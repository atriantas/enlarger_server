<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Darkroom Timer</title>
    <style>
      /* ===== CONSOLIDATED STYLES FOR REDUCED REDUNDANCY ===== */
      /* The following similar classes have been consolidated:
         1. List containers: .chemical-preset-list + .shelf-life-list (replaces .profile-list)
         2. List items: .shelf-life-item (replaces .chemical-preset-item, .profile-item, .list-item, .relay-item)
         3. Toggle buttons: .toggle-btn (replaces .paper-btn, .paper-size-btn, 
            .dilution-btn, .method-btn, .color-scheme-btn, .btn-toggle, .paper-size-buttons)
         4. Action buttons: .btn-action (replaces .chemical-preset-btn, .shelf-life-btn, .profile-btn)
         5. Action containers: .shelf-life-actions (replaces .chemical-preset-actions)
         6. Flex containers: .custom-dilution (replaces .custom-paper-size)
         7. Flexible buttons: .settings-btn (replaces .repeat-btn, .btn-flex, .relay-toggle-btn) - uses inline styles for specific variants
         8. Settings buttons: .settings-btn consolidates .preset-btn, .capacity-btn, .global-btn
         9. Panel containers: .incremental-timer (replaces .test-strip-preview-container, 
            .chemical-calculator, .chemical-presets, .capacity-tracker, .shelf-life-tracker, .instructions-panel, .panel-base, .panel-container, .contrast-calculator)
         10. Label classes: .label-sm (replaces .info-label, .chemical-label-sm)
         11. Value classes: .value-display (replaces .result-value, .chemical-result-value)
         12. 3-column grid selectors: .dilution-selector (replaces .color-scheme-selector)
         13. Full-width action buttons: .settings-btn (replaces .fullscreen-btn)
         14. Medium label classes: .setting-label (replaces .sound-label, .preview-label) - CONSOLIDATED
         15. Select dropdowns: .settings-input (replaces .fstop-select)
         16. Panel containers: .incremental-timer (replaces .timer-settings)
         17. Button groups: .settings-btn-group (replaces .global-controls, .timer-controls)
         18. Section headers: .title-sm (replaces .timer-status)
         19. Flex groups: .flex-group (replaces .preview-legend, .preview-options) - CONSOLIDATED into .shelf-life-actions
         20. Step info containers: .current-step-info - CONSOLIDATED into .shelf-life-actions with inline styles
         21. Progress bars: .progress-bar (replaces .progress-fill) - uses gradient background for all progress indicators
         22. Progress labels: .progress-labels (replaces .test-progress-labels) - consolidated into single class
         23. Panel containers: .incremental-timer (replaces .test-presets) - uses inline styles for light background variants
         24. Button grids: .settings-group (replaces .preset-buttons) - uses 2-column grid layout
         25. Method selectors: .settings-group (replaces .method-selector) - uses 2-column grid layout with inline styles
         All variants use the same base styles with class-specific overrides.
      */

      /* ===== CSS VARIABLES - PRECISE MATCH TO ORIGINAL ===== */
      :root {
        /* Dark Scheme (Original Default) - EXACT matches */
        --bg: #000;
        --text: #f00;
        --text-secondary: #900;

        --accent: #f00;
        --accent-dark: #700;

        --panel: #100;
        --panel-light: #200;

        --border: #300;
        --border-light: #400;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #300, #600, #f00);
      }

      /* Light Scheme - Clean grey tones with blue accent */
      body.light-scheme {
        --bg: #ffffff;
        --text: #1a1a1a;
        --text-secondary: #666666;

        --accent: #3a86de;
        --accent-dark: #2769ac;

        --panel: #e0e0e0;
        --panel-light: #f2f2f2;

        --border: #a0a0a0;
        --border-light: #bdbdbd;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #bdbdbd, #757575, #2196f3);
      }

      /* Day Scheme - Dark grey tones with blue accent */
      body.day-scheme {
        --bg: #040404;
        --text: #e0e0e0;
        --text-secondary: #9e9e9e;

        --accent: #3a86de;
        --accent-dark: #2769ac;

        --panel: #1e1e1e;
        --panel-light: #2d2d2d;

        --border: #424242;
        --border-light: #616161;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #424242, #757575, #42a5f5);
      }

      /* ===== BASE STYLES (IDENTICAL TO ORIGINAL) ===== */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        line-height: 1.3;
        padding: 6px;
        min-height: 100vh;
        transition: background-color 0.3s, color 0.3s;
        overflow: hidden; /* Hide scrollbar */
      }

      .container {
        max-width: 480px;
        margin: 0 auto;
        height: 100vh; /* Full viewport height */
        overflow-y: auto; /* Allow scrolling within container */
        scrollbar-width: none; /* Firefox */
      }

      /* Hide scrollbar for Chrome, Safari and Opera */
      .container::-webkit-scrollbar {
        display: none;
      }

      /* ===== HEADER (EXACT MATCH) ===== */
      header {
        text-align: center;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--border);
      }

      h1 {
        font-size: 1.2rem;
        margin-bottom: 3px;
      }

      /* ===== TABS (EXACT MATCH) ===== */
      .tabs {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 8px;
        border-bottom: 1px solid var(--border);
        gap: 2px;
      }

      .tab-button {
        flex: 0 0 auto;
        min-width: 70px;
        padding: 6px 8px;
        background: var(--panel-light);
        color: var(--text);
        border: none;
        border-radius: 12px 12px 0px 0px;
        font-size: 0.8rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .tab-button.active {
        color: var(--bg);
        border-bottom: 2px solid var(--title);
        background: var(--text-secondary);
        border-radius: 12px 12px 0px 0px;
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      /* ===== CALCULATOR CONTROLS (EXACT MATCH) ===== */
      .control {
        margin-bottom: 10px;
      }

      /* control-label now consolidated with settings-label */

      .slider {
        width: 100%;
        height: 24px;
        appearance: none;
        -webkit-appearance: none;
        background: transparent;
      }

      .slider::-webkit-slider-runnable-track {
        width: 100%;
        height: 3px;
        background: var(--slider-track);
      }

      .slider::-webkit-slider-thumb {
        appearance: none;
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--accent);
        margin-top: -8px;
      }

      /* Unified result display containers */
      .info-box {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        text-align: center;
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
      }

      .timer-display {
        font-size: 2.5rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-weight: bold;
        text-align: center;
        margin: 10px 0;
        color: var(--text);
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* ===== BUTTON STYLES (EXACT MATCH) ===== */
      .exp-btn {
        flex: 1;
        padding: 8px;
        background: var(--accent);
        border: 1px solid var(--accent-dark);
        color: var(--bg);
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: bold;
        cursor: pointer;
        min-width: 120px;
        min-height: 60px;
      }

      .exp-btn.active {
        background: var(--border-light);
        border-color: var(--accent);
      }

      .exp-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .exp-btn.warning {
        border-color: var(--warning);
        animation: pulse 1s infinite;
      }

      .exp-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 10px;
      }

      /* info-box is the unified result display container */

      /* Unified small label class - consolidates info-label, label-sm, chemical-label-sm, label-sm */
      .label-sm {
        font-size: 0.65rem;
        color: var(--text-secondary);
        margin-bottom: 3px;
      }

      /* Unified value display class - consolidates result-value, chemical-result-value */
      .value-display {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-weight: bold;
        color: var(--text);
        font-size: 0.8rem;
      }

      /* ===== TIMER GRID (EXACT MATCH) ===== */
      .timer-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 8px;
        height: 320px;
        margin-bottom: 10px;
      }

      .timer-box {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
      }

      /* Disabled state - black and red only */
      .timer-box.disabled {
        background: var(--border-light);
        border-color: var(--border-light);
        color: var(--border-light);
        color: var(--text-secondary);
        opacity: 0.2;
        cursor: not-allowed;
      }

      .timer-btn .time-display {
        background: var(--border-light);
        border-color: var(--border-light);
        color: var(--text-secondary);
        cursor: not-allowed;
      }

      /* Unified title classes */
      .title-sm {
        font-size: 0.75rem;
        color: var(--text);
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .title-md {
        font-size: 0.9rem;
        color: var(--title);
        margin-bottom: 8px;
        text-transform: uppercase;
      }

      .time-display {
        font-size: 1.6rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-weight: bold;
        color: var(--text);
        margin: 4px 0;
        text-align: center;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .timer-controls-2 {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .adjust-row {
        display: flex;
        gap: 6px;
        margin-bottom: 2px;
      }

      .timer-btn {
        flex: 1;
        padding: 4px;
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 6px;
        font-size: 0.7rem;
        cursor: pointer;
        white-space: nowrap;
      }

      .timer-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .timer-btn.active {
        background: var(--border);
        border-color: var(--accent);
      }

      /* Timer states */
      .timer-box.running {
        border-color: var(--accent);
        background: var(--panel-light);
      }

      .timer-box.warning {
        border-color: var(--warning);
        animation: pulse 1s infinite;
      }

      .timer-box.complete {
        border-color: var(--accent);
        background: var(--border);
      }

      .settings-section {
        margin-bottom: 10px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 10px;
      }

      .settings-section:last-child {
        border-bottom: none;
      }

      /* settings-title now uses .title-md */

      .settings-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }

      .settings-item {
        display: flex;
        flex-direction: column;
        gap: 3px;
      }

      /* Unified label for form controls */
      .control-label,
      .settings-label {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }

      .control-label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 3px;
      }

      /* Base input field (consolidated) */
      .settings-input {
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text);
        padding: 4px 6px;
        font-size: 0.8rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        flex: auto;
      }

      .settings-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      /* Unified list container - consolidates chemical-preset-list, shelf-life-list */
      .shelf-life-list {
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        max-height: 200px;
        overflow-y: auto;
        margin-top: 10px;
        margin-bottom: 10px;
      }

      /* Unified list item - replaces chemical-preset-item, shelf-life-item */
      .shelf-life-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        border-bottom: 1px solid var(--border);
        font-size: 0.75rem;
      }

      .shelf-life-item:last-child {
        border-bottom: none;
      }

      .shelf-life-item.active {
        background: var(--border);
        font-weight: bold;
      }

      .settings-btn {
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 6px;
        padding: 6px 12px;
        font-size: 0.8rem;
        cursor: pointer;
        width: 100%;
      }

      .settings-btn.primary {
        background: var(--border-light);
        border-color: var(--accent);
        margin-top: 0.5rem;
      }

      .settings-btn.danger {
        background: var(--border);
        border-color: var(--accent);
      }

      .settings-btn-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }

      .settings-btn-group .settings-btn {
        flex: 1;
      }

      /* setting-item now uses .item-container */

      /* Unified medium label class - consolidates setting-label, preview-label */
      .setting-label {
        font-size: 0.7rem;
        white-space: nowrap;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 28px;
        height: 14px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider-switch {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--border);
        transition: 0.2s;
        border-radius: 6px;
      }

      .slider-switch:before {
        position: absolute;
        content: "";
        height: 10px;
        width: 10px;
        left: 2px;
        bottom: 2px;
        background-color: var(--bg);
        transition: 0.2s;
        border-radius: 50%;
      }

      input:checked + .slider-switch {
        background-color: var(--accent);
      }

      input:checked + .slider-switch:before {
        transform: translateX(14px);
      }

      /* chemical-result-box removed - using info-box instead */

      /* chemical-label-sm now uses .label-sm */
      /* chemical-result-value uses unified value classes */

      .test-strip-preview {
        display: flex;
        height: 60px;
        margin: 10px 0;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
      }

      .test-step {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: background-color 0.3s;
      }

      .test-step.active {
        background: var(--border-light) !important;
      }

      .step-time {
        font-size: 0.6rem;
        font-weight: bold;
        color: var(--bg);
        text-align: center;
        z-index: 2;
      }

      .step-stop {
        font-size: 0.6rem;
        color: var(--bg);
        margin-top: 2px;
      }

      /* ===== FOOTER (EXACT MATCH) ===== */
      footer {
        text-align: center;
        margin-top: 10px;
        padding-top: 6px;
        border-top: 1px solid var(--border);
        font-size: 0.6rem;
        color: var(--text-secondary);
      }

      /* ===== ANIMATIONS (EXACT MATCH) ===== */
      @keyframes pulse {
        0% {
          border-color: var(--warning);
        }
        50% {
          border-color: var(--warning);
        }
        100% {
          border-color: var(--warning);
        }
      }

      /* ===== THE REST OF THE ORIGINAL STYLES WITH VARIABLES ===== */

      /* Chart styles */

      .time-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.7rem;
      }

      .time-table th,
      .time-table td {
        padding: 5px 3px;
        text-align: center;
        border-bottom: 1px solid var(--border);
      }

      .time-table th {
        background: var(--panel-light);
        color: var(--text);
        border-bottom: 1px solid var(--border);
        white-space: nowrap;
      }

      .time-table tr:nth-child(even) {
        background: var(--panel);
      }

      /* increment-cell can use .label-sm */

      /* Unified flex control groups */
      .sound-controls {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
      }

      /* .repeat-btn consolidated into .settings-btn with inline styles */
      /* .paper-size-buttons consolidated into .dilution-selector with inline styles */
      /* .custom-paper-size consolidated into .custom-dilution */

      /* Panel container for all panel-style sections */
      .incremental-timer {
        background: var(--panel);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
        margin-bottom: 10px;
      }

      /* 2-column grid layouts */
      .paper-selector {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }

      /* Base toggle button (consolidated for all variants) */
      .toggle-btn {
        padding: 8px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text);
        cursor: pointer;
        text-align: center;
        font-size: 0.75rem;
      }

      .toggle-btn.active {
        background: var(--border);
        border-color: var(--border-light);
        font-weight: bold;
      }

      /* Chemical management styles */
      .dilution-selector {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 10px;
      }

      /* Flex containers for various controls */
      .custom-dilution,
      .capacity-controls {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .capacity-controls {
        margin: 10px 0;
      }

      .custom-dilution input {
        flex: 1;
        text-align: center;
        padding: 4px 6px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text);
        font-size: 0.8rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      /* Unified input focus already handled by .settings-input:focus */

      /* Unified flex-row class for action buttons - replaces .chemical-preset-actions */
      .shelf-life-actions {
        display: flex;
        gap: 6px;
      }

      /* Base action button - replaces .chemical-preset-btn, .shelf-life-btn */
      .btn-action {
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--accent);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 0.65rem;
        cursor: pointer;
      }

      .btn-action.delete {
        border-color: var(--accent);
        color: var(--accent);
      }

      .btn-action {
        min-width: 50px;
      }

      .progress-container {
        height: 8px;
        background: var(--border);
        border-radius: 6px;
        overflow: hidden;
        margin: 10px 0;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--border-light), var(--accent));
        width: 0%;
        transition: width 0.5s ease;
      }

      .progress-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
        color: var(--text-secondary);
        margin-top: 5px;
      }

      /* Paper Size Selector */
      .paper-size-selector {
        margin-top: 10px;
        margin-bottom: 10px;
      }

      .custom-dilution input {
        flex: 1;
        text-align: center;
      }

      /* .shelf-life-list styles consolidated above */

      .shelf-life-item:last-child {
        border-bottom: none;
      }

      .shelf-life-item.expiring {
        background: var(--panel-light);
        border-left: 3px solid var(--accent);
      }

      .shelf-life-item.expired {
        background: var(--panel);
        border-left: 3px solid var(--accent);
        animation: pulse 2s infinite;
      }

      .shelf-life-days {
        font-weight: bold;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .shelf-life-days.expiring {
        color: var(--warning);
      }

      .shelf-life-days.expired {
        color: var(--accent);
      }

      .shelf-life-actions {
        display: flex;
        gap: 4px;
      }

      /* F-STOP TEST STRIP GENERATOR STYLES */
      /* preview-controls now consolidated with sound-controls */

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.7rem;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 6px;
      }

      .test-timer-display {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 10px 0;
      }

      /* label-sm now uses .label-sm, value-display uses unified value classes */

      .test-progress-container {
        margin: 15px 0;
      }

      .test-progress-bar {
        height: 6px;
        background: var(--border);
        border-radius: 6px;
        overflow: hidden;
        position: relative;
      }

      /* Countdown display styles */
      .countdown-active {
        animation: countdown-pulse 1s infinite;
      }

      @keyframes countdown-pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .control input:checked + .slider-switch {
        background-color: var(--accent);
      }

      /* ===== FULLSCREEN STYLES ===== */
      body.fullscreen-mode {
        padding: 0;
      }

      /* Container: use a single canonical set of rules for fullscreen */
      body.fullscreen-mode .container {
        max-width: 960px;
        margin: 0 auto;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* container shouldn't scroll; tab content should */
      }

      /* Tabs should stay at top in fullscreen */
      body.fullscreen-mode .tabs {
        border-bottom: 1px solid var(--border);
        margin-bottom: 0;
        flex-shrink: 0;
      }

      body.fullscreen-mode .tab-button {
        padding: 12px 3px;
      }

      /* Hide header and footer in fullscreen */
      body.fullscreen-mode header,
      body.fullscreen-mode footer {
        display: none;
      }

      /* Tab content: scrollable and flexible in fullscreen */
      body.fullscreen-mode .tab-content.active {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 8px;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      /* Ensure tab contents are scrollable by default in fullscreen */
      body.fullscreen-mode .tab-content {
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      body.fullscreen-mode .tab-content::-webkit-scrollbar {
        display: none;
      }

      /* Timer tab specific adjustments */
      body.fullscreen-mode #timer.tab-content.active {
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      /* Settings tab adjustments */
      body.fullscreen-mode #settings.tab-content.active {
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* Collapsible rows in CALC tab */
      .collapsible {
        border-top: 1px solid var(--border);
        margin-top: 10px;
        padding-top: 6px;
      }
      .collapsible-header {
        width: 100%;
        text-align: left;
        background: transparent;
        border: none;
        color: var(--text);
        font-weight: bold;
        padding: 8px 6px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95rem;
      }
      .collapsible-header::after {
        content: "▾";
        transition: transform 0.2s ease;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }
      .collapsible-header[aria-expanded="false"]::after {
        transform: rotate(-90deg);
      }
      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.28s ease;
        max-height: 0;
      }
      .collapsible .exp-info {
        margin-top: 6px;
      }
      .collapsible .info-box {
        margin-bottom: 6px;
      }

      /* -------------------------------------------------------------
         Controls: Segmented control (increment selectors)
         - Clear, accessible focus styles using --accent
         - Responsive adjustments for small screens
         - Small wrap behavior so controls remain usable on narrow widths
         ------------------------------------------------------------- */
      .segmented-control {
        display: inline-flex;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
        background: var(--panel);
        align-items: center;
        gap: 0; /* buttons are visually separated by borders */
      }

      .segmented-control .segmented-btn {
        background: transparent;
        border: none;
        padding: 8px 12px;
        cursor: pointer;
        color: var(--text);
        font-size: 0.9rem;
        min-width: 44px;
        text-align: center;
        line-height: 1;
      }

      .segmented-control .segmented-btn:not(:last-child) {
        border-right: 1px solid var(--border);
      }

      .segmented-control .segmented-btn.active,
      .segmented-control .segmented-btn[aria-pressed="true"] {
        background: var(--border-light);
        color: var(--accent);
      }

      /* Prefer the more semantic :focus-visible when available */
      .segmented-control .segmented-btn:focus {
        outline: none;
      }
      .segmented-control .segmented-btn:focus-visible {
        /* Use accent color for the outline if available, with a subtle shadow for depth */
        outline: 2px solid var(--accent);
        box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.12);
        z-index: 1;
      }

      /* Container for segmented controls (centers buttons) */
      .segmented-control-container {
        margin-top: 6px;
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
      }

      /* Accessibility helper: visually-hidden */
      .visually-hidden {
        position: absolute !important;
        height: 1px;
        width: 1px;
        overflow: hidden;
        clip: rect(1px, 1px, 1px, 1px);
        white-space: nowrap;
        border: 0;
        padding: 0;
        margin: -1px;
      }

      /* Custom filter bank layout */
      .custom-filter-header {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }

      .custom-filter-rows {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }

      .custom-filter-row {
        display: grid;
        grid-template-columns: 1.1fr 0.6fr 0.6fr;
        gap: 6px;
        align-items: center;
      }

      .custom-filter-row input[type="text"] {
        width: 100%;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .custom-filter-row input[type="number"] {
        width: 100%;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .custom-filter-row button {
        padding: 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--accent-muted);
        color: var(--text);
        cursor: pointer;
      }

      .custom-filter-row button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Relay styles remain outside fullscreen concerns */
      /* relay-controls now consolidated with .incremental-timer */

      /* .relay-item consolidated into .shelf-life-item with inline styles */

      /* .relay-toggle-btn consolidated into .settings-btn with inline styles */

      /* Mobile adjustments for fullscreen with profiles */
      @media (max-width: 400px) {
        body.fullscreen-mode #timer .timer-grid {
          height: auto; /* Maintain flexible height */
          min-height: 320px; /* ensure space for 2x2 grid */
          display: grid; /* keep 2-column grid in fullscreen on mobile */
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          gap: 6px;
        }
      }

      /* Desktop adjustments */
      @media (min-width: 401px) {
        /* Fullscreen mode adjustments for desktop */
        body.fullscreen-mode .timer-grid {
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          height: auto; /* Changed from calc(100vh - 120px) */
        }

        /* Ensure timer tab can scroll and the grid can flex in fullscreen on wider screens */
        body.fullscreen-mode #timer.tab-content.active {
          display: flex;
          flex-direction: column;
          min-height: 0; /* allow flex children to shrink */
          overflow-y: auto; /* enable scrolling if content overflows */
          -webkit-overflow-scrolling: touch;
        }
      }

      /* ===== MOBILE STYLES - EXACT MATCH ===== */
      @media (max-width: 400px) {
        /* Calculator info - 2 columns on mobile */
        .exp-info {
          grid-template-columns: 1fr 1fr;
        }

        /* Settings - 2 columns on mobile */
        .settings-group {
          grid-template-columns: 1fr 1fr;
        }

        /* Chemical management mobile adjustments */
        .dilution-selector {
          grid-template-columns: repeat(2, 1fr);
        }

        .capacity-controls {
          flex-direction: column;
        }

        /* Fullscreen mode adjustments for mobile */
        body.fullscreen-mode {
          padding: 0;
        }

        body.fullscreen-mode .container {
          padding: 0;
        }

        body.fullscreen-mode .tabs {
          margin-bottom: 0;
          border-bottom: none;
        }

        /* Test strip mobile adjustments */
        .test-timer-display {
          flex-direction: column;
          gap: 5px;
        }

        .paper-selector {
          grid-template-columns: 1fr;
        }
        .segmented-control {
          flex-wrap: wrap;
          justify-content: center;
        }
        .segmented-control .segmented-btn {
          padding: 6px 8px;
          min-width: 36px;
          font-size: 0.85rem;
        }
        .segmented-control-container {
          gap: 6px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>CYANOWOOD TIMER & TOOLS</h1>
      </header>

      <!-- Accessibility: live status for settings updates -->
      <div
        id="settingsLiveStatus"
        class="visually-hidden"
        aria-live="polite"
        aria-atomic="true"
      ></div>

      <div class="tabs">
        <button class="tab-button active" data-tab="calc">CALC</button>
        <button class="tab-button" data-tab="fstop-test">TEST</button>
        <button class="tab-button" data-tab="timer">TIMER</button>
        <button class="tab-button" data-tab="relay">CONTROL</button>
        <button class="tab-button" data-tab="chemical">CHEMICAL</button>
        <button class="tab-button" data-tab="chart">CHART</button>
        <button class="tab-button" data-tab="settings">SETTINGS</button>
      </div>

      <!-- Calculator Tab with Incremental Exposure Timer -->
      <div id="calc" class="tab-content active">
        <div class="control">
          <div class="control-label">
            <span>BASE TIME</span>
            <span class="value-display" id="baseTimeValue">10.0s</span>
          </div>
          <input
            type="range"
            min="0.4"
            max="50"
            step="0.1"
            value="10"
            class="slider"
            id="baseTimeSlider"
          />
        </div>

        <div class="control">
          <div class="control-label">
            <span>STOP ADJUST</span>
            <span class="value-display" id="stopValue">0.0</span>
          </div>
          <input
            type="range"
            min="-6"
            max="6"
            step="1"
            value="0"
            class="slider"
            id="stopSlider"
          />

          <!-- Dynamic ruler that will be populated based on selected increment denominator -->
          <div
            id="calcStopRuler"
            style="
              display: flex;
              justify-content: space-between;
              margin-top: 5px;
              padding: 0 5px;
            "
          >
            <!-- labels populated by JS -->
          </div>

          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="calcIncrementSeg"
              role="tablist"
              aria-label="Calc stop increment"
            >
              <button
                type="button"
                class="segmented-btn"
                data-denom="1"
                aria-pressed="false"
              >
                1
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="2"
                aria-pressed="false"
              >
                1/2
              </button>
              <button
                type="button"
                class="segmented-btn active"
                data-denom="3"
                aria-pressed="true"
              >
                1/3
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="4"
                aria-pressed="false"
              >
                1/4
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="6"
                aria-pressed="false"
              >
                1/6
              </button>
            </div>
          </div>
        </div>

        <div class="info-box">
          <div class="label-sm">SELECTED EXPOSURE</div>
          <div class="value-display" id="resultTime" style="font-size: 1.2rem">
            10.00
          </div>
          <div class="label-sm" id="resultDetails">BASE (0.0 stops)</div>
        </div>

        <!-- Simplified Incremental Exposure Timer -->
        <div class="incremental-timer">
          <div class="title-sm" id="timerStatus" style="text-align: center">
            READY FOR EXPOSURE
          </div>
          <div class="timer-display" id="calcTimerDisplay">10.00</div>

          <div class="sound-controls">
            <div>
              <div class="setting-label">3s Beeps</div>
              <label class="switch">
                <input type="checkbox" id="calcWarningBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
            <div>
              <div class="setting-label">End Beep</div>
              <label class="switch">
                <input type="checkbox" id="calcEndBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
          </div>

          <div class="settings-btn-group">
            <button class="exp-btn" id="startExposure">Start Exposure</button>
            <button class="exp-btn" id="stopCalcTimer" disabled>Stop</button>
            <button class="exp-btn" id="resetCalcTimer">Reset</button>
            <button
              class="settings-btn"
              id="repeatExposure"
              disabled
              style="
                flex: 1;
                font-size: 0.9rem;
                font-weight: bold;
                padding: 8px;
              "
            >
              Repeat Last
            </button>
          </div>

          <!-- Simplified Information Display -->
          <div class="exp-info">
            <div class="info-box">
              <div class="label-sm">Selected Stop</div>
              <div class="value-display" id="selectedStopDisplay">0.0</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Previous Total</div>
              <div class="value-display" id="previousTotalDisplay">0.00</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Current Total</div>
              <div class="value-display" id="currentTotalDisplay">10.00</div>
            </div>
            <div class="info-box">
              <div class="label-sm">This Exposure</div>
              <div class="value-display" id="thisExposureDisplay">10.00</div>
            </div>
          </div>
        </div>

        <!-- MODIFIED ENLARGER HEIGHT CALCULATOR WITH CONTRAST CONTROL INTEGRATED -->
        <div class="incremental-timer" style="margin-top: 10px">
          <div class="title-sm" style="text-align: center">
            ENLARGER & CONTRAST CALCULATOR
          </div>
          <!-- Original Settings Section -->
          <div class="info-box">
            <div class="label-sm">Original Time (s)</div>
            <div class="value-display" id="originalTimeValue">10.00</div>
            <div style="display: flex; gap: 5px; margin-top: 5px">
              <button
                class="timer-btn"
                id="copyCurrentTime"
                style="flex: 1; font-size: 0.6rem; padding: 2px 4px"
              >
                Use Current
              </button>
            </div>
          </div>

          <!-- Height Adjustments -->
          <section class="collapsible" data-id="head-height">
            <button class="collapsible-header" aria-expanded="false">
              Head Height Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="label-sm">Original Height (cm)</div>
                  <div class="value-display" id="originalHeightValue">30.0</div>
                  <div style="margin-top: 5px">
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-bottom: 2px;
                      "
                    >
                      Coarse adjustment
                    </div>
                    <input
                      type="range"
                      min="10"
                      max="60"
                      step="1"
                      value="30"
                      class="slider"
                      id="originalHeightCoarseSlider"
                    />
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-top: 3px;
                        margin-bottom: 2px;
                      "
                    >
                      Fine adjustment (±0.5cm)
                    </div>
                    <input
                      type="range"
                      min="-5"
                      max="5"
                      step="1"
                      value="0"
                      class="slider"
                      id="originalHeightFineSlider"
                      style="height: 16px"
                    />
                  </div>
                </div>
                <div class="info-box">
                  <div class="label-sm">New Height (cm)</div>
                  <div class="value-display" id="newHeightValue">30.0</div>
                  <div style="margin-top: 5px">
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-bottom: 2px;
                      "
                    >
                      Coarse adjustment
                    </div>
                    <input
                      type="range"
                      min="10"
                      max="60"
                      step="1"
                      value="30"
                      class="slider"
                      id="newHeightCoarseSlider"
                    />
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-top: 3px;
                        margin-bottom: 2px;
                      "
                    >
                      Fine adjustment (±0.5cm)
                    </div>
                    <input
                      type="range"
                      min="-5"
                      max="5"
                      step="1"
                      value="0"
                      class="slider"
                      id="newHeightFineSlider"
                      style="height: 16px"
                    />
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- F-Stop Adjustment -->
          <section class="collapsible" data-id="fstop">
            <button class="collapsible-header" aria-expanded="false">
              F-Stop Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="label-sm">Original F-Stop</div>
                  <select
                    class="settings-input"
                    id="originalFStop"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="2.8">f/2.8</option>
                    <option value="4">f/4</option>
                    <option value="5.6" selected>f/5.6</option>
                    <option value="8">f/8</option>
                    <option value="11">f/11</option>
                    <option value="16">f/16</option>
                    <option value="22">f/22</option>
                    <option value="32">f/32</option>
                  </select>
                </div>
                <div class="info-box">
                  <div class="label-sm">New F-Stop</div>
                  <select
                    class="settings-input"
                    id="newFStop"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="2.8">f/2.8</option>
                    <option value="4">f/4</option>
                    <option value="5.6" selected>f/5.6</option>
                    <option value="8">f/8</option>
                    <option value="11">f/11</option>
                    <option value="16">f/16</option>
                    <option value="22">f/22</option>
                    <option value="32">f/32</option>
                  </select>
                </div>
              </div>
            </div>
          </section>

          <!-- Paper Size Adjustment -->
          <section class="collapsible" data-id="paper-size">
            <button class="collapsible-header" aria-expanded="false">
              Paper Size Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 0"
              >
                <!-- Original Paper Size -->
                <div class="info-box">
                  <div class="label-sm">Original Paper Size</div>
                  <select
                    class="settings-input"
                    id="originalPaperSize"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="0.011">3.5×5" (0.011 m²)</option>
                    <option value="0.013">4×5" (0.013 m²)</option>
                    <option value="0.023">5×7" (0.023 m²)</option>
                    <option value="0.052" selected>8×10" (0.052 m²)</option>
                    <option value="0.099">11×14" (0.099 m²)</option>
                    <option value="0.206">16×20" (0.206 m²)</option>
                    <option value="custom">Custom size...</option>
                  </select>
                  <!-- ADD "style" attribute to this div -->
                  <div
                    id="originalCustomPaperSize"
                    style="display: none; margin-top: 5px"
                  >
                    <input
                      type="number"
                      min="0.001"
                      max="1"
                      step="0.001"
                      value="0.052"
                      class="settings-input"
                      id="originalCustomPaperSizeValue"
                      placeholder="m²"
                      style="width: 80px; font-size: 0.7rem"
                    />
                    <button
                      class="timer-btn"
                      id="setOriginalCustomPaper"
                      style="font-size: 0.6rem; padding: 2px 4px"
                    >
                      Set
                    </button>
                  </div>
                </div>

                <!-- New Paper Size -->
                <div class="info-box">
                  <div class="label-sm">New Paper Size</div>
                  <select
                    class="settings-input"
                    id="newPaperSize"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="0.011">3.5×5" (0.011 m²)</option>
                    <option value="0.013">4×5" (0.013 m²)</option>
                    <option value="0.023">5×7" (0.023 m²)</option>
                    <option value="0.052" selected>8×10" (0.052 m²)</option>
                    <option value="0.099">11x14" (0.099 m²)</option>
                    <option value="0.206">16x20" (0.206 m²)</option>
                    <option value="custom">Custom size...</option>
                  </select>
                  <!-- ADD "style" attribute to this div -->
                  <div
                    id="newCustomPaperSize"
                    style="display: none; margin-top: 5px"
                  >
                    <input
                      type="number"
                      min="0.001"
                      max="1"
                      step="0.001"
                      value="0.052"
                      class="settings-input"
                      id="newCustomPaperSizeValue"
                      placeholder="m²"
                      style="width: 80px; font-size: 0.7rem"
                    />
                    <button
                      class="timer-btn"
                      id="setNewCustomPaper"
                      style="font-size: 0.6rem; padding: 2px 4px"
                    >
                      Set
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- CONTRAST CONTROL INTEGRATED -->
          <section class="collapsible" data-id="contrast-filter">
            <button class="collapsible-header" aria-expanded="false">
              Foma Contrast Filter Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="label-sm">Paper Type</div>
                  <div class="paper-selector" style="margin-top: 5px">
                    <button
                      class="toggle-btn active"
                      data-paper="fomaspeed"
                      id="btnFomaspeed"
                    >
                      FOMASPEED<br />Variant III
                    </button>
                    <button
                      class="toggle-btn"
                      data-paper="fomatonemg"
                      id="btnFomatonemg"
                    >
                      FOMATONE MG<br />Classic
                    </button>
                  </div>
                </div>
                <div class="info-box">
                  <div class="label-sm">Contrast Filter</div>
                  <select
                    class="settings-input"
                    id="contrastFilterSelect"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="2xY">2×Y</option>
                    <option value="Y">Y</option>
                    <option value="none" selected>No filter</option>
                    <option value="M1">M1</option>
                    <option value="2xM1">2×M1</option>
                    <option value="M2">M2</option>
                    <option value="2xM2">2×M2</option>
                  </select>
                  <div
                    class="exp-info"
                    style="grid-template-columns: 1fr 1fr; margin-top: 5px"
                  >
                    <div class="info-box" style="padding: 3px">
                      <div class="label-sm">ISO R</div>
                      <div class="value-display" id="isoValue">105</div>
                    </div>
                    <div class="info-box" style="padding: 3px">
                      <div class="label-sm">Contrast Factor</div>
                      <div class="value-display" id="filterFactorValue">
                        1.0×
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- Custom Filter Bank -->
          <section class="collapsible" data-id="custom-filter-bank">
            <button class="collapsible-header" aria-expanded="false">
              Custom Factor Bank
            </button>
            <div class="collapsible-content">
              <div class="custom-filter-header">
                <div>
                  <div class="label-sm">Group</div>
                  <select
                    class="settings-input"
                    id="customFilterGroup"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="0">Group A</option>
                    <option value="1">Group B</option>
                    <option value="2">Group C</option>
                  </select>
                </div>
                <div>
                  <div class="label-sm">Group Name</div>
                  <input
                    type="text"
                    id="customFilterGroupName"
                    class="settings-input"
                    placeholder="Group name"
                    style="width: 100%"
                  />
                </div>
              </div>

              <div
                style="
                  font-size: 0.8rem;
                  color: var(--text-secondary);
                  margin-bottom: 6px;
                "
              >
                Store up to 12 named factors per group (3 groups). Use these to
                drive the Contrast Factor used in New Adjusted Time. Values
                auto-save and are included in Export All Data.
              </div>

              <div class="custom-filter-rows" id="customFilterRows"></div>
            </div>
          </section>

          <!-- Combined Factors Display -->
          <div
            class="title-sm"
            style="text-align: center; font-size: 0.65rem; margin-top: 15px"
          >
            Factors & Time
          </div>
          <div
            class="exp-info"
            style="grid-template-columns: 1fr 1fr 1fr 1fr 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="label-sm">Height Factor</div>
              <div class="value-display" id="heightFactorDisplay">1.00x</div>
            </div>
            <div class="info-box">
              <div class="label-sm">F-Stop Factor</div>
              <div class="value-display" id="fstopFactor">1.00x</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Paper Factor</div>
              <div class="value-display" id="paperSizeFactor">1.00x</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Contrast Factor</div>
              <div class="value-display" id="filterFactorValueDisplay">
                1.00x
              </div>
            </div>
            <div class="info-box">
              <div class="label-sm">Custom Factor</div>
              <div class="value-display" id="customBankFactorDisplay">
                1.00x
              </div>
            </div>
          </div>

          <div
            class="exp-info"
            style="grid-template-columns: 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="label-sm">Combined Factor</div>
              <div class="value-display" id="combinedFactor">1.00x</div>
            </div>
          </div>

          <div
            class="exp-info"
            style="grid-template-columns: 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="label-sm">New Adjusted Time (s)</div>
              <div class="value-display" id="newAdjustedTime">10.00</div>
              <div
                style="
                  font-size: 0.6rem;
                  color: var(--text-secondary);
                  margin-top: 3px;
                "
              >
                Formula: Original Time × (New Height ÷ Original Height)² × (New
                F-Stop ÷ Original F-Stop)² × (√New Paper Area ÷ √Original Paper
                Area)² × Filter Factor
              </div>
            </div>
          </div>

          <div style="margin-top: 10px; text-align: center">
            <button
              class="exp-btn"
              id="applyHeightTime"
              style="margin-bottom: 5px"
            >
              Apply Adjusted Time as Base Time
            </button>
            <div
              style="
                font-size: 0.6rem;
                color: var(--text-secondary);
                margin-top: 3px;
              "
            >
              Example: 10s at 30cm, f/5.6, No filter → 22.5s at 45cm, f/5.6, No
              filter<br />
              Example with filter: 10s at f/5.6 → 14s with Y filter (1.4×
              factor)
            </div>
          </div>
        </div>
      </div>

      <!-- Chart Tab with Incremental Time Column -->
      <div id="chart" class="tab-content">
        <!-- BASE TIME slider removed per user request -->
        <div
          class="chart-note"
          role="note"
          title="This chart uses the main BASE TIME control in the CALC tab."
          aria-label="Chart uses base time from CALC"
          style="
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
          "
        >
          ⓘ Uses BASE TIME from CALC tab
        </div>

        <div style="overflow-x: auto; margin-bottom: 10px">
          <table
            class="time-table"
            id="timeTable"
            style="margin-left: -6px; margin-right: -6px"
          >
            <thead>
              <tr>
                <th>STOP</th>
                <th>TOTAL TIME</th>
                <th>+/- FROM BASE</th>
                <th>INCREMENT</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- F-Stop Test Strip Generator Tab -->
      <div id="fstop-test" class="tab-content">
        <div class="control">
          <div class="control-label">
            <span>BASE TIME</span>
            <span class="value-display" id="testBaseValue">10.0s</span>
          </div>
          <input
            type="range"
            min="1"
            max="50"
            step="0.5"
            value="10"
            class="slider"
            id="testBaseSlider"
          />
        </div>

        <div class="control">
          <div class="control-label">
            <span>INCREMENT (in stops)</span>
            <span class="value-display" id="testIncrementValue">⅓ stop</span>
          </div>
          <input
            type="range"
            min="1"
            max="9"
            step="1"
            value="1"
            class="slider"
            id="testIncrementSlider"
          />

          <!-- Dynamic ruler populated by JS based on denominator -->
          <div
            id="testIncrementRuler"
            style="
              display: flex;
              justify-content: space-between;
              margin-top: 5px;
              padding: 0 5px;
            "
          >
            <!-- labels populated by JS -->
          </div>

          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="testIncrementSeg"
              role="tablist"
              aria-label="Test stop increment"
            >
              <button
                type="button"
                class="segmented-btn"
                data-denom="1"
                aria-pressed="false"
              >
                1
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="2"
                aria-pressed="false"
              >
                1/2
              </button>
              <button
                type="button"
                class="segmented-btn active"
                data-denom="3"
                aria-pressed="true"
              >
                1/3
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="4"
                aria-pressed="false"
              >
                1/4
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="6"
                aria-pressed="false"
              >
                1/6
              </button>
            </div>
          </div>
        </div>

        <div class="control">
          <div class="control-label">
            <span>NUMBER OF STEPS</span>
            <span class="value-display" id="testStepsValue">6</span>
          </div>
          <input
            type="range"
            min="3"
            max="12"
            step="1"
            value="6"
            class="slider"
            id="testStepsSlider"
          />
        </div>

        <!-- NEW: Method Selector -->
        <div class="control">
          <div class="control-label">
            <span>METHOD</span>
            <span class="value-display" id="testMethodValue">Cumulative</span>
          </div>
          <div class="settings-group" style="margin-top: 5px; margin-bottom: 0">
            <button class="toggle-btn active" data-method="cumulative">
              Cumulative
            </button>
            <button class="toggle-btn" data-method="incremental">
              Incremental
            </button>
          </div>
        </div>

        <!-- NEW: Auto Advance Toggle -->
        <div class="control">
          <div class="control-label">
            <span>AUTO ADVANCE</span>
            <span class="value-display" id="autoAdvanceValue">OFF</span>
          </div>
          <label class="switch">
            <input type="checkbox" id="autoAdvanceToggle" />
            <span class="slider-switch"></span>
          </label>
          <div
            style="
              font-size: 0.6rem;
              color: var(--text-secondary);
              margin-top: 3px;
              text-align: center;
            "
          >
            <span id="autoAdvanceDescription">Pause after each step</span>
          </div>
        </div>

        <div class="info-box">
          <div class="label-sm">TEST STRIP SEQUENCE</div>
          <div
            class="value-display"
            id="testSequenceInfo"
            style="font-size: 1.2rem"
          >
            6 steps × ⅓ stop
          </div>
          <div class="label-sm" id="testTimeRange">10.00s to 31.75s</div>
        </div>

        <!-- UPDATED: Instructions Panel with Auto Advance Info -->
        <div class="incremental-timer">
          <div class="title-sm" style="text-align: center">INSTRUCTIONS</div>
          <div id="methodInstructions">
            <div
              class="cumulative-instructions"
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                line-height: 1.3;
                padding: 5px;
              "
            >
              <strong>CUMULATIVE METHOD:</strong><br />
              • Expose each strip for its total time<br />
              •
              <span id="cumulativeAdvanceText"
                >Auto-advance: OFF - Press Next Step between exposures</span
              >
            </div>
            <div
              class="incremental-instructions"
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                line-height: 1.3;
                padding: 5px;
                display: none;
              "
            >
              <strong>INCREMENTAL METHOD:</strong><br />
              • First strip: expose for base time<br />
              • Slide mask, expose next strip for difference<br />
              •
              <span id="incrementalAdvanceText"
                >Auto-advance: OFF - Press Next Step after sliding mask</span
              >
            </div>
          </div>
          <div
            style="
              margin-top: 5px;
              font-size: 0.6rem;
              color: var(--accent);
              text-align: center;
            "
          >
            <span id="autoAdvanceStatus">Current: Manual Advance</span>
          </div>
        </div>

        <!-- Visual Test Strip Preview -->
        <div class="incremental-timer">
          <div class="title-sm" style="text-align: center">
            TEST STRIP LAYOUT
          </div>
          <div class="test-strip-preview" id="testStripPreview">
            <!-- Will be populated by JavaScript -->
          </div>
          <div
            class="sound-controls"
            style="justify-content: space-between; align-items: center"
          >
            <div class="shelf-life-actions" style="gap: 15px">
              <div class="legend-item">
                <span class="legend-label"
                  >Select your preferred test strip</span
                >
              </div>
            </div>
            <div class="shelf-life-actions" style="align-items: center">
              <label class="switch">
                <input type="checkbox" id="previewMode" checked />
                <span class="slider-switch"></span>
              </label>
              <span class="setting-label">Show Times</span>
            </div>
          </div>
        </div>

        <!-- Test Strip Timer Controls -->
        <div class="incremental-timer" style="margin-top: 10px">
          <div class="title-sm" id="testTimerStatus" style="text-align: center">
            READY FOR TEST STRIP
          </div>
          <div class="test-timer-display">
            <div
              class="shelf-life-actions"
              style="
                flex: 1;
                align-items: center;
                justify-content: center;
                text-align: center;
                gap: 0;
              "
            >
              <div class="label-sm">Current Step</div>
              <div class="value-display" id="currentStepDisplay">1/6</div>
            </div>
            <div class="timer-display" id="testTimerDisplay">10.00</div>
            <div
              class="shelf-life-actions"
              style="
                flex: 1;
                align-items: center;
                justify-content: center;
                text-align: center;
                gap: 0;
              "
            >
              <div class="label-sm">Time</div>
              <div class="value-display" id="currentTimeDisplay">10.00s</div>
            </div>
          </div>

          <div class="test-progress-container">
            <div class="test-progress-bar" id="testProgressBar">
              <div class="progress-bar" id="progressFill"></div>
            </div>
            <div class="progress-labels">
              <span id="progressStart">10.0s</span>
              <span id="progressMiddle">19.0s</span>
              <span id="progressEnd">31.8s</span>
            </div>
          </div>

          <div class="sound-controls">
            <div>
              <div class="setting-label">3s Beeps</div>
              <label class="switch">
                <input type="checkbox" id="testWarningBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
            <div>
              <div class="setting-label">Step Beeps</div>
              <label class="switch">
                <input type="checkbox" id="testStepBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
            <div>
              <div class="setting-label">End Beep</div>
              <label class="switch">
                <input type="checkbox" id="testEndBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
          </div>

          <div class="settings-btn-group">
            <button class="exp-btn" id="startTestStrip">
              Start Test Strip
            </button>
            <button class="exp-btn" id="stopTestTimer" disabled>Stop</button>
            <button class="exp-btn" id="resetTestTimer">Reset</button>
          </div>

          <!-- Test Strip Information -->
          <div class="exp-info">
            <div class="info-box">
              <div class="label-sm">Step Size</div>
              <div class="value-display" id="stepSizeDisplay">0.0 stops</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Current Stop</div>
              <div class="value-display" id="currentStopDisplay">0.0</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Time Multiplier</div>
              <div class="value-display" id="timeMultiplierDisplay">1.00×</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Total Time</div>
              <div class="value-display" id="totalTestTimeDisplay">68.3s</div>
            </div>
          </div>

          <!-- Test Strip Profiles Section -->
          <section class="collapsible" data-id="test-strip-profiles">
            <button class="collapsible-header" aria-expanded="false">
              <div class="collapsible-title">TEST STRIP PROFILES</div>
            </button>
            <div class="collapsible-content">
              <div class="incremental-timer" style="margin-top: 15px">
                <div class="title-md">Test Strip Profiles</div>

                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Profile Name</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="testStripProfileName"
                      placeholder="Enter profile name"
                      maxlength="20"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label"> </div>
                    <button class="settings-btn" id="saveTestStripProfile">
                      Save Current as Profile
                    </button>
                  </div>
                </div>

                <div class="title-md">Saved Test Strip Profiles</div>
                <div class="shelf-life-list" id="testStripProfileList">
                  <!-- Test strip profiles will be listed here -->
                </div>

                <div class="settings-btn-group">
                  <button
                    class="settings-btn danger"
                    id="clearTestStripProfiles"
                  >
                    Clear All
                  </button>
                </div>
              </div>
            </div>
          </section>
        </div>
      </div>

      <!-- UPDATED: CHEMICAL MANAGEMENT TAB -->
      <div id="chemical" class="tab-content">
        <!-- Mix Calculator -->
        <section class="collapsible" data-id="chemical-mix">
          <button class="collapsible-header" aria-expanded="false">
            CHEMICAL MIX CALCULATOR
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                CHEMICAL MIX CALCULATOR
              </div>

              <div class="control">
                <div class="control-label">
                  <span>TOTAL VOLUME</span>
                  <span class="value-display" id="totalVolumeValue"
                    >1000ml</span
                  >
                </div>
                <input
                  type="range"
                  min="100"
                  max="5000"
                  step="50"
                  value="1000"
                  class="slider"
                  id="totalVolumeSlider"
                />
              </div>

              <div
                class="title-sm"
                style="
                  text-align: center;
                  font-size: 0.75rem;
                  margin-bottom: 8px;
                "
              >
                DILUTION RATIO
              </div>
              <div class="dilution-selector">
                <button class="toggle-btn active" data-ratio="1+9">
                  1+9 (1:10)
                </button>
                <button class="toggle-btn" data-ratio="1+14">
                  1+14 (1:15)
                </button>
                <button class="toggle-btn" data-ratio="1+19">
                  1+19 (1:20)
                </button>
                <button class="toggle-btn" data-ratio="1+24">
                  1+24 (1:25)
                </button>
                <button class="toggle-btn" data-ratio="1+29">
                  1+29 (1:30)
                </button>
                <button class="toggle-btn" data-ratio="1+39">
                  1+39 (1:40)
                </button>
              </div>

              <div
                class="title-sm"
                style="
                  text-align: center;
                  font-size: 0.75rem;
                  margin-top: 10px;
                  margin-bottom: 5px;
                "
              >
                OR CUSTOM RATIO
              </div>
              <div class="custom-dilution">
                <input
                  type="number"
                  min="1"
                  max="100"
                  value="1"
                  class="settings-input"
                  id="customStockParts"
                  placeholder="Stock"
                />
                <div style="color: var(--text-secondary); align-self: center">
                  +
                </div>
                <input
                  type="number"
                  min="1"
                  max="100"
                  value="9"
                  class="settings-input"
                  id="customWaterParts"
                  placeholder="Water"
                />
              </div>

              <div
                class="incremental-timer"
                style="background: var(--panel-light); margin-bottom: 0"
              >
                <div
                  class="title-sm"
                  style="text-align: center; font-size: 0.75rem"
                >
                  MIXING INSTRUCTIONS
                </div>
                <div class="chemical-results-grid">
                  <div class="info-box">
                    <div class="label-sm">STOCK SOLUTION</div>
                    <div
                      class="value-display"
                      id="stockVolume"
                      style="font-size: 1.2rem"
                    >
                      100ml
                    </div>
                  </div>
                  <div class="info-box">
                    <div class="label-sm">WATER</div>
                    <div
                      class="value-display"
                      id="waterVolume"
                      style="font-size: 1.2rem"
                    >
                      900ml
                    </div>
                  </div>
                </div>
                <div
                  style="
                    font-size: 0.6rem;
                    color: --text-secondary;
                    text-align: center;
                    margin-top: 8px;
                  "
                >
                  Add stock to water, not water to stock
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Chemical Presets Section - NEW -->
        <section class="collapsible" data-id="chemical-presets">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">CHEMICAL PRESETS</div>
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer" style="margin-top: 15px">
              <div class="title-md">Chemical Presets</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Preset Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="chemicalPresetName"
                    placeholder="Enter preset name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn" id="saveChemicalPreset">
                    Save Current as Preset
                  </button>
                </div>
              </div>

              <div class="title-md">Saved Chemical Presets</div>
              <div class="shelf-life-list" id="chemicalPresetList">
                <!-- Chemical presets will be listed here -->
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn danger" id="clearChemicalPresets">
                  Clear All
                </button>
              </div>
            </div>
          </div>
        </section>

        <!-- UPDATED: Developer Capacity Tracker with Paper Area Calculations -->
        <section class="collapsible" data-id="capacity-tracker">
          <button class="collapsible-header" aria-expanded="false">
            DEVELOPER CAPACITY TRACKER
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                DEVELOPER CAPACITY TRACKER
              </div>

              <div class="control">
                <div class="control-label">
                  <span>CAPACITY (m² per liter)</span>
                  <span class="value-display" id="capacityValue">0.5</span>
                </div>
                <input
                  type="range"
                  min="0.1"
                  max="40"
                  step="0.1"
                  value="0.5"
                  class="slider"
                  id="capacitySlider"
                />
              </div>

              <div class="control">
                <div class="control-label">
                  <span>TRAY VOLUME (ml)</span>
                  <span class="value-display" id="trayVolumeValue">1000</span>
                </div>
                <input
                  type="range"
                  min="100"
                  max="5000"
                  step="100"
                  value="1000"
                  class="slider"
                  id="trayVolumeSlider"
                />
              </div>

              <!-- NEW: Paper Size Selector -->
              <div class="paper-size-selector">
                <div class="dilution-selector">
                  <button class="toggle-btn" data-size="0.011">
                    3.5x5" (0.011 m²)
                  </button>
                  <button class="toggle-btn active" data-size="0.013">
                    4x5" (0.013 m²)
                  </button>
                  <button class="toggle-btn" data-size="0.023">
                    5x7" (0.023 m²)
                  </button>
                  <button class="toggle-btn" data-size="0.052">
                    8x10" (0.052 m²)
                  </button>
                  <!-- CHANGED -->
                  <button class="toggle-btn" data-size="0.099">
                    11x14" (0.099 m²)
                  </button>
                  <!-- CHANGED -->
                  <button class="toggle-btn" data-size="0.206">
                    16x20" (0.206 m²)
                  </button>
                  <!-- CHANGED -->
                </div>
                <div class="custom-dilution">
                  <!-- Chemical tab capacity tracker custom paper size -->
                  <input
                    type="number"
                    min="0.001"
                    max="1"
                    step="0.001"
                    value="0.052"
                    class="settings-input"
                    id="customPaperSize"
                    placeholder="Custom m²"
                  />
                  <button class="toggle-btn" id="useCustomSize">Use</button>
                </div>
              </div>

              <div class="info-box" style="margin: 10px 0">
                <div class="label-sm">MAX PRINTS THIS BATCH</div>
                <div
                  class="value-display"
                  id="maxPrintsValue"
                  style="font-size: 1.2rem"
                >
                  6
                </div>
                <div class="label-sm" id="printsRemaining">
                  6 prints remaining (0.48 m²)
                </div>
              </div>

              <div class="progress-container">
                <div
                  class="progress-bar"
                  id="capacityProgressBar"
                  style="width: 0%"
                ></div>
              </div>
              <div class="progress-labels">
                <span>0</span>
                <span id="capacityMiddleLabel">3</span>
                <span id="capacityMaxLabel">6</span>
              </div>

              <div class="capacity-controls">
                <button class="settings-btn" id="addPrint">+1 Print</button>
                <button class="settings-btn" id="add5Prints">+5 Prints</button>
                <button class="settings-btn" id="resetPrints">Reset</button>
              </div>

              <div class="exp-info" style="margin-top: 12px">
                <div class="info-box">
                  <div class="label-sm">Prints Done</div>
                  <div class="value-display" id="printsDoneValue">0</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">Area Used</div>
                  <div class="value-display" id="areaUsedValue">0.00 m²</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">% Used</div>
                  <div class="value-display" id="percentUsedValue">0%</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">Status</div>
                  <div class="value-display" id="capacityStatus">Fresh</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- UPDATED: Shelf Life Tracker with Custom Chemical Name -->
        <section class="collapsible" data-id="shelf-life">
          <button class="collapsible-header" aria-expanded="false">
            SHELF LIFE TRACKER
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                SHELF LIFE TRACKER
              </div>

              <div class="settings-group" style="margin-top: 10px">
                <div class="settings-item">
                  <div class="settings-label">Chemical</div>
                  <select class="settings-input" id="chemicalType">
                    <option value="developer">Developer</option>
                    <option value="stopbath">Stop Bath</option>
                    <option value="fixer">Fixer</option>
                    <option value="hypoclear">Hypo Clear</option>
                    <option value="photof">Photo Wash</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
                <div
                  class="settings-item"
                  id="customChemicalNameContainer"
                  style="display: none"
                >
                  <div class="settings-label">Custom Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="customChemicalName"
                    placeholder="Enter chemical name"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Shelf Life (days)</div>
                  <input
                    type="number"
                    min="1"
                    max="365"
                    value="30"
                    class="settings-input"
                    id="shelfLifeDays"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Date Mixed/Opened</div>
                  <input
                    type="date"
                    class="settings-input"
                    id="chemicalDate"
                    value=""
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button
                    class="settings-btn"
                    id="addChemical"
                    style="margin-top: 0"
                  >
                    Add Chemical
                  </button>
                </div>
              </div>

              <div
                class="title-sm"
                style="text-align: center; font-size: 0.75rem; margin-top: 15px"
              >
                ACTIVE CHEMICALS
              </div>
              <div class="shelf-life-list" id="shelfLifeList">
                <!-- Chemicals will be listed here -->
              </div>

              <div style="margin-top: 10px; text-align: center">
                <button class="settings-btn" id="clearExpired">
                  Clear Expired
                </button>
                <div
                  style="
                    font-size: 0.6rem;
                    color: var(--text-secondary);
                    margin-top: 5px;
                  "
                >
                  Red items expired, orange expire in 3 days
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Timer Tab with Photo Wash Toggle AND Timer Profiles -->
      <div id="timer" class="tab-content">
        <div class="timer-grid">
          <!-- Developer Timer -->
          <div class="timer-box" id="timerDev">
            <div class="title-sm">Developer</div>
            <div class="time-display" id="displayDev">01:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Dev" data-action="minus">
                  -5s
                </button>
                <button class="timer-btn" data-timer="Dev" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnDev">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Dev"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Stop Bath Timer -->
          <div class="timer-box" id="timerStop">
            <div class="title-sm">Stop Bath</div>
            <div class="time-display" id="displayStop">00:30</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Stop" data-action="minus">
                  -5s
                </button>
                <button class="timer-btn" data-timer="Stop" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnStop">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Stop"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Fixer Timer -->
          <div class="timer-box" id="timerFix">
            <div class="title-sm">Fixer</div>
            <div class="time-display" id="displayFix">05:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Fix" data-action="minus">
                  -5s
                </button>
                <button class="timer-btn" data-timer="Fix" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnFix">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Fix"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Photo Wash Timer -->
          <div class="timer-box" id="timerFlo">
            <div class="title-sm">Photo Wash</div>
            <div class="time-display" id="displayFlo">01:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Flo" data-action="minus">
                  -5s
                </button>
                <button class="timer-btn" data-timer="Flo" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnFlo">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Flo"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="settings-btn-group">
          <button class="exp-btn" id="startAll">Start All</button>
          <button class="exp-btn" id="resetAll">Reset All</button>
        </div>

        <div
          class="incremental-timer"
          style="
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 6px 8px;
          "
        >
          <div class="setting-item">
            <div class="setting-label">
              <span>Photo Wash</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="photoFloToggle" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span>End Beep</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="endBeep" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span>10s Beep</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="warningBeep" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
        </div>

        <!-- Timer Profiles Section MOVED from SETTINGS tab -->
        <section class="collapsible" data-id="timer-profiles">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">TIMER PROFILES</div>
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer" style="margin-top: 15px">
              <div class="title-md">Timer Profiles</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Profile Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="timerProfileName"
                    placeholder="Enter profile name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn" id="saveTimerProfile">
                    Save Current as Profile
                  </button>
                </div>
              </div>

              <div class="title-md">Saved Timer Profiles</div>
              <div class="shelf-life-list" id="timerProfileList">
                <!-- Timer profiles will be listed here -->
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn danger" id="clearTimerProfiles">
                  Clear All
                </button>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Add this new tab content section after the SETTINGS tab content -->
      <div id="relay" class="tab-content">
        <div class="incremental-timer">
          <div class="settings-section">
            <div class="title-md">Relay Control (Manual)</div>
            <div
              class="incremental-timer"
              style="background: var(--panel-light); margin-bottom: 0"
            >
              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 1 (GPIO 25)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay1Name"
                      value="Enlarger Timer"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="1"
                      data-gpio="25"
                      id="toggleRelay1"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 2 (GPIO 17)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay2Name"
                      value="Safelight"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="2"
                      data-gpio="17"
                      id="toggleRelay2"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 3 (GPIO 27)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay3Name"
                      value="Ventilation"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="3"
                      data-gpio="27"
                      id="toggleRelay3"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 4 (GPIO 22)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay4Name"
                      value="White Light"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="4"
                      data-gpio="22"
                      id="toggleRelay4"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <button class="settings-btn" id="allRelaysOn">All ON</button>
                </div>
                <div class="settings-item">
                  <button class="settings-btn" id="allRelaysOff">
                    All OFF
                  </button>
                </div>
              </div>
            </div>
          </div>

          <div class="settings-section">
            <div class="title-md">Controller Manager</div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Server IP</div>
                <input
                  type="text"
                  class="settings-input"
                  id="relayServerIP"
                  placeholder="192.168.1.xxx"
                  value="192.168.1.100"
                />
              </div>
              <div class="settings-item">
                <div class="settings-label">Server Port</div>
                <input
                  type="number"
                  class="settings-input"
                  id="relayServerPort"
                  value="5000"
                />
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Test Connection</div>
                <button class="settings-btn" id="testRelayConnection">
                  Test
                </button>
              </div>
              <div class="settings-item">
                <div class="settings-label">Status</div>
                <div
                  id="relayStatus"
                  style="color: var(--text-secondary); font-size: 0.8rem"
                >
                  Not connected
                </div>
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <button class="settings-btn warning" id="rebootPi">
                  Reboot Raspberry Pi
                </button>
              </div>
              <div class="settings-item">
                <button class="settings-btn danger" id="shutdownPi">
                  Shutdown Raspberry Pi
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- UPDATED: Settings Tab WITH Countdown Settings AND Auto Advance -->
      <div id="settings" class="tab-content">
        <div class="incremental-timer">
          <!-- Fullscreen Section -->
          <div class="settings-section">
            <div class="title-md">Display</div>
            <button
              class="settings-btn primary"
              id="toggleFullscreen"
              style="
                padding: 8px 16px;
                text-transform: uppercase;
                margin-top: 10px;
              "
            >
              Toggle Fullscreen
            </button>
            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                text-align: center;
                margin-top: 5px;
              "
            >
              Press F11 for desktop fullscreen
            </div>
            <div class="title-md">Color Scheme</div>
            <div class="dilution-selector">
              <button class="toggle-btn active" data-scheme="dark">
                Darkroom (Default)
              </button>
              <button class="toggle-btn" data-scheme="light">Day</button>
              <button class="toggle-btn" data-scheme="day">Night</button>
            </div>
          </div>

          <!-- GLOBAL SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="global-settings">
            <button class="collapsible-header" aria-expanded="false">
              GLOBAL SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Base Time (s)</div>
                  <input
                    type="number"
                    min="1"
                    max="50"
                    step="0.5"
                    class="settings-input"
                    id="settingBaseTime"
                    value="10"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Stop Increment</div>
                  <select id="settingStopIncrement" class="settings-input">
                    <option value="1">1 stop</option>
                    <option value="2">1/2 stop</option>
                    <option value="3">1/3 stop</option>
                    <option value="4">1/4 stop</option>
                    <option value="6">1/6 stop</option>
                  </select>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Countdown Delay (s)</div>
                  <input
                    type="number"
                    min="0"
                    max="30"
                    step="1"
                    class="settings-input"
                    id="settingCountdownDelay"
                    value="5"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Countdown Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingCountdownBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Beep Pattern</div>
                  <select class="settings-input" id="settingCountdownPattern">
                    <option value="every-second">Beep every second</option>
                    <option value="last3">Beep last 3 seconds only</option>
                    <option value="last5">Beep last 5 seconds only</option>
                    <option value="none">No beeps</option>
                  </select>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Test Pattern</div>
                  <button
                    class="settings-btn"
                    id="testCountdownBeep"
                    style="font-size: 0.7rem; padding: 4px 8px"
                  >
                    Test Beep
                  </button>
                </div>
              </div>
            </div>
          </section>

          <!-- CALC SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="calc-settings">
            <button class="collapsible-header" aria-expanded="false">
              CALC SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Base Time Min (s)</div>
                  <input
                    type="number"
                    id="baseTimeMin"
                    class="settings-input"
                    min="0.1"
                    max="10"
                    step="0.1"
                    value="0.4"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Base Time Max (s)</div>
                  <input
                    type="number"
                    id="baseTimeMax"
                    class="settings-input"
                    min="10"
                    max="300"
                    step="1"
                    value="50"
                  />
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Calc 3s Beep</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingCalcWarningBeep"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Calc End Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingCalcEndBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>
            </div>
          </section>

          <!-- TEST STRIP SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="test-strip-settings">
            <button class="collapsible-header" aria-expanded="false">
              TEST STRIP SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Auto Advance</div>
                  <label class="switch">
                    <input type="checkbox" id="settingAutoAdvance" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Auto Advance Delay (s)</div>
                  <input
                    type="number"
                    min="0"
                    max="30"
                    step="1"
                    class="settings-input"
                    id="settingAutoAdvanceDelay"
                    value="1"
                  />
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Test Base Time Min (s)</div>
                  <input
                    type="number"
                    id="testBaseTimeMin"
                    class="settings-input"
                    min="0.5"
                    max="10"
                    step="0.5"
                    value="1"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Test Base Time Max (s)</div>
                  <input
                    type="number"
                    id="testBaseTimeMax"
                    class="settings-input"
                    min="10"
                    max="300"
                    step="1"
                    value="50"
                  />
                </div>
              </div>
            </div>
          </section>

          <!-- TIMER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="timer-settings">
            <button class="collapsible-header" aria-expanded="false">
              TIMER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Developer (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="600"
                    step="5"
                    class="settings-input time-input"
                    id="settingDevTime"
                    value="60"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Stop Bath (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="300"
                    step="5"
                    class="settings-input time-input"
                    id="settingStopTime"
                    value="30"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Fixer (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="600"
                    step="5"
                    class="settings-input time-input"
                    id="settingFixTime"
                    value="300"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Photo Wash (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="300"
                    step="5"
                    class="settings-input time-input"
                    id="settingFloTime"
                    value="60"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Timer 10s Beep</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingTimerWarningBeep"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Timer End Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingTimerEndBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Photo Wash</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingDefaultPhotoFlo"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>
            </div>
          </section>

          <!-- CONTROLLER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="controller-settings">
            <button class="collapsible-header" aria-expanded="false">
              CONTROLLER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div
                    id="safelightAutoOffStatus"
                    style="color: var(--text-secondary); font-size: 0.8rem"
                  >
                    Loading...
                  </div>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Safelight Auto-Off</div>
                  <label class="switch">
                    <input type="checkbox" id="safelightAutoOff" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <div
                    style="
                      font-size: 0.7rem;
                      color: var(--text-secondary);
                      text-align: center;
                    "
                  >
                    Turn off safelight when enlarger is on
                  </div>
                </div>
              </div>

              <div class="title-md" style="margin-top: 12px">
                Auto - Manual Enlarger Control
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Auto-trigger Enlarger</div>
                  <label class="switch">
                    <input type="checkbox" id="autoTriggerRelay" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Test Timer Relay</div>
                  <div style="display: flex; gap: 5px">
                    <input
                      type="number"
                      class="settings-input"
                      id="testTimerSeconds"
                      value="5"
                      min="0.1"
                      max="60"
                      step="0.1"
                      style="flex: 1"
                    />
                    <button class="settings-btn" id="testTimerRelay">
                      Test
                    </button>
                  </div>
                </div>
              </div>

              <div
                style="
                  font-size: 0.7rem;
                  color: var(--text-secondary);
                  margin-top: 10px;
                "
              >
                Note: When enabled, the timer relay (GPIO 25) will automatically
                trigger during countdown timers in CALC and F-STOP TEST tabs.
                Time is sent as a single request with delay parameter for
                maximum accuracy.
              </div>
            </div>
          </section>

          <div class="settings-section">
            <button class="settings-btn primary" id="saveGlobalSettings">
              Save All Settings
            </button>
            <div id="allProfilesFeedback" class="json-feedback"></div>
          </div>

          <!-- UPDATED: Profile & Chemical Presets Sharing Section -->
          <div class="settings-section">
            <div class="title-md">Profile & Chemical Presets Sharing</div>
            <div class="settings-btn-group">
              <button class="settings-btn" id="exportAllProfiles">
                Export All Data
              </button>
              <button class="settings-btn" id="importAllProfiles">
                Import All Data
              </button>
            </div>
            <input
              type="file"
              id="allProfilesFileInput"
              accept=".json"
              style="display: none"
            />

            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                margin-top: 8px;
              "
            >
              Exports Timer Profiles, Chemical Presets, Capacity Tracker, and
              Shelf Life Data in one file
            </div>
          </div>

          <!-- Reset Section -->
          <div class="settings-section">
            <div class="title-md">Reset</div>
            <button class="settings-btn danger" id="resetAllSettings">
              Reset All Settings
            </button>
            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                text-align: center;
                margin-top: 5px;
              "
            >
              This will reset all settings to defaults and clear all data
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div>DARKROOM TIMER v2.9.1</div>
        <div>
          Height & Aperture & Paper Size & Contrast Calculator: New Time =
          Original Time × (New Height ÷ Original Height)² × (New F-Stop ÷
          Original F-Stop)² × (√New Paper Area ÷ √Original Paper Area)² × Filter
          Factor
        </div>
        <div>
          Chemical Mix Calculator: Stock = Total Volume ÷ (Stock Parts + Water
          Parts)
        </div>
        <div>
          Capacity Calculator: Max Prints = (Capacity × Tray Volume / 1000) ÷
          Paper Area
        </div>
        <div>
          Countdown Feature: Configurable 0-30 second delay with audible beeps
          before all timers start
        </div>
        <div>
          Test Strip Auto Advance: Toggle automatic progression between test
          strip steps
        </div>
        <div>
          Data Export: Includes Timer Profiles, Chemical Presets, Capacity
          Tracker, and Shelf Life Data
        </div>
      </footer>
    </div>

    <script>
      // Storage keys - UPDATED
      const STORAGE_KEYS = {
        SETTINGS: "darkroom_timer_settings",
        PROFILES: "darkroom_timer_profiles",
        CURRENT_PROFILE: "darkroom_timer_current_profile",
        COLOR_SCHEME: "darkroom_timer_color_scheme",
        CHEMICAL_PRESETS: "darkroom_timer_chemical_presets",
        CAPACITY_TRACKER: "darkroom_timer_capacity_tracker",
        SHELF_LIFE: "darkroom_timer_shelf_life",
        CUSTOM_FILTER_BANKS: "darkroom_timer_custom_filter_banks",
        TEST_STRIP_PROFILES: "darkroom_timer_test_strip_profiles",
        CURRENT_TEST_STRIP_PROFILE: "darkroom_timer_current_test_strip_profile",
      };

      // Application configuration - constants to eliminate magic numbers
      const CONFIG = {
        AUDIO: {
          BEEP_FREQUENCY_HZ: 600,
          BEEP_DURATION_SEC: 0.3,
          BEEP_VOLUME: 0.3,
          FEEDBACK_TIMEOUT_MS: 3000,
        },
      };

      // Default settings - UPDATED with countdown settings AND auto advance
      const DEFAULT_SETTINGS = {
        baseTime: 10.0,
        devTime: 60,
        stopTime: 30,
        fixTime: 60,
        floTime: 30,
        calcWarningBeep: true,
        calcEndBeep: true,
        timerWarningBeep: true,
        timerEndBeep: true,
        defaultPhotoFlo: true,
        currentProfile: null,
        colorScheme: "dark",
        // Countdown settings
        countdownDelay: 5, // Countdown delay in seconds
        countdownBeep: true, // Countdown beep enabled
        countdownPattern: "every-second", // Countdown beep pattern: 'every-second'|'last3'|'last5'|'none'
        // Test strip auto-advance
        autoAdvance: false,
        autoAdvanceDelay: 1,
        safelightAutoOff: true, // Turn off safelight when enlarger is on
        stopDenominator: 3, // Denominator for f-stop fractions (2, 3, or 4)
        // Base time slider limits
        baseTimeMin: 0.4,
        baseTimeMax: 50,
        // Test base time slider limits
        testBaseTimeMin: 1,
        testBaseTimeMax: 50,
      };

      // Default timer times (seconds)
      const DEFAULT_TIMER_TIMES = {
        Dev: 60,
        Stop: 30,
        Fix: 60,
        Flo: 30,
      };

      function getDefaultCustomFilterBanks() {
        const defaultLabels = [
          "Grade 00",
          "Grade 0",
          "Grade 0.5",
          "Grade 1",
          "Grade 1.5",
          "Grade 2",
          "Grade 2.5",
          "Grade 3",
          "Grade 3.5",
          "Grade 4",
          "Grade 4.5",
          "Grade 5",
        ];

        const makeGroup = (name) => ({
          name,
          slots: defaultLabels.map((label) => ({ label, value: 1.0 })),
        });

        return [
          makeGroup("Group A"),
          makeGroup("Group B"),
          makeGroup("Group C"),
        ];
      }

      // Global variables for timer management
      let settingsManager;
      let timerManager;
      let audioService = null; // Centralized audio service

      // ===== AUDIO SERVICE CLASS =====
      /**
       * AudioService - Manages Web Audio API for sound feedback
       *
       * Provides a centralized audio system for all timer and UI sound effects.
       * Handles audio context initialization, resume on user interaction, and
       * provides preset sound patterns for different events.
       *
       * @class
       * @example
       * const audio = new AudioService();
       * await audio.playPreset('timerComplete');
       */
      class AudioService {
        /**
         * Creates an AudioService instance
         * @constructor
         * @property {AudioContext|null} audioContext - The Web Audio API context
         * @property {boolean} initialized - Whether audio context is initialized
         * @property {Object} presets - Collection of sound presets with frequency, duration, volume
         */
        constructor() {
          this.audioContext = null;
          this.initialized = false;
          this.presets = {
            // Timer presets
            warning: { frequency: 600, duration: 0.3, volume: 0.3 },
            timerWarning: { frequency: 400, duration: 0.3, volume: 0.3 },
            timerComplete: { frequency: 800, duration: 0.1, volume: 0.5 },

            // Calculator presets
            calcWarning: { frequency: 600, duration: 0.3, volume: 0.3 },
            calcComplete: { frequency: 1600, duration: 0.1, volume: 0.5 },

            // Countdown presets
            countdown: { frequency: 400, duration: 0.2, volume: 0.2 },
            countdownMid: { frequency: 600, duration: 0.3, volume: 0.3 },
            countdownUrgent: { frequency: 800, duration: 0.2, volume: 0.4 },
            countdownComplete: { frequency: 1600, duration: 0.5, volume: 0.5 },

            // UI feedback presets
            success: { frequency: 800, duration: 0.3, volume: 0.3 },
            action: { frequency: 600, duration: 0.3, volume: 0.3 },
            pause: { frequency: 600, duration: 0.3, volume: 0.2 },
            error: { frequency: 400, duration: 0.3, volume: 0.3 },
            lowTone: { frequency: 400, duration: 0.3, volume: 0.3 },

            // Relay presets
            relayOn: { frequency: 800, duration: 0.1, volume: 0.3 },
            relayOff: { frequency: 400, duration: 0.5, volume: 0.3 },
            relayTrigger: { frequency: 600, duration: 0.3, volume: 0.3 },
            relayBurst: { frequency: 600, duration: 0.1, volume: 0.3 },

            // Chemical presets
            chemicalAction: { frequency: 600, duration: 0.3, volume: 0.2 },
            chemicalSave: { frequency: 600, duration: 0.5, volume: 0.3 },
            chemicalDelete: { frequency: 800, duration: 0.5, volume: 0.3 },

            // Other presets
            complete: { frequency: 1600, duration: 0.1, volume: 0.5 },
          };
        }

        /**
         * Initialize the Web Audio API context
         * @returns {boolean} Success status
         * @description Must be called before any audio playback. Requires user interaction.
         */
        init() {
          if (this.initialized) return true;

          try {
            this.audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            this.initialized = true;
            console.log("AudioService initialized");
            return true;
          } catch (e) {
            console.warn("Web Audio API not supported:", e);
            return false;
          }
        }

        /**
         * Ensure audio context is running (resume if suspended)
         * @async
         * @returns {Promise<void>}
         * @description Automatically initializes if needed and resumes suspended context
         */
        async ensureRunning() {
          if (!this.audioContext) {
            this.init();
          }

          if (this.audioContext && this.audioContext.state === "suspended") {
            try {
              await this.audioContext.resume();
            } catch (e) {
              console.warn("Failed to resume audio context:", e);
            }
          }
        }

        /**
         * Play a beep with specified parameters
         * @async
         * @param {number} [frequency=800] - Frequency in Hz (20-20000)
         * @param {number} [duration=0.1] - Duration in seconds
         * @param {number} [volume=0.3] - Volume level (0.0-1.0)
         * @returns {Promise<void>}
         * @description Creates a sine wave oscillator with exponential fade-out
         */
        async playBeep(frequency = 800, duration = 0.1, volume = 0.3) {
          await this.ensureRunning();

          if (!this.audioContext) return;

          try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = "sine";

            gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              this.audioContext.currentTime + duration
            );

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration);
          } catch (e) {
            console.warn("Could not play beep:", e);
          }
        }

        /**
         * Play a preset beep by name
         * @async
         * @param {string} presetName - Name of the preset (e.g., 'timerComplete', 'warning')
         * @returns {Promise<void>}
         * @description Looks up preset configuration and plays with stored parameters
         */
        async playPreset(presetName) {
          const preset = this.presets[presetName];
          if (!preset) {
            console.warn(`Unknown preset: ${presetName}`);
            return;
          }
          await this.playBeep(preset.frequency, preset.duration, preset.volume);
        }

        /**
         * Play countdown beep pattern based on remaining seconds
         * @async
         * @param {number} secondsRemaining - Seconds left in countdown
         * @returns {Promise<void>}
         * @description Plays different beep patterns based on urgency:
         * - 0-3 seconds: urgent high-pitch beep
         * - 4-5 seconds: mid-pitch beep
         * - 6+ seconds: standard beep
         */
        async playCountdownBeep(secondsRemaining) {
          if (secondsRemaining <= 3) {
            await this.playPreset("countdownUrgent");
          } else if (secondsRemaining <= 5) {
            await this.playPreset("countdownMid");
          } else {
            await this.playPreset("countdown");
          }
        }
      }

      // ===== DRIFT-CORRECTED TIMER UTILITY =====
      /**
       * DriftCorrectedTimer - High-precision timer with drift compensation
       *
       * Provides millisecond-accurate timing by compensating for JavaScript's
       * timer drift. Uses Date.now() instead of setInterval for photographic
       * timing precision. Essential for accurate exposure timing.
       *
       * @class
       * @example
       * const timer = new DriftCorrectedTimer(() => {
       *   console.log('Tick');
       * }, 1000);
       * timer.start();
       */
      class DriftCorrectedTimer {
        /**
         * Creates a DriftCorrectedTimer instance
         * @constructor
         * @param {Function} callback - Function to execute on each tick
         * @param {number} interval - Interval in milliseconds between ticks
         * @property {Function} callback - The callback function to execute
         * @property {number} interval - The target interval in milliseconds
         * @property {number|null} expected - The expected timestamp of next tick
         * @property {number|null} timeout - The setTimeout identifier
         * @property {boolean} running - Whether the timer is currently running
         */
        constructor(callback, interval) {
          this.callback = callback;
          this.interval = interval;
          this.expected = null;
          this.timeout = null;
          this.running = false;
        }

        /**
         * Start the timer
         * @returns {void}
         * @description Begins the timer loop with drift correction
         */
        start() {
          if (this.running) return;

          this.running = true;
          this.expected = Date.now() + this.interval;
          this.timeout = setTimeout(() => this.step(), this.interval);
        }

        /**
         * Execute one timer tick with drift compensation
         * @private
         * @returns {void}
         * @description Calculates drift and schedules next tick with adjusted delay
         */
        step() {
          if (!this.running) return;

          const drift = Date.now() - this.expected;

          // Call the callback
          this.callback();

          // Calculate next tick with drift correction
          this.expected += this.interval;
          const nextDelay = Math.max(0, this.interval - drift);

          this.timeout = setTimeout(() => this.step(), nextDelay);
        }

        /**
         * Stop the timer
         * @returns {void}
         * @description Halts the timer and clears any pending timeouts
         */
        stop() {
          this.running = false;
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
        }

        /**
         * Check if timer is running
         * @returns {boolean} True if timer is currently running
         */
        isRunning() {
          return this.running;
        }
      }
      // Application State - Single Source of Truth Pattern
      // =====================================================
      // STATE MANAGEMENT ARCHITECTURE:
      //
      // 1. TRANSIENT UI STATE (appState.ui)
      //    - activeTab, timerStatus
      //    - Never persisted to localStorage
      //    - Reset on page reload
      //    - Updated during user interactions
      //
      // 2. RUNTIME STATE (appState.calculator, appState.timers)
      //    - Timer values, calculator state, countdown flags
      //    - Transient (not persisted)
      //    - Cleared/reset on page reload
      //    - Source of truth for current timer/calc display
      //
      // 3. PERSISTENT UI SELECTIONS (appState.persistent)
      //    - currentProfile, currentChemicalPreset
      //    - Persisted via StorageManager.save*()
      //    - Loaded on page start via SettingsManager/ChemicalManager constructors
      //    - SINGLE SOURCE OF TRUTH - accessed via helper methods:
      //      SettingsManager: getCurrentProfile(), setCurrentProfile()
      //      ChemicalManager: getCurrentPreset(), setCurrentPreset()
      //
      // 4. SETTINGS (appState.settings)
      //    - User preferences and configuration
      //    - Persisted via StorageManager.saveSettings()
      //    - Synced from StorageManager on init
      //    - Single copy kept in this.settings on SettingsManager
      //
      // REDUNDANCY PREVENTION:
      // - NO instance properties for currentProfile/currentPreset
      // - Use appState.persistent for truth instead
      // - Helper methods ensure consistency with StorageManager
      // - All reads go through appState, all writes sync to StorageManager
      //
      const appState = {
        // Calculator state (runtime/transient)
        calculator: {
          baseTime: 10.0,
          currentStop: 0,
          currentTotalTime: 10.0,
          thisExposureTime: 10.0,
          accumulatedTime: 0,
          isRunning: false,
          isPaused: false,
          isCountdown: false,
          currentTime: 10.0,
          lastExposureTime: 10.0,
        },

        // Timer states (runtime/transient)
        timers: {
          Dev: {
            timeLeft: 60,
            totalTime: 60,
            isRunning: false,
            isEnabled: true,
          },
          Stop: {
            timeLeft: 30,
            totalTime: 30,
            isRunning: false,
            isEnabled: true,
          },
          Fix: {
            timeLeft: 60,
            totalTime: 60,
            isRunning: false,
            isEnabled: true,
          },
          Flo: {
            timeLeft: 30,
            totalTime: 30,
            isRunning: false,
            isEnabled: true,
          },
        },

        // Settings state (persisted + synced from StorageManager)
        settings: {
          colorScheme: "dark",
          calcWarningBeep: true,
          calcEndBeep: true,
          timerWarningBeep: true,
          timerEndBeep: true,
          defaultPhotoFlo: true,
          countdownDelay: 5,
          countdownBeep: true,
          countdownPattern: "every-second",
          autoAdvance: false,
          autoAdvanceDelay: 1,
          safelightAutoOff: true,
          stopDenominator: 3,
        },

        // Persistent UI selections (loaded from StorageManager)
        persistent: {
          currentProfile: null, // Currently loaded timer profile
          currentChemicalPreset: null, // Currently loaded chemical preset
          currentTestStripProfile: null, // Currently loaded test strip profile
        },

        // Transient UI state (not persisted)
        ui: {
          activeTab: "calculator",
          timerStatus: "READY FOR EXPOSURE",
        },
      };

      // ===== RENDER FUNCTIONS =====

      // Calculator render functions
      /**
       * @function renderCalculatorDisplay
       * @description Renders the calculator display with current state values.
       * Updates base time, stop value, result time, result details, and timer display.
       * @returns {void}
       * @fires appState.calculator - Reads calculator state
       * @fires Element.textContent - Updates display elements
       * @fires formatStop - Formats stop value for display
       * @example
       * renderCalculatorDisplay(); // Update calculator UI
       */
      function renderCalculatorDisplay() {
        const state = appState.calculator;
        document.getElementById(
          "baseTimeValue"
        ).textContent = `${state.baseTime.toFixed(1)}s`;
        document.getElementById("stopValue").textContent = formatStop(
          appState.calculator.currentStop
        );
        document.getElementById("resultTime").textContent =
          state.currentTotalTime.toFixed(2);
        document.getElementById("resultDetails").textContent = `${formatStop(
          state.currentStop
        )} STOPS`;
        document.getElementById("calcTimerDisplay").textContent =
          state.currentTime.toFixed(2);
      }

      /**
       * @function renderCalculatorExposureDetails
       * @description Renders detailed exposure information for the calculator.
       * Updates selected stop display and other exposure-related details.
       * @returns {void}
       * @fires appState.calculator - Reads calculator state
       * @fires Element.textContent - Updates display elements
       * @fires formatStop - Formats stop value for display
       * @example
       * renderCalculatorExposureDetails(); // Update exposure details UI
       */
      function renderCalculatorExposureDetails() {
        const state = appState.calculator;
        document.getElementById("selectedStopDisplay").textContent = formatStop(
          state.currentStop
        );
        document.getElementById("previousTotalDisplay").textContent =
          state.accumulatedTime.toFixed(2);
        document.getElementById("currentTotalDisplay").textContent =
          state.currentTotalTime.toFixed(2);
        document.getElementById("thisExposureDisplay").textContent =
          state.thisExposureTime.toFixed(2);
      }

      /**
       * @function renderCalculatorTimerStatus
       * @description Renders the calculator timer status, button states, and display styling.
       * Updates status text, button text/disabled states, and warning styling based on calculator state
       * (countdown, running, paused, or ready).
       * @returns {void}
       * @fires appState.calculator - Reads calculator state
       * @fires appState.ui.timerStatus - Reads UI status text
       * @fires Element.textContent - Updates button and status text
       * @fires Element.disabled - Updates button disabled states
       * @fires Element.classList - Adds/removes warning class
       * @example
       * renderCalculatorTimerStatus(); // Update timer status UI
       */
      function renderCalculatorTimerStatus() {
        const state = appState.calculator;
        const statusElement = document.getElementById("timerStatus");
        const startBtn = document.getElementById("startExposure");
        const stopBtn = document.getElementById("stopCalcTimer");
        const resetBtn = document.getElementById("resetCalcTimer");
        const repeatBtn = document.getElementById("repeatExposure");
        const displayElement = document.getElementById("calcTimerDisplay");

        statusElement.textContent = appState.ui.timerStatus;

        if (state.isCountdown) {
          startBtn.textContent = "Start Exposure";
          startBtn.disabled = true;
          stopBtn.disabled = false;
          resetBtn.disabled = true;
          repeatBtn.disabled = true;
        } else if (state.isRunning) {
          startBtn.textContent = "Pause";
          startBtn.disabled = false;
          stopBtn.disabled = false;
          resetBtn.disabled = true;
          repeatBtn.disabled = true;
        } else if (state.isPaused) {
          startBtn.textContent = "Resume";
          startBtn.disabled = false;
          stopBtn.disabled = false;
          resetBtn.disabled = false;
          repeatBtn.disabled = true;
        } else {
          startBtn.textContent =
            state.accumulatedTime > 0 ? "Start Next" : "Start Exposure";
          startBtn.disabled = false;
          stopBtn.disabled = true;
          resetBtn.disabled = false;
          repeatBtn.disabled = state.lastExposureTime <= 0;
        }

        if (state.currentTime <= 3 && state.isRunning) {
          displayElement.classList.add("warning");
        } else {
          displayElement.classList.remove("warning");
        }
      }

      /**
       * @function renderTimer
       * @description Renders a single timer's display and UI state.
       * Updates timer display, status text, button states, and styling based on timer state.
       * @param {string} timerName - Name of the timer to render (Dev, Stop, Fix, Flo)
       * @returns {void}
       * @throws {Error} If timer state not found
       * @fires appState.timers - Reads timer state
       * @fires Element.textContent - Updates display and status text
       * @fires Element.disabled - Updates button disabled states
       * @fires Element.classList - Adds/removes timer state classes
       * @fires Element.style - Updates styling
       * @example
       * renderTimer("Dev"); // Render Dev timer UI
       */
      function renderTimer(timerName) {
        const state = appState.timers[timerName];
        if (!state) return;

        const display = document.getElementById(`display${timerName}`);
        const button = document.getElementById(`btn${timerName}`);
        const box = document.getElementById(`timer${timerName}`);
        const resetButton = document.querySelector(
          `button[data-timer="${timerName}"][data-action="reset"]`
        );
        const plusButton = document.querySelector(
          `button[data-timer="${timerName}"][data-action="plus"]`
        );
        const minusButton = document.querySelector(
          `button[data-timer="${timerName}"][data-action="minus"]`
        );

        // Update display
        if (display) {
          const minutes = Math.floor(state.timeLeft / 60);
          const seconds = state.timeLeft % 60;
          display.textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }

        // Update button states
        if (!state.isEnabled) {
          if (button) button.disabled = true;
          if (resetButton) resetButton.disabled = true;
          if (plusButton) plusButton.disabled = true;
          if (minusButton) minusButton.disabled = true;
          if (box) box.classList.add("disabled");
          return;
        }

        if (button) {
          button.disabled = false;
          button.textContent = state.isRunning ? "Pause" : "Start";
          button.classList.toggle("active", state.isRunning);
        }

        if (resetButton) resetButton.disabled = state.isRunning;
        if (plusButton) plusButton.disabled = state.isRunning;
        if (minusButton) minusButton.disabled = state.isRunning;

        // Update box state
        if (box) {
          box.classList.remove("running", "warning", "complete", "disabled");
          if (state.isRunning) box.classList.add("running");
          if (state.timeLeft === 0) box.classList.add("complete");
          if (!state.isEnabled) box.classList.add("disabled");
        }
      }

      /**
       * @function renderAllTimers
       * @description Renders all timer displays by iterating through appState.timers.
       * Calls renderTimer() for each timer name to update their UI states.
       * @returns {void}
       * @fires appState.timers - Reads all timer states
       * @fires renderTimer - Renders each individual timer
       * @example
       * renderAllTimers(); // Update all timer displays
       */
      function renderAllTimers() {
        Object.keys(appState.timers).forEach((timerName) =>
          renderTimer(timerName)
        );
      }

      /**
       * @function renderSoundSettings
       * @description Renders sound settings checkboxes from appState.
       * Updates all sound-related checkbox states based on current settings.
       * @returns {void}
       * @fires appState.settings - Reads sound settings
       * @fires Element.checked - Updates checkbox states
       * @example
       * renderSoundSettings(); // Update sound settings UI
       */
      function renderSoundSettings() {
        const settings = appState.settings;
        document.getElementById("calcWarningBeep").checked =
          settings.calcWarningBeep;
        document.getElementById("calcEndBeep").checked = settings.calcEndBeep;
        document.getElementById("warningBeep").checked =
          settings.timerWarningBeep;
        document.getElementById("endBeep").checked = settings.timerEndBeep;
      }

      // Tab management
      const tabButtons = document.querySelectorAll(".tab-button");
      const tabContents = document.querySelectorAll(".tab-content");

      // Generic feedback display helper - consolidates showAllProfilesFeedback and showShelfLifeFeedback
      function showFeedback(elementId, message, type = "info") {
        const feedbackElement = document.getElementById(elementId);
        if (feedbackElement) {
          feedbackElement.textContent = message;
          feedbackElement.className = `feedback ${type}`;
          feedbackElement.style.display = "block";
          setTimeout(() => {
            feedbackElement.style.display = "none";
          }, CONFIG.AUDIO.FEEDBACK_TIMEOUT_MS);
        }
      }

      function refreshCollapsibleHeights(container = document) {
        const sections = container.querySelectorAll(".collapsible");
        sections.forEach((sec) => {
          const header = sec.querySelector(".collapsible-header");
          const content = sec.querySelector(".collapsible-content");
          if (!header || !content) return;

          const expanded = header.getAttribute("aria-expanded") === "true";
          content.style.maxHeight = expanded
            ? content.scrollHeight + "px"
            : "0px";
        });
      }

      /**
       * @function switchTab
       * @description Switches the active tab and updates related UI components.
       * Removes active class from all tabs, adds it to selected tab, and triggers
       * tab-specific updates (chart, test strip, chemical, timer, relay).
       * @param {string} tabId - ID of the tab to activate
       * @returns {void}
       * @fires Element.classList.remove - Removes active class from all tabs
       * @fires Element.classList.add - Adds active class to selected tab
       * @fires refreshCollapsibleHeights - Updates collapsible sections
       * @fires updateChart - Updates chart tab
       * @fires fstopTestGenerator.updateDisplay - Updates test strip display
       * @fires chemicalManager.updateDisplay - Updates chemical display
       * @fires settingsManager.updateTimerProfileListUI - Updates timer profiles
       * @fires relayManager.updateRelayButtons - Updates relay controls
       * @example
       * switchTab("calc"); // Switch to calculator tab
       */
      function switchTab(tabId) {
        tabButtons.forEach((btn) => btn.classList.remove("active"));
        tabContents.forEach((content) => content.classList.remove("active"));

        tabButtons.forEach((btn) => {
          if (btn.getAttribute("data-tab") === tabId) {
            btn.classList.add("active");
          }
        });

        const activeTab = document.getElementById(tabId);
        if (activeTab) {
          activeTab.classList.add("active");
          refreshCollapsibleHeights(activeTab);
        }

        if (tabId === "chart") {
          updateChart();
        } else if (tabId === "fstop-test") {
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.updateDisplay();
            window.fstopTestGenerator.updateInstructions();
          }
        } else if (tabId === "chemical") {
          if (window.chemicalManager) {
            window.chemicalManager.updateDisplay();
            // Specifically update shelf life list
            window.chemicalManager.updateShelfLifeList();
          }
        } else if (tabId === "timer") {
          if (settingsManager) {
            settingsManager.updateTimerProfileListUI();
          }
        } else if (tabId === "relay") {
          if (window.relayManager) {
            window.relayManager.updateRelayButtons();
          }
        }
      }

      // Event delegation for tabs - handles both existing and future tab buttons
      document.addEventListener("click", (e) => {
        const tabBtn = e.target.closest(".tab-button[data-tab]");
        if (tabBtn) {
          e.preventDefault();
          switchTab(tabBtn.getAttribute("data-tab"));
        }
      });

      // Add event listeners for base time limit inputs
      document.addEventListener("DOMContentLoaded", () => {
        const baseTimeMinInput = document.getElementById("baseTimeMin");
        const baseTimeMaxInput = document.getElementById("baseTimeMax");

        if (baseTimeMinInput && baseTimeMaxInput) {
          baseTimeMinInput.addEventListener("change", () => {
            const minVal = parseFloat(baseTimeMinInput.value);
            const maxVal = parseFloat(baseTimeMaxInput.value);
            if (minVal >= maxVal) {
              baseTimeMinInput.value = (maxVal - 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });

          baseTimeMaxInput.addEventListener("change", () => {
            const minVal = parseFloat(baseTimeMinInput.value);
            const maxVal = parseFloat(baseTimeMaxInput.value);
            if (maxVal <= minVal) {
              baseTimeMaxInput.value = (minVal + 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });
        }

        // Add event listeners for test base time limit inputs
        const testBaseTimeMinInput = document.getElementById("testBaseTimeMin");
        const testBaseTimeMaxInput = document.getElementById("testBaseTimeMax");

        if (testBaseTimeMinInput && testBaseTimeMaxInput) {
          testBaseTimeMinInput.addEventListener("change", () => {
            const minVal = parseFloat(testBaseTimeMinInput.value);
            const maxVal = parseFloat(testBaseTimeMaxInput.value);
            if (minVal >= maxVal) {
              testBaseTimeMinInput.value = (maxVal - 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });

          testBaseTimeMaxInput.addEventListener("change", () => {
            const minVal = parseFloat(testBaseTimeMinInput.value);
            const maxVal = parseFloat(testBaseTimeMaxInput.value);
            if (maxVal <= minVal) {
              testBaseTimeMaxInput.value = (minVal + 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });
        }
      });

      // Legacy audio wrapper for backward compatibility

      function initAudioContext() {
        // Deprecated - AudioService handles this now
        if (audioService) {
          audioService.init();
          return audioService.audioContext;
        }
        return null;
      }

      // Legacy playBeep wrapper - redirects to AudioService
      /**
       * @function playBeep
       * @description Plays a beep sound using the audio service.
       * Wrapper for AudioService.playBeep with default parameters from CONFIG.
       * @param {number} frequency - Frequency in Hz (default: CONFIG.AUDIO.BEEP_FREQUENCY_HZ)
       * @param {number} duration - Duration in seconds (default: CONFIG.AUDIO.BEEP_DURATION_SEC)
       * @param {number} volume - Volume 0-1 (default: CONFIG.AUDIO.BEEP_VOLUME)
       * @returns {void}
       * @fires audioService.playBeep - Plays the beep sound
       * @example
       * playBeep(800, 0.1, 0.5); // Play 800Hz beep for 0.1s at 50% volume
       */
      function playBeep(
        frequency = CONFIG.AUDIO.BEEP_FREQUENCY_HZ,
        duration = CONFIG.AUDIO.BEEP_DURATION_SEC,
        volume = CONFIG.AUDIO.BEEP_VOLUME
      ) {
        if (audioService) {
          audioService.playBeep(frequency, duration, volume);
        }
      }

      /**
       * @function playPreset
       * @description Plays a named audio preset using the audio service.
       * Wrapper for AudioService.playPreset for standardized sound patterns.
       * @param {string} presetName - Name of the preset to play
       * @returns {void}
       * @fires audioService.playPreset - Plays the preset sound
       * @example
       * playPreset("timerComplete"); // Play timer completion sound
       */
      function playPreset(presetName) {
        if (audioService) {
          audioService.playPreset(presetName);
        }
      }

      /**
       * @function playCountdownBeep
       * @description Plays countdown beep pattern based on seconds remaining.
       * Wrapper for AudioService.playCountdownBeep for countdown audio feedback.
       * @param {number} secondsRemaining - Seconds remaining in countdown
       * @returns {void}
       * @fires audioService.playCountdownBeep - Plays countdown pattern
       * @example
       * playCountdownBeep(3); // Play beep for 3 seconds remaining
       */
      function playCountdownBeep(secondsRemaining) {
        if (audioService) {
          audioService.playCountdownBeep(secondsRemaining);
        }
      }

      /**
       * StorageManager - Centralized localStorage handler with error handling
       *
       * Provides a unified interface for all localStorage operations with
       * consistent error handling and key management. All persistence flows
       * through this class to ensure data integrity.
       *
       * @class
       * @example
       * StorageManager.saveSettings({ baseTime: 10.0 });
       * const settings = StorageManager.loadSettings();
       */
      class StorageManager {
        /**
         * Save data as JSON string
         * @static
         * @param {string} key - Storage key
         * @param {*} value - Data to save (will be JSON stringified)
         * @returns {boolean} Success status
         * @description Handles serialization errors and logs failures
         */
        static saveJSON(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
          } catch (e) {
            console.error(`Failed to save ${key}:`, e);
            return false;
          }
        }

        /**
         * Load and parse JSON data
         * @static
         * @param {string} key - Storage key
         * @param {*} fallback - Value to return if load fails or key doesn't exist
         * @returns {*} Parsed data or fallback
         * @description Handles parsing errors and provides fallback values
         */
        static loadJSON(key, fallback) {
          try {
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : fallback;
          } catch (e) {
            console.error(`Failed to load ${key}:`, e);
            return fallback;
          }
        }

        /**
         * Remove multiple storage keys
         * @static
         * @param {string[]} keys - Array of keys to remove
         * @returns {boolean} Success status
         * @description Clears all specified keys from localStorage
         */
        static removeKeys(keys) {
          try {
            keys.forEach((k) => localStorage.removeItem(k));
            return true;
          } catch (e) {
            console.error("Failed to clear storage:", e);
            return false;
          }
        }

        /**
         * Save user settings
         * @static
         * @param {Object} settings - Settings object
         * @returns {boolean} Success status
         */
        static saveSettings(settings) {
          return this.saveJSON(STORAGE_KEYS.SETTINGS, settings);
        }

        /**
         * Load user settings
         * @static
         * @returns {Object} Settings object with defaults
         */
        static loadSettings() {
          return this.loadJSON(STORAGE_KEYS.SETTINGS, { ...DEFAULT_SETTINGS });
        }

        /**
         * Save timer profiles
         * @static
         * @param {Array} profiles - Array of profile objects
         * @returns {boolean} Success status
         */
        static saveProfiles(profiles) {
          return this.saveJSON(STORAGE_KEYS.PROFILES, profiles);
        }

        /**
         * Load timer profiles
         * @static
         * @returns {Array} Array of profile objects
         */
        static loadProfiles() {
          return this.loadJSON(STORAGE_KEYS.PROFILES, []);
        }

        /**
         * Save currently loaded profile name
         * @static
         * @param {string|null} profileName - Name of current profile or null
         * @returns {boolean} Success status
         */
        static saveCurrentProfile(profileName) {
          return this.saveJSON(STORAGE_KEYS.CURRENT_PROFILE, profileName);
        }

        /**
         * Load currently loaded profile name
         * @static
         * @returns {string|null} Profile name or null
         */
        static loadCurrentProfile() {
          return this.loadJSON(STORAGE_KEYS.CURRENT_PROFILE, null);
        }

        /**
         * Save color scheme preference
         * @static
         * @param {string} scheme - Color scheme name ('dark', 'light', 'day')
         * @returns {boolean} Success status
         */
        static saveColorScheme(scheme) {
          return this.saveJSON(STORAGE_KEYS.COLOR_SCHEME, scheme);
        }

        /**
         * Load color scheme preference
         * @static
         * @returns {string} Color scheme name
         */
        static loadColorScheme() {
          return this.loadJSON(STORAGE_KEYS.COLOR_SCHEME, "dark");
        }

        /**
         * Save chemical presets
         * @static
         * @param {Array} presets - Array of chemical preset objects
         * @returns {boolean} Success status
         */
        static saveChemicalPresets(presets) {
          return this.saveJSON(STORAGE_KEYS.CHEMICAL_PRESETS, presets);
        }

        /**
         * Load chemical presets
         * @static
         * @returns {Array} Array of chemical preset objects
         */
        static loadChemicalPresets() {
          return this.loadJSON(STORAGE_KEYS.CHEMICAL_PRESETS, []);
        }

        /**
         * Save developer capacity tracker data
         * @static
         * @param {Object} data - Capacity data object
         * @returns {boolean} Success status
         */
        static saveCapacityTracker(data) {
          return this.saveJSON(STORAGE_KEYS.CAPACITY_TRACKER, data);
        }

        /**
         * Load developer capacity tracker data
         * @static
         * @returns {Object} Capacity data with defaults
         */
        static loadCapacityTracker() {
          return this.loadJSON(STORAGE_KEYS.CAPACITY_TRACKER, {
            printsDone: 0,
            areaUsed: 0,
            paperSize: 0.052,
            lastReset: new Date().toISOString(),
          });
        }

        /**
         * Save shelf life tracking data
         * @static
         * @param {Array} chemicals - Array of chemical objects
         * @returns {boolean} Success status
         */
        static saveShelfLife(chemicals) {
          return this.saveJSON(STORAGE_KEYS.SHELF_LIFE, chemicals);
        }

        /**
         * Load shelf life tracking data
         * @static
         * @returns {Array} Array of chemical objects
         */
        static loadShelfLife() {
          return this.loadJSON(STORAGE_KEYS.SHELF_LIFE, []);
        }

        /**
         * Save custom filter banks
         * @static
         * @param {Array} banks - Array of filter bank objects
         * @returns {boolean} Success status
         */
        static saveCustomFilterBanks(banks) {
          return this.saveJSON(STORAGE_KEYS.CUSTOM_FILTER_BANKS, banks);
        }

        /**
         * Load custom filter banks
         * @static
         * @returns {Array} Array of filter bank objects with defaults
         */
        static loadCustomFilterBanks() {
          return this.loadJSON(
            STORAGE_KEYS.CUSTOM_FILTER_BANKS,
            getDefaultCustomFilterBanks()
          );
        }

        /**
         * Save test strip profiles
         * @static
         * @param {Array} profiles - Array of test strip profile objects
         * @returns {boolean} Success status
         */
        static saveTestStripProfiles(profiles) {
          return this.saveJSON(STORAGE_KEYS.TEST_STRIP_PROFILES, profiles);
        }

        /**
         * Load test strip profiles
         * @static
         * @returns {Array} Array of test strip profile objects
         */
        static loadTestStripProfiles() {
          return this.loadJSON(STORAGE_KEYS.TEST_STRIP_PROFILES, []);
        }

        /**
         * Save currently loaded test strip profile name
         * @static
         * @param {string|null} profileName - Profile name or null
         * @returns {boolean} Success status
         */
        static saveCurrentTestStripProfile(profileName) {
          return this.saveJSON(
            STORAGE_KEYS.CURRENT_TEST_STRIP_PROFILE,
            profileName
          );
        }

        /**
         * Load currently loaded test strip profile name
         * @static
         * @returns {string|null} Profile name or null
         */
        static loadCurrentTestStripProfile() {
          return this.loadJSON(STORAGE_KEYS.CURRENT_TEST_STRIP_PROFILE, null);
        }

        /**
         * Clear all stored data
         * @static
         * @returns {boolean} Success status
         * @description Removes ALL application data from localStorage
         */
        static clearAll() {
          return this.removeKeys([
            STORAGE_KEYS.SETTINGS,
            STORAGE_KEYS.PROFILES,
            STORAGE_KEYS.CURRENT_PROFILE,
            STORAGE_KEYS.COLOR_SCHEME,
            STORAGE_KEYS.CHEMICAL_PRESETS,
            STORAGE_KEYS.CAPACITY_TRACKER,
            STORAGE_KEYS.SHELF_LIFE,
            STORAGE_KEYS.CUSTOM_FILTER_BANKS,
            STORAGE_KEYS.TEST_STRIP_PROFILES,
            STORAGE_KEYS.CURRENT_TEST_STRIP_PROFILE,
          ]);
        }
      }

      /**
       * Timer - Individual timer instance for darkroom processes
       *
       * Manages a single countdown timer with drift-corrected precision.
       * Supports auto-sequencing between timers and provides visual feedback.
       * Four instances are typically used: Dev, Stop, Fix, Flo.
       *
       * @class
       * @example
       * const devTimer = new Timer('Dev');
       * devTimer.setTime(60);
       * devTimer.start();
       */
      class Timer {
        /**
         * Creates a Timer instance
         * @constructor
         * @param {string} name - Timer identifier ('Dev', 'Stop', 'Fix', or 'Flo')
         * @property {string} name - Timer identifier
         * @property {DriftCorrectedTimer|null} driftTimer - High-precision timer instance
         * @property {boolean} warningPlayed - Whether 10-second warning has played
         * @property {boolean} isPartOfSequence - Whether timer is part of auto-chain
         */
        constructor(name) {
          this.name = name;
          this.driftTimer = null; // Using drift-corrected timer
          this.warningPlayed = false;
          this.isPartOfSequence = false; // NEW: Track if timer is part of a sequence

          // Initialize state if not exists
          if (!appState.timers[name]) {
            appState.timers[name] = {
              timeLeft: DEFAULT_TIMER_TIMES[name] || 60,
              totalTime: DEFAULT_TIMER_TIMES[name] || 60,
              isRunning: false,
              isEnabled: true,
            };
          }

          // Initialize display immediately
          this.render();
        }

        /**
         * Get current timer state from appState
         * @returns {Object} Timer state object
         */
        get state() {
          return appState.timers[this.name];
        }

        /**
         * Render timer display
         * @returns {void}
         * @description Updates UI elements for this timer
         */
        render() {
          renderTimer(this.name);
        }

        /**
         * Update display (deprecated - use render instead)
         * @deprecated Use render() instead
         * @returns {void}
         */
        updateDisplay() {
          // Deprecated - use render() instead
          this.render();
        }

        /**
         * Update button states (deprecated - use render instead)
         * @deprecated Use render() instead
         * @returns {void}
         */
        updateButtonStates() {
          // Deprecated - use render() instead
          this.render();
        }

        /**
         * Set timer duration
         * @param {number} seconds - Duration in seconds (5-600)
         * @returns {void}
         * @description Stops timer if running and sets new duration
         */
        setTime(seconds) {
          // Stop if running
          if (this.state.isRunning) {
            if (this.driftTimer) {
              this.driftTimer.stop();
            }
            this.state.isRunning = false;
          }

          // Set new time in state
          this.state.totalTime = seconds;
          this.state.timeLeft = seconds;
          this.warningPlayed = false;

          // Update display
          this.render();
        }

        /**
         * Adjust timer duration
         * @param {number} seconds - Amount to adjust (+/-)
         * @returns {void}
         * @description Adds/subtracts from current duration (5-600s range)
         */
        adjustTime(seconds) {
          if (this.state.isRunning || !this.state.isEnabled) return;

          const newTime = this.state.totalTime + seconds;
          if (newTime >= 5 && newTime <= 600) {
            this.state.totalTime = newTime;
            this.state.timeLeft = newTime;
            this.render();
          }
        }

        /**
         * Start the timer
         * @param {boolean} [isSequence=false] - Whether this is part of an auto-chain
         * @returns {void}
         * @description Begins countdown with drift-corrected timing
         */
        start(isSequence = false) {
          if (
            this.state.isRunning ||
            !this.state.isEnabled ||
            this.state.timeLeft <= 0
          )
            return;

          this.state.isRunning = true;
          this.warningPlayed = false;
          this.isPartOfSequence = isSequence; // NEW: Store sequence flag
          this.render();

          // Use drift-corrected timer
          this.driftTimer = new DriftCorrectedTimer(() => {
            this.state.timeLeft--;
            this.render();

            // 10-second warning
            if (
              this.state.timeLeft === 10 &&
              appState.settings.timerWarningBeep &&
              this.state.isEnabled
            ) {
              const box = document.getElementById(`timer${this.name}`);
              if (box) box.classList.add("warning");
              playPreset("timerWarning");
              this.warningPlayed = true;
            }

            // Timer ended
            if (this.state.timeLeft <= 0) {
              this.complete();
            }
          }, 1000);

          this.driftTimer.start();
        }

        /**
         * Stop the timer
         * @returns {void}
         * @description Halts countdown and resets sequence flag
         */
        stop() {
          if (!this.state.isRunning) return;

          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.state.isRunning = false;
          this.isPartOfSequence = false; // NEW: Reset sequence flag
          this.render();
        }

        /**
         * Reset timer to initial duration
         * @returns {void}
         * @description Stops timer and resets time to total duration
         */
        reset() {
          if (this.state.isRunning || !this.state.isEnabled) return;

          this.stop();
          this.state.timeLeft = this.state.totalTime;
          this.warningPlayed = false;
          this.render();
        }

        /**
         * Handle timer completion
         * @returns {void}
         * @description Plays completion sound and starts next timer in sequence
         */
        complete() {
          this.state.isRunning = false;
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.state.timeLeft = 0;
          this.render();

          if (appState.settings.timerEndBeep && this.state.isEnabled) {
            playPreset("timerComplete");
          }

          // NEW: Only auto-start next timer if this was part of a sequence
          if (this.isPartOfSequence) {
            const nextTimer = this.startNextTimer();
            // If no next timer was started, the sequence is complete
            if (!nextTimer) {
              // Reset the start all state
              if (window.startAllState) {
                window.startAllState.isRunning = false;
                window.startAllState.isPaused = false;
                // Update the button
                const btn = document.getElementById("startAll");
                if (btn) {
                  btn.textContent = "Start All";
                  btn.disabled = false;
                }
              }
            }
          }
          // Reset the flag after completion
          this.isPartOfSequence = false;
        }

        /**
         * Toggle timer start/stop
         * @returns {void}
         * @description Starts if stopped, stops if running
         */
        toggle() {
          if (!this.state.isEnabled) return;

          if (this.state.isRunning) {
            this.stop();
          } else {
            if (this.state.timeLeft <= 0) {
              this.reset();
            }
            // NEW: Individual start is NOT part of a sequence
            this.start(false);
          }
        }

        /**
         * Enable or disable timer
         * @param {boolean} enabled - Whether timer should be enabled
         * @returns {void}
         * @description Updates enabled state and visual appearance
         */
        updateEnabledState(enabled) {
          this.state.isEnabled = enabled;
          const box = document.getElementById(`timer${this.name}`);
          if (box) {
            if (enabled) {
              box.classList.remove("disabled");
            } else {
              box.classList.add("disabled");
              this.stop();
            }
          }
          this.render();
        }

        /**
         * Start next timer in sequence
         * @returns {Timer|null} The next timer that was started, or null
         * @description Finds and starts the next enabled timer after this one
         */
        startNextTimer() {
          const timerOrder = ["Dev", "Stop", "Fix", "Flo"];
          const currentIndex = timerOrder.indexOf(this.name);

          for (let i = currentIndex + 1; i < timerOrder.length; i++) {
            const nextTimerName = timerOrder[i];
            const nextTimer = timerManager.timers.find(
              (t) => t.name === nextTimerName
            );

            if (nextTimer && nextTimer.state.isEnabled) {
              setTimeout(() => {
                nextTimer.reset();
                // NEW: Start next timer as part of sequence
                nextTimer.start(true);
              }, 1000);
              return nextTimer; // Return the next timer that was started
            }
          }
          return null; // No next timer found
        }

        /**
         * Get current timer duration
         * @returns {number} Total duration in seconds
         */
        getCurrentTime() {
          return this.state.totalTime;
        }
      }

      /**
       * CountdownManager - Visual and audio countdown before exposure
       *
       * Provides a configurable countdown delay with visual feedback and
       * audible beeps. Supports multiple beep patterns and theme-aware styling.
       * Used before starting any exposure timer.
       *
       * @class
       * @example
       * const countdown = new CountdownManager();
       * await countdown.startCountdown(displayElement, () => {
       *   // Start exposure after countdown
       * });
       */
      class CountdownManager {
        /**
         * Creates a CountdownManager instance
         * @constructor
         * @property {boolean} isActive - Whether countdown is currently running
         * @property {number} countdownValue - Current countdown number
         * @property {number|null} countdownInterval - Interval identifier
         * @property {Function|null} onCompleteCallback - Callback when countdown completes
         * @property {HTMLElement|null} displayElement - Element to update display
         * @property {boolean} beepEnabled - Whether audio feedback is enabled
         * @property {string} beepPattern - Beep pattern: 'every-second', 'last3', 'last5', 'none'
         * @property {string} originalDisplay - Original text content of display
         * @property {string} originalBackground - Original background color
         * @property {string} originalColor - Original text color
         */
        constructor() {
          this.isActive = false;
          this.countdownValue = 5;
          this.countdownInterval = null;
          this.onCompleteCallback = null;
          this.displayElement = null;
          this.beepEnabled = true;
        }

        /**
         * Start the countdown
         * @async
         * @param {HTMLElement} displayElement - Element to show countdown
         * @param {Function} onComplete - Callback to execute when countdown finishes
         * @returns {Promise<void>}
         * @description Loads settings, saves original display state, and begins countdown
         */
        startCountdown(displayElement, onComplete) {
          if (this.isActive) return;

          this.isActive = true;
          this.displayElement = displayElement;
          this.onCompleteCallback = onComplete;

          // Get settings
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
            this.beepEnabled = settingsManager.settings.countdownBeep !== false;
            this.beepPattern =
              settingsManager.settings.countdownPattern || "every-second";
          }

          // Save original display value
          this.originalDisplay = displayElement.textContent;
          this.originalBackground = displayElement.style.backgroundColor;
          this.originalColor = displayElement.style.color;

          // Start countdown with initial beep (if pattern allows)
          if (this.beepEnabled && this.beepPattern !== "none") {
            // Check if pattern allows initial beep
            const pattern = this.beepPattern || "every-second";
            const shouldBeep =
              pattern === "every-second" ||
              (pattern === "last3" && this.countdownValue <= 3) ||
              (pattern === "last5" && this.countdownValue <= 5);

            if (shouldBeep) {
              playCountdownBeep(this.countdownValue);
            }
          }

          this.updateCountdown();
        }

        /**
         * Update countdown display and schedule next tick
         * @private
         * @returns {void}
         * @description Updates visual display, plays beeps, and decrements counter
         */
        updateCountdown() {
          if (this.countdownValue <= 0) {
            this.complete();
            return;
          }

          // Update display
          if (this.displayElement) {
            this.displayElement.textContent = this.countdownValue;
            this.displayElement.style.fontWeight = "bold";

            // Flash effect for last 3 seconds
            if (this.countdownValue <= 3) {
              this.displayElement.style.backgroundColor = "#400";
              this.displayElement.style.color = "#fff";

              if (this.countdownValue <= 1) {
                this.displayElement.style.backgroundColor = "#f00";
              }
            } else {
              this.displayElement.style.backgroundColor = "#300";
              this.displayElement.style.color = "#f00";
            }

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              if (this.countdownValue <= 3) {
                this.displayElement.style.backgroundColor = "#0066cc";
                this.displayElement.style.color = "#fff";
              } else {
                this.displayElement.style.backgroundColor = "#cce5ff";
                this.displayElement.style.color = "#0066cc";
              }
            } else if (document.body.classList.contains("day-scheme")) {
              if (this.countdownValue <= 3) {
                this.displayElement.style.backgroundColor = "#ffcc00";
                this.displayElement.style.color = "#000";
              } else {
                this.displayElement.style.backgroundColor = "#ffdd66";
                this.displayElement.style.color = "#ffcc00";
              }
            }
          }

          // Play beep based on pattern
          if (this.beepEnabled) {
            const pattern = this.beepPattern || "every-second";
            let shouldBeep = false;

            switch (pattern) {
              case "every-second":
                shouldBeep = true;
                break;
              case "last3":
                shouldBeep = this.countdownValue <= 3;
                break;
              case "last5":
                shouldBeep = this.countdownValue <= 5;
                break;
              case "none":
                shouldBeep = false;
                break;
              default:
                shouldBeep = true;
            }

            if (shouldBeep) {
              // Use countdown beep with time-based patterns
              playCountdownBeep(this.countdownValue);
            }
          }

          this.countdownValue--;

          // Schedule next update
          this.countdownInterval = setTimeout(
            () => this.updateCountdown(),
            1000
          );
        }

        /**
         * Complete the countdown
         * @returns {void}
         * @description Restores display, plays final beep, and executes callback
         */
        complete() {
          this.isActive = false;
          clearTimeout(this.countdownInterval);

          // Final beep
          if (this.beepEnabled) {
            playPreset("countdownComplete");
          }

          // Restore display
          if (this.displayElement) {
            this.displayElement.textContent = this.originalDisplay;
            this.displayElement.style.backgroundColor =
              this.originalBackground || "";
            this.displayElement.style.color = this.originalColor || "";
            this.displayElement.style.fontWeight = "";
          }

          // Reset countdown value for next use
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
          } else {
            this.countdownValue = 5;
          }

          // Call completion callback
          if (this.onCompleteCallback) {
            this.onCompleteCallback();
          }
        }

        /**
         * Cancel the countdown
         * @returns {void}
         * @description Stops countdown and restores display without executing callback
         */
        cancel() {
          this.isActive = false;
          clearTimeout(this.countdownInterval);

          // Restore display
          if (this.displayElement) {
            this.displayElement.textContent = this.originalDisplay;
            this.displayElement.style.backgroundColor =
              this.originalBackground || "";
            this.displayElement.style.color = this.originalColor || "";
            this.displayElement.style.fontWeight = "";
          }

          // Reset countdown value
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
          } else {
            this.countdownValue = 5;
          }
        }
      }

      /**
       * SettingsManager - Manages user preferences and application configuration
       *
       * Handles loading, saving, and applying all user settings including:
       * - Timer defaults and durations
       * - Sound preferences
       * - Color scheme
       * - Countdown settings
       * - Test strip auto-advance
       * - Safelight auto-off
       * - F-stop denominator
       * - Base time slider limits
       *
       * @class
       * @example
       * const settings = new SettingsManager();
       * settings.saveGlobalSettings();
       */
      class SettingsManager {
        /**
         * Creates a SettingsManager instance
         * @constructor
         * @property {Object} settings - Current settings object
         * @property {Array} profiles - Timer profiles array
         * @property {string} colorScheme - Current color scheme
         * @description Loads settings from storage and applies them to UI and appState
         */
        constructor() {
          this.settings = StorageManager.loadSettings();
          this.profiles = StorageManager.loadProfiles();
          this.colorScheme = StorageManager.loadColorScheme();

          // Load persistent UI state into appState (single source of truth)
          appState.persistent.currentProfile =
            StorageManager.loadCurrentProfile();

          // Sync loaded settings to appState
          Object.assign(appState.settings, this.settings);

          this.applyColorScheme();
          this.applySoundSettings();

          // Apply auto advance setting to F-Stop Test generator
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.setAutoAdvance(
              this.settings.autoAdvance || false
            );
          }

          // Ensure chemical manager is available
          if (window.chemicalManager) {
            // Load any existing chemical data
            window.chemicalManager.chemicalPresets =
              StorageManager.loadChemicalPresets();
            window.chemicalManager.capacityData =
              StorageManager.loadCapacityTracker();
            window.chemicalManager.shelfLifeData =
              StorageManager.loadShelfLife();
          }

          // Clear button listener is set up via global delegation in DOMContentLoaded
        }

        /**
         * Apply sound settings to appState and UI
         * @returns {void}
         * @description Syncs sound preferences from settings to appState and updates UI
         */
        applySoundSettings() {
          // Apply sound settings from saved settings and sync to appState
          if (this.settings.calcWarningBeep !== undefined) {
            appState.settings.calcWarningBeep = this.settings.calcWarningBeep;
          }
          if (this.settings.calcEndBeep !== undefined) {
            appState.settings.calcEndBeep = this.settings.calcEndBeep;
          }
          if (this.settings.timerWarningBeep !== undefined) {
            appState.settings.timerWarningBeep = this.settings.timerWarningBeep;
          }
          if (this.settings.timerEndBeep !== undefined) {
            appState.settings.timerEndBeep = this.settings.timerEndBeep;
          }

          // Update UI to reflect state
          renderSoundSettings();
        }

        /**
         * Apply color scheme to document body
         * @returns {void}
         * @description Updates CSS classes and saves scheme preference
         */
        applyColorScheme() {
          document.body.classList.remove(
            "dark-scheme",
            "light-scheme",
            "day-scheme"
          );
          document.body.classList.add(`${this.colorScheme}-scheme`);

          document
            .querySelectorAll(".toggle-btn[data-scheme]")
            .forEach((btn) => {
              btn.classList.remove("active");
              if (btn.getAttribute("data-scheme") === this.colorScheme) {
                btn.classList.add("active");
              }
            });

          this.settings.colorScheme = this.colorScheme;
          StorageManager.saveSettings(this.settings);
        }

        /**
         * Set and apply color scheme
         * @param {string} scheme - Color scheme name ('dark', 'light', or 'day')
         * @returns {void}
         */
        setColorScheme(scheme) {
          if (["dark", "light", "day"].includes(scheme)) {
            this.colorScheme = scheme;
            StorageManager.saveColorScheme(scheme);
            this.applyColorScheme();
          }
        }

        /**
         * Get currently loaded profile name
         * @returns {string|null} Current profile name or null
         * @description Uses appState as single source of truth
         */
        getCurrentProfile() {
          return appState.persistent.currentProfile;
        }

        /**
         * Set currently loaded profile name
         * @param {string|null} profileName - Profile name or null
         * @description Updates appState and persists to storage
         */
        setCurrentProfile(profileName) {
          appState.persistent.currentProfile = profileName;
          StorageManager.saveCurrentProfile(profileName);
        }

        /**
         * Read current UI values into settings object
         * @returns {void}
         * @description Collects all settings from UI controls
         */
        readSettingsFromUI() {
          this.settings = {
            baseTime: parseFloat(
              document.getElementById("settingBaseTime").value
            ),
            devTime: parseInt(document.getElementById("settingDevTime").value),
            stopTime: parseInt(
              document.getElementById("settingStopTime").value
            ),
            fixTime: parseInt(document.getElementById("settingFixTime").value),
            floTime: parseInt(document.getElementById("settingFloTime").value),
            calcWarningBeep: document.getElementById("settingCalcWarningBeep")
              .checked,
            calcEndBeep: document.getElementById("settingCalcEndBeep").checked,
            timerWarningBeep: document.getElementById("settingTimerWarningBeep")
              .checked,
            timerEndBeep: document.getElementById("settingTimerEndBeep")
              .checked,
            defaultPhotoFlo: document.getElementById("settingDefaultPhotoFlo")
              .checked,
            colorScheme: this.colorScheme,
            countdownDelay: parseInt(
              document.getElementById("settingCountdownDelay").value
            ),
            countdownBeep: document.getElementById("settingCountdownBeep")
              .checked,
            countdownPattern: document.getElementById("settingCountdownPattern")
              .value,
            autoAdvance: document.getElementById("settingAutoAdvance").checked,
            autoAdvanceDelay: parseInt(
              document.getElementById("settingAutoAdvanceDelay").value
            ),
            safelightAutoOff:
              document.getElementById("safelightAutoOff").checked, // NEW
            // Base time slider limits
            baseTimeMin: parseFloat(
              document.getElementById("baseTimeMin")?.value || 0.4
            ),
            baseTimeMax: parseFloat(
              document.getElementById("baseTimeMax")?.value || 50
            ),
            // Test base time slider limits
            testBaseTimeMin: parseFloat(
              document.getElementById("testBaseTimeMin")?.value || 1
            ),
            testBaseTimeMax: parseFloat(
              document.getElementById("testBaseTimeMax")?.value || 50
            ),
            // F-stop denominator setting (2, 3, or 4) - Settings select takes precedence, then segmented controls, then legacy selects
            stopDenominator: (function () {
              const settingsSel = document.getElementById(
                "settingStopIncrement"
              );
              if (settingsSel && settingsSel.value)
                return parseInt(settingsSel.value, 10) || 3;
              function fromSeg(id) {
                const s = document.getElementById(id);
                if (!s) return null;
                const active =
                  s.querySelector(".segmented-btn.active") ||
                  s.querySelector('.segmented-btn[aria-pressed="true"]');
                if (active) return parseInt(active.dataset.denom, 10);
                return null;
              }
              const cs = fromSeg("calcIncrementSeg");
              if (cs) return cs;
              const ts = fromSeg("testIncrementSeg");
              if (ts) return ts;
              // backward compatibility with legacy <select>
              const c = document.getElementById("calcIncrementDenom");
              const t = document.getElementById("testIncrementDenom");
              if (c) return parseInt(c.value, 10) || 3;
              if (t) return parseInt(t.value, 10) || 3;
              return 3;
            })(),
          };
        }

        /**
         * Apply settings to runtime and UI
         * @returns {void}
         * @description Updates all components with current settings values
         */
        applySettingsToRuntime() {
          // Apply to UI
          this.applySoundSettings();

          // Apply Photo Wash
          const photoFloToggle = document.getElementById("photoFloToggle");
          if (photoFloToggle) {
            photoFloToggle.checked = this.settings.defaultPhotoFlo;
          }
          if (timerManager && timerManager.timers) {
            const floTimer = timerManager.timers.find((t) => t.name === "Flo");
            if (floTimer) {
              floTimer.updateEnabledState(this.settings.defaultPhotoFlo);
            }
          }

          // Apply auto advance to F-Stop Test generator
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.setAutoAdvance(this.settings.autoAdvance);
            window.fstopTestGenerator.setAutoAdvanceDelay(
              this.settings.autoAdvanceDelay * 1000
            ); // Convert to ms
          }

          // Apply base time slider limits
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            const newMin = parseFloat(this.settings.baseTimeMin) || 0.4;
            const newMax = parseFloat(this.settings.baseTimeMax) || 50;
            baseSlider.min = newMin;
            baseSlider.max = newMax;
            // Ensure current value is within new range
            const currentValue = parseFloat(baseSlider.value);
            if (currentValue < newMin) baseSlider.value = newMin;
            if (currentValue > newMax) baseSlider.value = newMax;
          }

          // Apply test base time slider limits
          const testBaseSlider = document.getElementById("testBaseSlider");
          if (testBaseSlider) {
            const newMin = parseFloat(this.settings.testBaseTimeMin) || 1;
            const newMax = parseFloat(this.settings.testBaseTimeMax) || 50;
            testBaseSlider.min = newMin;
            testBaseSlider.max = newMax;
            // Ensure current value is within new range
            const currentValue = parseFloat(testBaseSlider.value);
            if (currentValue < newMin) testBaseSlider.value = newMin;
            if (currentValue > newMax) testBaseSlider.value = newMax;
          }

          // Apply base time to calculators and test generator so UI updates immediately
          const newBase = parseFloat(this.settings.baseTime);
          const baseSliderEl = document.getElementById("baseTimeSlider");
          if (baseSliderEl) {
            baseSliderEl.value = newBase;
            baseSliderEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
          const testBaseEl = document.getElementById("testBaseSlider");
          if (testBaseEl) {
            testBaseEl.value = newBase;
            testBaseEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = newBase;
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.baseTime = newBase;
            if (window.fstopTestGenerator.testBaseSlider) {
              window.fstopTestGenerator.testBaseSlider.value = newBase;
            }
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }

          // Apply saved timer default times to Timer instances and DEFAULT_TIMER_TIMES
          if (
            typeof DEFAULT_TIMER_TIMES !== "undefined" &&
            timerManager &&
            timerManager.timers
          ) {
            const mapping = {
              Dev: parseInt(this.settings.devTime, 10),
              Stop: parseInt(this.settings.stopTime, 10),
              Fix: parseInt(this.settings.fixTime, 10),
              Flo: parseInt(this.settings.floTime, 10),
            };

            // Update DEFAULT_TIMER_TIMES so newly created timers use the saved defaults
            Object.keys(mapping).forEach((k) => {
              if (typeof mapping[k] === "number" && !isNaN(mapping[k])) {
                DEFAULT_TIMER_TIMES[k] = mapping[k];
              }
            });

            // Update existing timer instances
            timerManager.timers.forEach((timer) => {
              const newTime = mapping[timer.name];
              if (typeof newTime === "number" && !isNaN(newTime)) {
                if (!timer.isRunning) {
                  // Reset to new default
                  timer.setTime(newTime);
                } else {
                  // If running, update total and remaining time without interrupting display logic
                  timer.totalTime = newTime;
                  timer.timeLeft = newTime;
                  timer.warningPlayed = false;
                  timer.updateDisplay();
                  timer.updateButtonStates();
                }
              }
            });
          }

          // Apply f-stop denominator setting (2, 3, 4)
          (function applyDenominator() {
            const denom = parseInt(this.settings.stopDenominator, 10) || 3;
            window.stopDenominator = denom;
            // Apply to segmented controls if present
            function setSeg(containerId, d) {
              const cont = document.getElementById(containerId);
              if (!cont) return;
              Array.from(cont.querySelectorAll(".segmented-btn")).forEach(
                (b) => {
                  if (parseInt(b.dataset.denom, 10) === d) {
                    b.classList.add("active");
                    b.setAttribute("aria-pressed", "true");
                  } else {
                    b.classList.remove("active");
                    b.setAttribute("aria-pressed", "false");
                  }
                }
              );
            }
            setSeg("calcIncrementSeg", denom);
            setSeg("testIncrementSeg", denom);
            // Legacy selects (back-compat)
            const c = document.getElementById("calcIncrementDenom");
            const t = document.getElementById("testIncrementDenom");
            if (c) c.value = denom;
            if (t) t.value = denom;
            const settingsSel = document.getElementById("settingStopIncrement");
            if (settingsSel) settingsSel.value = denom;
            if (window.incrementalTimer) {
              window.incrementalTimer.updateCalculations();
              window.incrementalTimer.updateAllDisplays();
            }
            if (window.fstopTestGenerator) {
              window.fstopTestGenerator.generateSteps();
              window.fstopTestGenerator.updateDisplay();
            }
            try {
              updateAllRulers();
            } catch (e) {
              /* ignore if not yet defined */
            }
            try {
              updateChart();
            } catch (e) {}
          }).call(this);
        }

        /**
         * Save global settings from UI
         * @returns {void}
         * @description Reads UI, saves to storage, and applies to runtime
         */
        saveGlobalSettings() {
          this.readSettingsFromUI();
          // Sync to appState
          Object.assign(appState.settings, this.settings);

          if (StorageManager.saveSettings(this.settings)) {
            this.applySettingsToRuntime();
            this.showAllProfilesFeedback("Global settings saved!", "success");
          }
        }

        /**
         * Apply settings live without feedback
         * @returns {void}
         * @description Reads UI, saves to storage, applies to runtime (debounced)
         */
        applyLiveSettings() {
          this.readSettingsFromUI();
          // Sync to appState
          Object.assign(appState.settings, this.settings);

          // Save immediately for persistence but don't show the save feedback
          StorageManager.saveSettings(this.settings);
          this.applySettingsToRuntime();
          // Announce setting change to assistive tech
          try {
            const live = document.getElementById("settingsLiveStatus");
            if (live) {
              const denom = this.settings.stopDenominator || 3;
              live.textContent = `Default stop increment set to ${denomLabel(
                denom
              )}`;
            }
          } catch (e) {}
        }

        // Generic save preset/profile helper
        savePreset(config) {
          const {
            name,
            dataObject,
            collection,
            storageMethod,
            updateListMethod,
            feedbackMethod,
            feedbackButton,
            successMessage,
          } = config;

          if (!name || name.trim() === "") {
            if (feedbackMethod) {
              feedbackMethod("Please enter a name", "error");
            } else {
              alert("Please enter a name");
            }
            return false;
          }

          const preset = {
            name: name.trim(),
            ...dataObject,
            date: new Date().toISOString(),
          };

          const existingIndex = collection.findIndex(
            (p) => p.name === preset.name
          );
          if (existingIndex >= 0) {
            collection[existingIndex] = preset;
          } else {
            collection.push(preset);
          }

          if (storageMethod(collection)) {
            if (updateListMethod) updateListMethod();

            // Feedback handling
            if (feedbackMethod) {
              feedbackMethod(
                successMessage || `"${preset.name}" saved!`,
                "success"
              );
            } else if (feedbackButton) {
              playBeep(800, 0.3, 0.3);
              const originalText = feedbackButton.textContent;
              feedbackButton.textContent = "Saved!";
              feedbackButton.classList.add("active");
              setTimeout(() => {
                feedbackButton.textContent = originalText;
                feedbackButton.classList.remove("active");
              }, 1000);
            }
            return true;
          }
          return false;
        }

        // Generic delete preset/profile helper
        deletePreset(config) {
          const {
            name,
            collection,
            storageMethod,
            updateListMethod,
            feedbackMethod,
            confirmMessage,
            successMessage,
            onDeleteCallback,
          } = config;

          if (confirm(confirmMessage || `Delete "${name}"?`)) {
            const newCollection = collection.filter((p) => p.name !== name);
            collection.length = 0;
            collection.push(...newCollection);

            if (onDeleteCallback) onDeleteCallback();

            if (storageMethod(collection)) {
              if (updateListMethod) updateListMethod();
              if (feedbackMethod) {
                feedbackMethod(
                  successMessage || `"${name}" deleted!`,
                  "success"
                );
              }
              playBeep(400, 0.3, 0.3);
              return true;
            }
          }
          return false;
        }

        // Generic render preset list helper
        renderPresetList(config) {
          const { listElement, collection, currentItem, renderItemContent } =
            config;

          if (!listElement) return;

          listElement.innerHTML = "";

          collection.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = `shelf-life-item ${
              currentItem === item.name ? "active" : ""
            }`;

            itemDiv.innerHTML = renderItemContent(item);
            listElement.appendChild(itemDiv);
          });
        }

        // Generic clear all presets helper
        clearAllPresets(config) {
          const {
            collection,
            storageMethod,
            updateListMethod,
            feedbackMethod,
            confirmMessage,
            successMessage,
            onClearCallback,
          } = config;

          if (
            confirm(
              confirmMessage || "Delete ALL items? This cannot be undone!"
            )
          ) {
            collection.length = 0;

            if (onClearCallback) onClearCallback();

            if (storageMethod(collection)) {
              if (updateListMethod) updateListMethod();
              if (feedbackMethod) {
                feedbackMethod(
                  successMessage || "All items deleted!",
                  "success"
                );
              } else {
                playBeep(600, 0.5, 0.3);
              }
              return true;
            }
          }
          return false;
        }

        saveCurrentProfile(name) {
          // Get current timer times from timer objects
          const currentTimes = {};
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              currentTimes[timer.name] = timer.getCurrentTime();
            });
          }

          const result = this.savePreset({
            name,
            dataObject: { times: currentTimes },
            collection: this.profiles,
            storageMethod: (profiles) => StorageManager.saveProfiles(profiles),
            updateListMethod: () => this.updateTimerProfileListUI(),
            feedbackMethod: (msg, type) =>
              this.showAllProfilesFeedback(msg, type),
            successMessage: `Profile "${name}" saved!`,
          });

          if (result) {
            this.setCurrentProfile(name.trim());
          }
          return result;
        }

        loadProfile(profile) {
          if (!profile || !profile.times) {
            this.showAllProfilesFeedback("Invalid profile format", "error");
            return false;
          }

          // Stop all running timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              if (timer.isRunning) {
                timer.stop();
              }
            });
          }

          // Apply profile times to timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              if (profile.times[timer.name] !== undefined) {
                timer.setTime(profile.times[timer.name]);
              }
            });
          }

          this.setCurrentProfile(profile.name);
          this.updateTimerProfileListUI();

          playBeep(600, 0.3, 0.3);
          this.showAllProfilesFeedback(
            `Profile "${profile.name}" loaded!`,
            "success"
          );
          return true;
        }

        deleteProfile(profileName) {
          return this.deletePreset({
            name: profileName,
            collection: this.profiles,
            storageMethod: (profiles) => StorageManager.saveProfiles(profiles),
            updateListMethod: () => this.updateTimerProfileListUI(),
            feedbackMethod: (msg, type) =>
              this.showAllProfilesFeedback(msg, type),
            confirmMessage: `Delete profile "${profileName}"?`,
            successMessage: `Profile "${profileName}" deleted!`,
            onDeleteCallback: () => {
              if (this.getCurrentProfile() === profileName) {
                this.setCurrentProfile(null);
              }
            },
          });
        }

        clearAllProfiles() {
          return this.clearAllPresets({
            collection: this.profiles,
            storageMethod: () => StorageManager.saveProfiles([]),
            updateListMethod: () => this.updateTimerProfileListUI(),
            feedbackMethod: (msg, type) =>
              this.showAllProfilesFeedback(msg, type),
            confirmMessage: "Delete ALL timer profiles? This cannot be undone!",
            successMessage: "All timer profiles deleted!",
            onClearCallback: () => {
              this.setCurrentProfile(null);
            },
          });
        }

        resetAllSettings() {
          if (
            confirm(
              "Reset all settings to defaults? This will delete all profiles and settings!"
            )
          ) {
            StorageManager.clearAll();
            this.settings = { ...DEFAULT_SETTINGS };
            this.profiles = [];
            this.setCurrentProfile(null);
            this.colorScheme = "dark";
            this.applyColorScheme();
            this.applySoundSettings();
            loadSettingsToUI();
            this.updateTimerProfileListUI();
            this.showAllProfilesFeedback(
              "All settings reset to defaults!",
              "success"
            );
            location.reload();
          }
        }

        exportAllData() {
          // Ensure we export the latest UI state
          this.readSettingsFromUI();

          // Normalize settings to guarantee stop increment is present and numeric
          const settingsToExport = {
            ...DEFAULT_SETTINGS,
            ...this.settings,
            stopDenominator:
              parseInt(this.settings.stopDenominator, 10) ||
              DEFAULT_SETTINGS.stopDenominator,
          };

          const exportData = {
            app: "Darkroom Timer",
            version: "2.9.1",
            exportDate: new Date().toISOString(),
            settings: settingsToExport,
            timerProfiles: this.profiles,
            chemicalPresets: window.chemicalManager
              ? window.chemicalManager.chemicalPresets
              : [],
            capacityTracker: StorageManager.loadCapacityTracker(),
            shelfLifeData: StorageManager.loadShelfLife(),
            customFilterBanks: StorageManager.loadCustomFilterBanks(),
          };

          const jsonStr = JSON.stringify(exportData, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `darkroom-timer-data-${new Date()
            .toISOString()
            .slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          this.showAllProfilesFeedback(
            "All data exported successfully!",
            "success"
          );
        }

        importAllData(jsonData) {
          try {
            const data = JSON.parse(jsonData);
            let importedCount = 0;

            // Import global settings
            if (data.settings && typeof data.settings === "object") {
              this.settings = { ...DEFAULT_SETTINGS, ...data.settings };
              this.colorScheme = this.settings.colorScheme || "dark";
              StorageManager.saveSettings(this.settings);
              StorageManager.saveColorScheme(this.colorScheme);
              this.applyColorScheme();
              this.applySoundSettings();
              this.applySettingsToRuntime();
              if (typeof loadSettingsToUI === "function") {
                loadSettingsToUI();
              }
              importedCount++;
            }

            // Import timer profiles
            if (data.timerProfiles && Array.isArray(data.timerProfiles)) {
              const validProfiles = data.timerProfiles.filter((profile) => {
                return (
                  profile &&
                  typeof profile.name === "string" &&
                  profile.name.trim() !== "" &&
                  profile.times &&
                  typeof profile.times === "object"
                );
              });

              if (validProfiles.length > 0) {
                const existingNames = this.profiles.map((p) => p.name);
                const newNames = validProfiles.map((p) => p.name);
                const duplicates = newNames.filter((name) =>
                  existingNames.includes(name)
                );

                let mergeStrategy = "skip";
                if (duplicates.length > 0) {
                  mergeStrategy =
                    prompt(
                      `Found ${
                        duplicates.length
                      } duplicate timer profile(s): ${duplicates.join(
                        ", "
                      )}\n\n` +
                        `Enter 'overwrite' to replace duplicates, or 'skip' to keep existing:`,
                      "skip"
                    )?.toLowerCase() || "skip";

                  if (!["overwrite", "skip"].includes(mergeStrategy)) {
                    mergeStrategy = "skip";
                  }
                }

                validProfiles.forEach((newProfile) => {
                  const existingIndex = this.profiles.findIndex(
                    (p) => p.name === newProfile.name
                  );

                  if (existingIndex >= 0) {
                    if (mergeStrategy === "overwrite") {
                      this.profiles[existingIndex] = {
                        ...newProfile,
                        date: newProfile.date || new Date().toISOString(),
                      };
                    }
                  } else {
                    this.profiles.push({
                      ...newProfile,
                      date: newProfile.date || new Date().toISOString(),
                    });
                  }
                });

                StorageManager.saveProfiles(this.profiles);
                importedCount += validProfiles.length;
              }
            }

            // Import chemical presets
            if (
              data.chemicalPresets &&
              Array.isArray(data.chemicalPresets) &&
              window.chemicalManager
            ) {
              const validChemicalPresets = data.chemicalPresets.filter(
                (preset) => {
                  return (
                    preset &&
                    typeof preset.name === "string" &&
                    preset.name.trim() !== "" &&
                    preset.totalVolume &&
                    preset.dilutionRatio
                  );
                }
              );

              if (validChemicalPresets.length > 0) {
                validChemicalPresets.forEach((newPreset) => {
                  const existingIndex =
                    window.chemicalManager.chemicalPresets.findIndex(
                      (p) => p.name === newPreset.name
                    );
                  if (existingIndex >= 0) {
                    window.chemicalManager.chemicalPresets[existingIndex] =
                      newPreset;
                  } else {
                    window.chemicalManager.chemicalPresets.push(newPreset);
                  }
                });

                StorageManager.saveChemicalPresets(
                  window.chemicalManager.chemicalPresets
                );
                window.chemicalManager.updateChemicalPresetList();
                importedCount += validChemicalPresets.length;
              }
            }

            // Import capacity tracker
            if (data.capacityTracker && window.chemicalManager) {
              window.chemicalManager.capacityData = {
                ...window.chemicalManager.capacityData,
                ...data.capacityTracker,
              };
              StorageManager.saveCapacityTracker(
                window.chemicalManager.capacityData
              );
              window.chemicalManager.updateCapacityDisplay();
              importedCount++;
            }

            // Import shelf life data (ACTIVE CHEMICALS)
            if (
              data.shelfLifeData &&
              Array.isArray(data.shelfLifeData) &&
              window.chemicalManager
            ) {
              // First, clear existing shelf life data
              window.chemicalManager.shelfLifeData = [];

              // Validate and import each chemical
              data.shelfLifeData.forEach((chemical) => {
                // Validate required fields
                if (
                  chemical &&
                  chemical.name &&
                  chemical.dateMixed &&
                  chemical.shelfLifeDays
                ) {
                  // Add the chemical to shelf life data
                  window.chemicalManager.shelfLifeData.push({
                    id: chemical.id || Date.now() + Math.random(),
                    type: chemical.type || "custom",
                    name: chemical.name,
                    dateMixed: chemical.dateMixed,
                    shelfLifeDays: chemical.shelfLifeDays,
                    dateAdded: chemical.dateAdded || new Date().toISOString(),
                  });
                }
              });

              // Save to storage
              StorageManager.saveShelfLife(
                window.chemicalManager.shelfLifeData
              );

              // Update the shelf life list in the UI
              if (window.chemicalManager.shelfLifeList) {
                window.chemicalManager.updateShelfLifeList();
              }

              importedCount += window.chemicalManager.shelfLifeData.length;

              // Show notification if we're currently on the chemical tab
              const currentTab = document
                .querySelector(".tab-button.active")
                .getAttribute("data-tab");
              if (currentTab === "chemical") {
                this.showAllProfilesFeedback(
                  `Loaded ${window.chemicalManager.shelfLifeData.length} active chemicals`,
                  "success"
                );
              }
            }

            // Update all UIs
            this.updateTimerProfileListUI();

            // Import custom filter banks
            if (data.customFilterBanks) {
              const banks = Array.isArray(data.customFilterBanks)
                ? data.customFilterBanks
                : getDefaultCustomFilterBanks();
              StorageManager.saveCustomFilterBanks(banks);
              if (window.customFilterBankManager) {
                window.customFilterBankManager.replaceData(banks);
              }
              importedCount++;
            }

            // Refresh the chemical tab if it's currently active
            const currentTab = document
              .querySelector(".tab-button.active")
              .getAttribute("data-tab");
            if (currentTab === "chemical" && window.chemicalManager) {
              window.chemicalManager.updateDisplay();
            }

            // Visual feedback for chemical data
            if (window.chemicalManager) {
              // Briefly highlight the chemical tab if we imported chemical data
              const chemicalTabBtn = document.querySelector(
                '.tab-button[data-tab="chemical"]'
              );
              if (chemicalTabBtn) {
                chemicalTabBtn.style.backgroundColor = "#400";
                setTimeout(() => {
                  chemicalTabBtn.style.backgroundColor = "";
                }, 1000);
              }
            }

            this.showAllProfilesFeedback(
              `Successfully imported ${importedCount} items!`,
              "success"
            );

            return true;
          } catch (error) {
            this.showAllProfilesFeedback(
              `Import failed: ${error.message}`,
              "error"
            );
            return false;
          }
        }

        showAllProfilesFeedback(message, type = "info") {
          showFeedback("allProfilesFeedback", message, type);
        }

        updateTimerProfileListUI() {
          const profileList = document.getElementById("timerProfileList");
          if (!profileList) return;

          this.renderPresetList({
            listElement: profileList,
            collection: this.profiles,
            currentItem: this.getCurrentProfile(),
            renderItemContent: (profile) => {
              let timeStr = "";
              if (profile.times) {
                const devTime = profile.times.Dev || DEFAULT_TIMER_TIMES.Dev;
                const stopTime = profile.times.Stop || DEFAULT_TIMER_TIMES.Stop;
                const fixTime = profile.times.Fix || DEFAULT_TIMER_TIMES.Fix;

                const devMin = Math.floor(devTime / 60);
                const devSec = devTime % 60;
                const fixMin = Math.floor(fixTime / 60);
                const fixSec = fixTime % 60;

                timeStr = `Dev:${devMin}:${devSec
                  .toString()
                  .padStart(2, "0")} Stop:${stopTime}s Fix:${fixMin}:${fixSec
                  .toString()
                  .padStart(2, "0")}`;
              } else {
                timeStr = "No times saved";
              }

              return `
                        <div>
                            <strong>${profile.name}</strong>
                            <div style="font-size: 0.65rem; color: var(--text-secondary);">${new Date(
                              profile.date
                            ).toLocaleDateString()}</div>
                            <div style="font-size: 0.6rem; color: var(--accent);">${timeStr}</div>
                        </div>
                        <div class="shelf-life-actions">
                            <button class="btn-action load-btn" data-context="profile" data-name="${
                              profile.name
                            }">Load</button>
                            <button class="btn-action delete-btn" data-context="profile" data-name="${
                              profile.name
                            }">Delete</button>
                        </div>
                    `;
            },
          });
        }
      }

      /**
       * ChemicalManager - Manages chemical calculations and tracking
       *
       * Handles chemical mix calculations, capacity tracking, shelf life management,
       * and chemical presets. Integrates with StorageManager for persistence.
       *
       * @class
       * @example
       * const chemManager = new ChemicalManager();
       * chemManager.updateMixCalculator();
       */
      class ChemicalManager {
        /**
         * Creates a ChemicalManager instance
         * @constructor
         * @property {number} totalVolume - Total volume in ml
         * @property {string} dilutionRatio - Current dilution ratio
         * @property {number} customStockParts - Custom stock parts
         * @property {number} customWaterParts - Custom water parts
         * @property {Object} capacityData - Developer capacity tracking data
         * @property {Array} shelfLifeData - Active chemicals array
         * @property {Array} chemicalPresets - Saved chemical presets
         * @property {number} currentPaperSize - Current paper size in m²
         */
        constructor() {
          this.totalVolume = 1000;
          this.dilutionRatio = "1+9";
          this.customStockParts = 1;
          this.customWaterParts = 9;
          // Note: currentPreset is now stored in appState.persistent.currentChemicalPreset
          this.capacityData = StorageManager.loadCapacityTracker();
          this.shelfLifeData = StorageManager.loadShelfLife();
          this.chemicalPresets = StorageManager.loadChemicalPresets();
          this.currentPaperSize = this.capacityData.paperSize || 0.08;

          this.init();
          this.updateMixCalculator();
          this.updateCapacityDisplay();
          this.updateShelfLifeList();
          this.updateChemicalPresetList();

          // Set up custom chemical name visibility
          this.chemicalTypeSelect.addEventListener("change", () => {
            if (this.chemicalTypeSelect.value === "custom") {
              this.customChemicalNameContainer.style.display = "block";
            } else {
              this.customChemicalNameContainer.style.display = "none";
            }
          });
        }

        /**
         * Get currently loaded chemical preset name
         * @returns {string|null} Current preset name or null
         * @description Uses appState as single source of truth
         */
        getCurrentPreset() {
          return appState.persistent.currentChemicalPreset;
        }

        /**
         * Set currently loaded chemical preset name
         * @param {string|null} presetName - Preset name or null
         * @description Updates appState
         */
        setCurrentPreset(presetName) {
          appState.persistent.currentChemicalPreset = presetName;
        }

        /**
         * Initialize ChemicalManager - get DOM elements and set up event listeners
         * @private
         * @returns {void}
         */
        init() {
          // Get elements
          this.totalVolumeSlider = document.getElementById("totalVolumeSlider");
          this.totalVolumeValue = document.getElementById("totalVolumeValue");
          this.dilutionBtns = document.querySelectorAll(
            ".toggle-btn[data-ratio]"
          );
          this.customStockPartsInput =
            document.getElementById("customStockParts");
          this.customWaterPartsInput =
            document.getElementById("customWaterParts");
          this.stockVolumeElement = document.getElementById("stockVolume");
          this.waterVolumeElement = document.getElementById("waterVolume");

          // Chemical preset elements
          this.chemicalPresetNameInput =
            document.getElementById("chemicalPresetName");
          this.saveChemicalPresetBtn =
            document.getElementById("saveChemicalPreset");
          this.chemicalPresetList =
            document.getElementById("chemicalPresetList");
          this.clearChemicalPresetsBtn = document.getElementById(
            "clearChemicalPresets"
          );

          // Capacity tracker elements - UPDATED
          this.capacitySlider = document.getElementById("capacitySlider");
          this.capacityValue = document.getElementById("capacityValue");
          this.trayVolumeSlider = document.getElementById("trayVolumeSlider");
          this.trayVolumeValue = document.getElementById("trayVolumeValue");
          this.maxPrintsValue = document.getElementById("maxPrintsValue");
          this.printsRemaining = document.getElementById("printsRemaining");
          this.capacityProgressBar = document.getElementById(
            "capacityProgressBar"
          );
          this.capacityMiddleLabel = document.getElementById(
            "capacityMiddleLabel"
          );
          this.capacityMaxLabel = document.getElementById("capacityMaxLabel");
          this.addPrintBtn = document.getElementById("addPrint");
          this.add5PrintsBtn = document.getElementById("add5Prints");
          this.resetPrintsBtn = document.getElementById("resetPrints");
          this.printsDoneValue = document.getElementById("printsDoneValue");
          this.areaUsedValue = document.getElementById("areaUsedValue");
          this.percentUsedValue = document.getElementById("percentUsedValue");
          this.capacityStatus = document.getElementById("capacityStatus");

          // Paper size elements - NEW
          this.paperSizeBtns = document.querySelectorAll(
            ".toggle-btn[data-size]"
          );
          this.customPaperSizeInput =
            document.getElementById("customPaperSize");
          this.useCustomSizeBtn = document.getElementById("useCustomSize");

          // Shelf life elements - UPDATED
          this.chemicalTypeSelect = document.getElementById("chemicalType");
          this.customChemicalNameContainer = document.getElementById(
            "customChemicalNameContainer"
          );
          this.customChemicalNameInput =
            document.getElementById("customChemicalName");
          this.shelfLifeDaysInput = document.getElementById("shelfLifeDays");
          this.chemicalDateInput = document.getElementById("chemicalDate");
          this.addChemicalBtn = document.getElementById("addChemical");
          this.shelfLifeList = document.getElementById("shelfLifeList");
          this.clearExpiredBtn = document.getElementById("clearExpired");

          // Set current date as default
          const today = new Date().toISOString().split("T")[0];
          this.chemicalDateInput.value = today;

          // Add event listeners for inputs/sliders (not buttons - those use delegation)
          this.totalVolumeSlider.addEventListener("input", () =>
            this.updateMixCalculator()
          );

          // FIX: Allow typing in custom inputs
          this.customStockPartsInput.addEventListener("input", () => {
            this.customStockParts =
              parseInt(this.customStockPartsInput.value) || 1;
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.updateMixCalculator();
          });

          this.customWaterPartsInput.addEventListener("input", () => {
            this.customWaterParts =
              parseInt(this.customWaterPartsInput.value) || 1;
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.updateMixCalculator();
          });

          // Capacity tracker slider events
          this.capacitySlider.addEventListener("input", () =>
            this.updateCapacityDisplay()
          );
          this.trayVolumeSlider.addEventListener("input", () =>
            this.updateCapacityDisplay()
          );

          // Button click events now handled via delegation
          this.addPrintBtn.addEventListener("click", () => this.addPrints(1));
          this.add5PrintsBtn.addEventListener("click", () => this.addPrints(5));
          this.resetPrintsBtn.addEventListener("click", () =>
            this.resetPrints()
          );
          this.saveChemicalPresetBtn.addEventListener("click", () =>
            this.saveChemicalPreset()
          );
          this.clearChemicalPresetsBtn.addEventListener("click", () =>
            this.clearChemicalPresets()
          );
          this.addChemicalBtn.addEventListener("click", () =>
            this.addChemical()
          );
          this.clearExpiredBtn.addEventListener("click", () =>
            this.clearExpired()
          );

          // Custom paper size button
          this.useCustomSizeBtn.addEventListener("click", () => {
            const customSize = parseFloat(this.customPaperSizeInput.value);
            if (customSize && customSize > 0) {
              this.setPaperSize(customSize);
              // Show visual feedback
              this.useCustomSizeBtn.textContent = "✓ Used";
              this.useCustomSizeBtn.classList.add("active");
              setTimeout(() => {
                this.useCustomSizeBtn.textContent = "Use";
                this.useCustomSizeBtn.classList.remove("active");
              }, 1000);
            }
          });
        }

        /**
         * Update mix calculator calculations
         * @returns {void}
         * @description Calculates stock and water volumes based on total volume and dilution ratio
         */
        updateMixCalculator() {
          this.totalVolume = parseInt(this.totalVolumeSlider.value);
          this.totalVolumeValue.textContent = `${this.totalVolume}ml`;

          let stockParts, waterParts;

          // Check if a preset button is active
          const activeBtn = document.querySelector(
            ".toggle-btn[data-ratio].active"
          );
          if (activeBtn) {
            const parts = activeBtn.getAttribute("data-ratio").split("+");
            stockParts = parseInt(parts[0]);
            waterParts = parseInt(parts[1]);
          } else {
            // Use custom values
            stockParts = this.customStockParts;
            waterParts = this.customWaterParts;
          }

          const totalParts = stockParts + waterParts;
          const stockVolume = Math.round(
            (this.totalVolume / totalParts) * stockParts
          );
          const waterVolume = Math.round(
            (this.totalVolume / totalParts) * waterParts
          );

          // Adjust for rounding errors
          const adjustedStockVolume = Math.min(stockVolume, this.totalVolume);
          const adjustedWaterVolume = this.totalVolume - adjustedStockVolume;

          this.stockVolumeElement.textContent = `${adjustedStockVolume}ml`;
          this.waterVolumeElement.textContent = `${adjustedWaterVolume}ml`;
        }

        /**
         * Save current chemical mix as a preset
         * @returns {boolean} Success status
         */
        saveChemicalPreset() {
          const name = this.chemicalPresetNameInput.value.trim();

          const result = settingsManager.savePreset({
            name,
            dataObject: {
              totalVolume: this.totalVolume,
              dilutionRatio: this.dilutionRatio,
              customStockParts: this.customStockParts,
              customWaterParts: this.customWaterParts,
            },
            collection: this.chemicalPresets,
            storageMethod: (presets) =>
              StorageManager.saveChemicalPresets(presets),
            updateListMethod: () => this.updateChemicalPresetList(),
            feedbackMethod: (msg, type) =>
              settingsManager.showAllProfilesFeedback(msg, type),
            successMessage: `Preset "${name}" saved!`,
          });

          if (result) {
            this.chemicalPresetNameInput.value = "";
          }
        }

        loadChemicalPreset(preset) {
          this.setCurrentPreset(preset.name);
          this.totalVolumeSlider.value = preset.totalVolume;
          this.totalVolume = preset.totalVolume;

          // Try to find matching dilution button
          const matchingBtn = Array.from(this.dilutionBtns).find(
            (btn) => btn.getAttribute("data-ratio") === preset.dilutionRatio
          );

          if (matchingBtn) {
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            matchingBtn.classList.add("active");
            this.dilutionRatio = preset.dilutionRatio;
          } else {
            // Use custom values
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.customStockParts = preset.customStockParts;
            this.customWaterParts = preset.customWaterParts;
            this.customStockPartsInput.value = preset.customStockParts;
            this.customWaterPartsInput.value = preset.customWaterParts;
          }

          this.updateMixCalculator();
          this.updateChemicalPresetList();
          playBeep(600, 0.3, 0.3);
          settingsManager.showAllProfilesFeedback(
            `Preset "${preset.name}" loaded!`,
            "success"
          );
          return true;
        }

        deleteChemicalPreset(presetName) {
          return settingsManager.deletePreset({
            name: presetName,
            collection: this.chemicalPresets,
            storageMethod: (presets) =>
              StorageManager.saveChemicalPresets(presets),
            updateListMethod: () => this.updateChemicalPresetList(),
            confirmMessage: `Delete preset "${presetName}"?`,
            successMessage: `Preset "${presetName}" deleted!`,
            onDeleteCallback: () => {
              if (this.getCurrentPreset() === presetName) {
                this.setCurrentPreset(null);
              }
            },
          });
        }

        updateChemicalPresetList() {
          settingsManager.renderPresetList({
            listElement: this.chemicalPresetList,
            collection: this.chemicalPresets,
            currentItem: this.getCurrentPreset(),
            renderItemContent: (preset) => {
              const ratio = preset.dilutionRatio
                ? `Ratio: ${preset.dilutionRatio}`
                : `Custom: ${preset.customStockParts}+${preset.customWaterParts}`;

              return `
                        <div>
                            <strong>${preset.name}</strong>
                            <div style="font-size: 0.65rem; color: var(--text-secondary);">${new Date(
                              preset.date
                            ).toLocaleDateString()}</div>
                            <div style="font-size: 0.6rem; color: var(--accent);">${ratio} • ${
                preset.totalVolume
              }ml</div>
                        </div>
                        <div class="shelf-life-actions">
                            <button class="btn-action load-btn" data-context="preset" data-name="${
                              preset.name
                            }">Load</button>
                            <button class="btn-action delete-btn" data-context="preset" data-name="${
                              preset.name
                            }">Delete</button>
                        </div>
                    `;
            },
          });
        }

        clearChemicalPresets() {
          return settingsManager.clearAllPresets({
            collection: this.chemicalPresets,
            storageMethod: (presets) =>
              StorageManager.saveChemicalPresets(presets),
            updateListMethod: () => this.updateChemicalPresetList(),
            feedbackMethod: (msg, type) =>
              settingsManager.showAllProfilesFeedback(msg, type),
            confirmMessage:
              "Delete ALL chemical presets? This cannot be undone!",
            successMessage: "All chemical presets deleted!",
            onClearCallback: () => {
              this.setCurrentPreset(null);
            },
          });
        }

        // UPDATED: Paper area based capacity calculations
        setPaperSize(size) {
          this.currentPaperSize = size;
          this.capacityData.paperSize = size;

          // Update button states
          this.paperSizeBtns.forEach((btn) => {
            btn.classList.remove("active");
            const btnSize = parseFloat(btn.getAttribute("data-size"));
            if (Math.abs(btnSize - size) < 0.001) {
              btn.classList.add("active");
            }
          });

          this.updateCapacityDisplay();
          StorageManager.saveCapacityTracker(this.capacityData);
        }

        updateCapacityDisplay() {
          const capacityPerLiter = parseFloat(this.capacitySlider.value); // m² per liter
          const trayVolume = parseInt(this.trayVolumeSlider.value); // ml
          const trayVolumeLiters = trayVolume / 1000;

          this.capacityValue.textContent = capacityPerLiter.toFixed(1);
          this.trayVolumeValue.textContent = trayVolume;

          // Calculate maximum area and prints
          const maxArea = capacityPerLiter * trayVolumeLiters; // m²
          const areaUsed = this.capacityData.areaUsed || 0;
          const printsDone = this.capacityData.printsDone || 0;

          const maxPrints = Math.floor(maxArea / this.currentPaperSize);
          const remainingArea = Math.max(0, maxArea - areaUsed);
          const remainingPrints = Math.floor(
            remainingArea / this.currentPaperSize
          );

          this.maxPrintsValue.textContent = maxPrints;
          this.printsRemaining.textContent = `${remainingPrints} prints remaining (${remainingArea.toFixed(
            3
          )} m²)`;

          const percentUsed =
            maxArea > 0 ? Math.min(100, (areaUsed / maxArea) * 100) : 0;

          this.printsDoneValue.textContent = printsDone;
          this.areaUsedValue.textContent = `${areaUsed.toFixed(3)} m²`;
          this.percentUsedValue.textContent = `${percentUsed.toFixed(0)}%`;

          // Update progress bar
          this.capacityProgressBar.style.width = `${percentUsed}%`;
          const middlePrints = Math.round(maxPrints / 2);
          this.capacityMiddleLabel.textContent = middlePrints;
          this.capacityMaxLabel.textContent = maxPrints;

          // Update status based on area usage
          if (percentUsed >= 100) {
            this.capacityStatus.textContent = "Exhausted";
            this.capacityStatus.style.color = "#f00";
          } else if (percentUsed >= 85) {
            this.capacityStatus.textContent = "Nearly Used";
            this.capacityStatus.style.color = "#ff5500";
          } else if (percentUsed >= 60) {
            this.capacityStatus.textContent = "Well Used";
            this.capacityStatus.style.color = "#ffaa00";
          } else if (percentUsed >= 30) {
            this.capacityStatus.textContent = "Partially Used";
            this.capacityStatus.style.color = "#ffff00";
          } else {
            this.capacityStatus.textContent = "Fresh";
            this.capacityStatus.style.color = "#0a0";
          }

          // Update theme colors
          if (document.body.classList.contains("light-scheme")) {
            const colors = {
              Exhausted: "#cc0000",
              "Nearly Used": "#ff6600",
              "Well Used": "#ff9900",
              "Partially Used": "#ffcc00",
              Fresh: "#006600",
            };
            this.capacityStatus.style.color =
              colors[this.capacityStatus.textContent] || "#006600";
          } else if (document.body.classList.contains("day-scheme")) {
            const colors = {
              Exhausted: "#ff3333",
              "Nearly Used": "#ff9900",
              "Well Used": "#ffcc00",
              "Partially Used": "#ffff33",
              Fresh: "#33cc33",
            };
            this.capacityStatus.style.color =
              colors[this.capacityStatus.textContent] || "#33cc33";
          }
        }

        addPrints(count) {
          const areaToAdd = count * this.currentPaperSize;
          this.capacityData.printsDone =
            (this.capacityData.printsDone || 0) + count;
          this.capacityData.areaUsed =
            (this.capacityData.areaUsed || 0) + areaToAdd;
          StorageManager.saveCapacityTracker(this.capacityData);
          this.updateCapacityDisplay();
          playBeep(600, 0.2, 0.3);
        }

        resetPrints() {
          if (confirm("Reset print counter? This will start a fresh batch.")) {
            this.capacityData = {
              printsDone: 0,
              areaUsed: 0,
              paperSize: this.currentPaperSize,
              lastReset: new Date().toISOString(),
            };
            StorageManager.saveCapacityTracker(this.capacityData);
            this.updateCapacityDisplay();
            playBeep(800, 0.5, 0.3);
          }
        }

        // UPDATED: Add chemical with custom name support
        addChemical() {
          const type = this.chemicalTypeSelect.value;
          const shelfLifeDays = parseInt(this.shelfLifeDaysInput.value);
          const date = this.chemicalDateInput.value;

          if (!date) {
            alert("Please select a date");
            return;
          }

          let chemicalName;
          if (type === "custom") {
            chemicalName = this.customChemicalNameInput.value.trim();
            if (!chemicalName) {
              alert("Please enter a custom chemical name");
              return;
            }
          } else {
            chemicalName = this.getChemicalName(type);
          }

          const chemical = {
            id: Date.now(),
            type: type,
            name: chemicalName,
            dateMixed: date,
            shelfLifeDays: shelfLifeDays,
            dateAdded: new Date().toISOString(),
          };

          this.shelfLifeData.push(chemical);
          StorageManager.saveShelfLife(this.shelfLifeData);
          this.updateShelfLifeList();

          // Reset form
          this.chemicalDateInput.value = new Date().toISOString().split("T")[0];
          this.customChemicalNameInput.value = "";

          playBeep(800, 0.3, 0.3);
        }

        getChemicalName(type) {
          const names = {
            developer: "Developer",
            stopbath: "Stop Bath",
            fixer: "Fixer",
            hypoclear: "Hypo Clear",
            photof: "Photo Wash",
            custom: "Custom Chemical",
          };
          return names[type] || type;
        }

        loadShelfLifeData(data) {
          if (!data || !Array.isArray(data)) return;

          // Clear existing data
          this.shelfLifeData = [];

          // Load new data with validation
          data.forEach((chemical) => {
            if (
              chemical &&
              chemical.name &&
              chemical.dateMixed &&
              chemical.shelfLifeDays
            ) {
              this.shelfLifeData.push({
                id: chemical.id || Date.now() + Math.random(),
                type: chemical.type || "custom",
                name: chemical.name,
                dateMixed: chemical.dateMixed,
                shelfLifeDays: chemical.shelfLifeDays,
                dateAdded: chemical.dateAdded || new Date().toISOString(),
              });
            }
          });

          // Save to storage
          StorageManager.saveShelfLife(this.shelfLifeData);
          this.updateShelfLifeList();
        }

        updateShelfLifeList() {
          this.shelfLifeList.innerHTML = "";

          const today = new Date();
          this.shelfLifeData.forEach((chemical, index) => {
            const mixedDate = new Date(chemical.dateMixed);
            const expiryDate = new Date(mixedDate);
            expiryDate.setDate(expiryDate.getDate() + chemical.shelfLifeDays);

            const daysLeft = Math.ceil(
              (expiryDate - today) / (1000 * 60 * 60 * 24)
            );

            const item = document.createElement("div");
            item.className = "shelf-life-item";

            if (daysLeft < 0) {
              item.classList.add("expired");
            } else if (daysLeft <= 3) {
              item.classList.add("expiring");
            }

            let statusClass = "";
            let statusText = "";
            if (daysLeft < 0) {
              statusClass = "expired";
              statusText = "EXPIRED";
            } else if (daysLeft <= 3) {
              statusClass = "expiring";
              statusText = "EXPIRING";
            } else {
              statusText = `${daysLeft} days`;
            }

            item.innerHTML = `
                        <div>
                            <strong>${chemical.name}</strong>
                            <div style="font-size: 0.6rem; color: var(--accent);">
                                Mixed: ${new Date(
                                  chemical.dateMixed
                                ).toLocaleDateString()}
                            </div>
                            <div style="font-size: 0.6rem; color: var(--accent);">
                                Expires: ${expiryDate.toLocaleDateString()}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div class="shelf-life-days ${statusClass}">${statusText}</div>
                            <div class="shelf-life-actions">
                                <button class="btn-action renew-btn" data-context="chemical" data-id="${
                                  chemical.id
                                }">Renew</button>
                                <button class="btn-action delete-btn" data-context="chemical" data-id="${
                                  chemical.id
                                }">Delete</button>
                            </div>
                        </div>
                    `;

            this.shelfLifeList.appendChild(item);
          });

          // Event handlers now via delegation - no individual listeners needed
        }

        renewChemical(id) {
          if (
            confirm(
              "Renew this chemical? This will reset its shelf life from today."
            )
          ) {
            const index = this.shelfLifeData.findIndex((c) => c.id === id);
            if (index !== -1) {
              this.shelfLifeData[index].dateMixed = new Date()
                .toISOString()
                .split("T")[0];
              StorageManager.saveShelfLife(this.shelfLifeData);
              this.updateShelfLifeList();
              playBeep(600, 0.3, 0.3);
            }
          }
        }

        deleteChemical(id) {
          if (confirm("Delete this chemical from tracking?")) {
            this.shelfLifeData = this.shelfLifeData.filter((c) => c.id !== id);
            StorageManager.saveShelfLife(this.shelfLifeData);
            this.updateShelfLifeList();
            playBeep(400, 0.3, 0.3);
          }
        }

        clearExpired() {
          if (confirm("Remove all expired chemicals?")) {
            const today = new Date();
            this.shelfLifeData = this.shelfLifeData.filter((chemical) => {
              const mixedDate = new Date(chemical.dateMixed);
              const expiryDate = new Date(mixedDate);
              expiryDate.setDate(expiryDate.getDate() + chemical.shelfLifeDays);
              const daysLeft = Math.ceil(
                (expiryDate - today) / (1000 * 60 * 60 * 24)
              );
              return daysLeft > 0;
            });

            StorageManager.saveShelfLife(this.shelfLifeData);
            this.updateShelfLifeList();
            playBeep(800, 0.5, 0.3);
          }
        }

        updateDisplay() {
          this.updateMixCalculator();
          this.updateCapacityDisplay();
          this.updateChemicalPresetList();
          this.updateShelfLifeList();
        }
      }

      /**
       * @class RelayManager
       * @classdesc Central hub for managing relay control and server communication.
       * Handles all HTTP requests to Flask server, manages relay state tracking,
       * implements auto-trigger functionality for timer integration, and provides
       * safelight auto-off feature to prevent fogging during exposures.
       *
       * @property {string} serverIP - The IP address of the Raspberry Pi server (default: "192.168.1.100")
       * @property {number} serverPort - The port number of the Flask server (default: 5000)
       * @property {boolean} autoTrigger - Whether to automatically trigger the enlarger relay when timers start
       * @property {boolean} safelightAutoOff - Whether to automatically turn off safelight when enlarger activates
       * @property {boolean} safelightWasOn - Tracks if safelight was on before enlarger started (for restoration)
       * @property {Object} relayStates - Current state of all 4 relays (1-4)
       * @property {HTMLElement} relayServerIP - Input element for server IP
       * @property {HTMLElement} relayServerPort - Input element for server port
       * @property {HTMLElement} testRelayConnectionBtn - Button to test server connection
       * @property {HTMLElement} relayStatus - Status display element
       * @property {HTMLElement} autoTriggerRelay - Checkbox for auto-trigger setting
       * @property {HTMLElement} testTimerRelayBtn - Button to test timer relay
       * @property {HTMLElement} testTimerSeconds - Input for test timer duration
       * @property {HTMLElement} allRelaysOnBtn - Button to turn all relays on
       * @property {HTMLElement} allRelaysOffBtn - Button to turn all relays off
       *
       * @description
       * Relay Mapping:
       * - Relay 1 → GPIO 25 (Enlarger Timer) - Primary exposure control
       * - Relay 2 → GPIO 17 (Safelight) - Auto-controlled during exposure
       * - Relay 3 → GPIO 27 (Ventilation)
       * - Relay 4 → GPIO 22 (White Light)
       *
       * Safelight Auto-Off Flow:
       * 1. User starts exposure (CALC, TEST, or TIMER with auto-trigger)
       * 2. If safelight is on, remember state and turn it OFF
       * 3. Server starts GPIO 25 timer for specified duration
       * 4. After duration, safelight is automatically restored
       *
       * Triple-Fallback Fetch Strategy:
       * 1. CORS mode (Chrome/Safari) - preferred
       * 2. no-cors mode - fallback for restricted environments
       * 3. Image object - final fallback for GET requests
       *
       * @example
       * // Initialize relay manager
       * const relayManager = new RelayManager();
       *
       * // Trigger exposure with safelight handling
       * await relayManager.triggerTimerRelay(10.5);
       *
       * // Manual relay control
       * await relayManager.setRelay(1, true); // Turn on enlarger
       * await relayManager.setRelay(2, false); // Turn off safelight
       */
      class RelayManager {
        /**
         * @constructor
         * @description Creates a RelayManager instance with default settings and initializes the relay state tracking.
         * Loads saved settings from localStorage and sets up the initial UI state.
         */
        constructor() {
          this.serverIP = "192.168.1.100";
          this.serverPort = 5000;
          this.autoTrigger = true;
          this.safelightAutoOff = true; // NEW: Default to enabled
          this.safelightWasOn = false; // NEW: Track if safelight was on before enlarger

          this.relayStates = {
            1: false, // GPIO 25 - Enlarger Timer
            2: false, // GPIO 17 - Safelight
            3: false, // GPIO 27 - Ventilation
            4: false, // GPIO 22 - White Light
          };

          this.init();
        }

        /**
         * @method init
         * @description Initializes the RelayManager by loading saved settings, binding UI elements,
         * and setting up event listeners. Also synchronizes with SettingsManager for safelight auto-off
         * and updates the UI display.
         * @returns {void}
         */
        init() {
          // Load saved settings
          this.loadSettings();

          // Get elements
          this.relayServerIP = document.getElementById("relayServerIP");
          this.relayServerPort = document.getElementById("relayServerPort");
          this.testRelayConnectionBtn = document.getElementById(
            "testRelayConnection"
          );
          this.relayStatus = document.getElementById("relayStatus");
          this.autoTriggerRelay = document.getElementById("autoTriggerRelay");
          this.testTimerRelayBtn = document.getElementById("testTimerRelay");
          this.testTimerSeconds = document.getElementById("testTimerSeconds");
          this.allRelaysOnBtn = document.getElementById("allRelaysOn");
          this.allRelaysOffBtn = document.getElementById("allRelaysOff");

          // Set initial values
          if (this.relayServerIP) this.relayServerIP.value = this.serverIP;
          if (this.relayServerPort)
            this.relayServerPort.value = this.serverPort;
          if (this.autoTriggerRelay)
            this.autoTriggerRelay.checked = this.autoTrigger;

          // Add event listeners
          // In the init() method, add:
          const shutdownBtn = document.getElementById("shutdownPi");
          if (shutdownBtn) {
            shutdownBtn.addEventListener("click", () => this.shutdownPi());
          }
          const rebootBtn = document.getElementById("rebootPi");
          if (rebootBtn) {
            rebootBtn.addEventListener("click", () => this.rebootPi());
          }

          if (this.relayServerIP)
            this.relayServerIP.addEventListener("change", () =>
              this.saveSettings()
            );
          if (this.relayServerPort)
            this.relayServerPort.addEventListener("change", () =>
              this.saveSettings()
            );
          if (this.autoTriggerRelay)
            this.autoTriggerRelay.addEventListener("change", () =>
              this.saveSettings()
            );
          if (this.testRelayConnectionBtn)
            this.testRelayConnectionBtn.addEventListener("click", () =>
              this.testConnection()
            );
          if (this.testTimerRelayBtn)
            this.testTimerRelayBtn.addEventListener("click", () =>
              this.testTimerRelay()
            );
          if (this.allRelaysOnBtn)
            this.allRelaysOnBtn.addEventListener("click", () =>
              this.allRelaysOn()
            );
          if (this.allRelaysOffBtn)
            this.allRelaysOffBtn.addEventListener("click", () =>
              this.allRelaysOff()
            );

          // Relay toggle buttons now use delegation - no init needed

          // Update UI
          this.updateRelayButtons();
          // Load safelight auto-off setting from settingsManager
          if (settingsManager) {
            this.safelightAutoOff =
              settingsManager.settings.safelightAutoOff !== false;
          }
          // Update safelight auto-off status display
          this.updateSafelightAutoOffStatus();

          // Add event listener for the toggle in settings
          document
            .getElementById("safelightAutoOff")
            ?.addEventListener("change", () => {
              this.safelightAutoOff =
                document.getElementById("safelightAutoOff").checked;
              this.saveSettings();
              this.updateSafelightAutoOffStatus();
            });
        }

        /**
         * @method shutdownPi
         * @description Initiates a graceful shutdown of the Raspberry Pi.
         * Sends a shutdown command to the server with user confirmation.
         * Provides visual feedback during the shutdown process.
         * @returns {Promise<void>} Resolves when shutdown command is sent (or fails)
         * @throws {Error} If shutdown command fails to send
         * @fires updateStatus - Updates UI with shutdown progress
         * @fires playBeep - Audio feedback on success
         * @example
         * await relayManager.shutdownPi(); // User will see confirmation dialog
         */
        async shutdownPi() {
          if (
            !confirm(
              "Are you sure you want to shutdown the Raspberry Pi?\n\nThe server will stop and the Pi will power off."
            )
          ) {
            return;
          }

          try {
            const response = await this.sendRequest("shutdown");

            if (response) {
              this.updateStatus(
                "Shutdown command sent. Raspberry Pi will power off in 3 seconds...",
                "success"
              );

              // Visual feedback
              const btn = document.getElementById("shutdownPi");
              if (btn) {
                const originalText = btn.textContent;
                btn.textContent = "Shutting down...";
                btn.disabled = true;

                // Update status message after a delay
                setTimeout(() => {
                  this.updateStatus(
                    "Raspberry Pi is shutting down. Server connection will be lost.",
                    "info"
                  );
                }, 2000);

                setTimeout(() => {
                  btn.textContent = originalText;
                  btn.disabled = false;
                }, 5000);
              }
            }
          } catch (error) {
            this.updateStatus("Failed to send shutdown command", "error");
            console.error("Shutdown error:", error);
          }
        }

        /**
         * @method rebootPi
         * @description Initiates a reboot of the Raspberry Pi.
         * Sends a reboot command to the server with user confirmation.
         * Provides visual feedback during the reboot process.
         * @returns {Promise<void>} Resolves when reboot command is sent (or fails)
         * @throws {Error} If reboot command fails to send
         * @fires updateStatus - Updates UI with reboot progress
         * @fires playBeep - Audio feedback on success
         * @example
         * await relayManager.rebootPi(); // User will see confirmation dialog
         */
        async rebootPi() {
          if (
            !confirm(
              "Are you sure you want to reboot the Raspberry Pi?\n\nThe server will stop and the Pi will power off."
            )
          ) {
            return;
          }

          try {
            const response = await this.sendRequest("reboot");

            if (response) {
              this.updateStatus(
                "Reboot command sent. Raspberry Pi will reboot in 3 seconds...",
                "success"
              );

              // Visual feedback
              const btn = document.getElementById("rebootPi");
              if (btn) {
                const originalText = btn.textContent;
                btn.textContent = "Reboot...";
                btn.disabled = true;

                // Update status message after a delay
                setTimeout(() => {
                  this.updateStatus(
                    "Raspberry Pi is rebooting. Server connection will be lost.",
                    "info"
                  );
                }, 2000);

                setTimeout(() => {
                  btn.textContent = originalText;
                  btn.disabled = false;
                }, 5000);
              }
            }
          } catch (error) {
            this.updateStatus("Failed to send reboot command", "error");
            console.error("Shutdown error:", error);
          }
        }

        /**
         * @method updateSafelightAutoOffStatus
         * @description Updates the visual display of safelight auto-off status in the UI.
         * Changes text content and color based on current setting and active theme.
         * @returns {void}
         * @fires document.getElementById - Updates "safelightAutoOffStatus" element
         * @theme-aware - Adapts colors for dark, light, and day schemes
         * @example
         * relayManager.updateSafelightAutoOffStatus(); // Updates UI display
         */
        updateSafelightAutoOffStatus() {
          const statusElement = document.getElementById(
            "safelightAutoOffStatus"
          );
          if (!statusElement) return;

          if (this.safelightAutoOff) {
            statusElement.textContent = "ENABLED";
            statusElement.style.color = "#f00";

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              statusElement.style.color = "#0066cc";
            } else if (document.body.classList.contains("day-scheme")) {
              statusElement.style.color = "#ffcc00";
            }
          } else {
            statusElement.textContent = "DISABLED";
            statusElement.style.color = "#900";

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              statusElement.style.color = "#666";
            } else if (document.body.classList.contains("day-scheme")) {
              statusElement.style.color = "#ccc";
            }
          }
        }

        // initRelayToggleButtons removed - now using event delegation

        /**
         * @method saveSettings
         * @description Saves current relay manager settings to localStorage.
         * Reads values from UI elements and persists server configuration,
         * auto-trigger preference, and safelight auto-off setting.
         * @returns {void}
         * @fires localStorage.setItem - Saves "relaySettings" key
         * @throws {Error} Logs error if localStorage save fails
         * @example
         * relayManager.saveSettings(); // Persists current configuration
         */
        saveSettings() {
          this.serverIP = this.relayServerIP
            ? this.relayServerIP.value
            : "192.168.1.100";
          this.serverPort = this.relayServerPort
            ? parseInt(this.relayServerPort.value)
            : 5000;
          this.autoTrigger = this.autoTriggerRelay
            ? this.autoTriggerRelay.checked
            : true;

          // NEW: Get safelight auto-off setting
          this.safelightAutoOff = document.getElementById("safelightAutoOff")
            ? document.getElementById("safelightAutoOff").checked
            : true;

          try {
            localStorage.setItem(
              "relaySettings",
              JSON.stringify({
                serverIP: this.serverIP,
                serverPort: this.serverPort,
                autoTrigger: this.autoTrigger,
                safelightAutoOff: this.safelightAutoOff, // NEW
              })
            );
          } catch (e) {
            console.error("Failed to save relay settings:", e);
          }
        }

        /**
         * @method loadSettings
         * @description Loads relay manager settings from localStorage.
         * Restores server configuration, auto-trigger preference, safelight auto-off setting,
         * and relay states. Uses default values if no saved settings exist.
         * @returns {void}
         * @fires localStorage.getItem - Retrieves "relaySettings" and "relayStates" keys
         * @throws {Error} Logs error if localStorage load or parse fails
         * @example
         * relayManager.loadSettings(); // Restores saved configuration
         */
        loadSettings() {
          try {
            const saved = localStorage.getItem("relaySettings");
            if (saved) {
              const settings = JSON.parse(saved);
              this.serverIP = settings.serverIP || "192.168.1.100";
              this.serverPort = settings.serverPort || 5000;
              this.autoTrigger = settings.autoTrigger !== false;
              this.safelightAutoOff = settings.safelightAutoOff !== false; // NEW: Default to true

              // Load relay states
              const savedStates = localStorage.getItem("relayStates");
              if (savedStates) {
                this.relayStates = JSON.parse(savedStates);
              }
            }
          } catch (e) {
            console.error("Failed to load relay settings:", e);
          }
        }

        /**
         * @method sendRequest
         * @description Sends an HTTP GET request to the Flask server with triple-fallback strategy.
         * Tries CORS mode first, then no-cors mode, then Image object for maximum compatibility.
         * @param {string} endpoint - The server endpoint to request (e.g., "ping", "relay", "timer")
         * @param {Object} [params={}] - Query parameters to include in the request
         * @returns {Promise<boolean>} Resolves to true if request succeeds, false otherwise
         * @throws {Error} May throw if CORS request fails with non-200 status
         * @description Triple-Fallback Strategy:
         * 1. CORS mode (Chrome/Safari) - preferred, allows reading response
         * 2. no-cors mode - fallback for restricted environments, can't read response
         * 3. Image object - final fallback for GET requests, no CORS requirements
         * @example
         * // Test connection
         * const success = await relayManager.sendRequest("ping");
         *
         * // Control relay
         * await relayManager.sendRequest("relay", { gpio: 25, state: "on" });
         *
         * // Start timer
         * await relayManager.sendRequest("timer", { gpio: 25, duration: 10.5 });
         */
        async sendRequest(endpoint, params = {}) {
          const url = `http://${this.serverIP}:${this.serverPort}/${endpoint}`;
          const queryString = Object.keys(params)
            .map(
              (key) =>
                `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`
            )
            .join("&");

          const fullUrl = queryString ? `${url}?${queryString}` : url;

          try {
            // Try with CORS first (for Chrome/Safari)
            const response = await fetch(fullUrl, {
              method: "GET",
              mode: "cors",
              cache: "no-cache",
              headers: {
                Accept: "application/json",
              },
            });

            if (response.ok) {
              return true;
            } else {
              throw new Error(`HTTP ${response.status}`);
            }
          } catch (error) {
            console.warn(
              "CORS fetch failed, trying alternative methods:",
              error
            );

            // Fallback 1: Try with no-cors mode
            try {
              await fetch(fullUrl, {
                method: "GET",
                mode: "no-cors",
                cache: "no-cache",
              });
              return true; // Assume success (we can't read response in no-cors mode)
            } catch (noCorsError) {
              console.warn("No-cors fetch failed:", noCorsError);

              // Fallback 2: Use Image object (works for GET requests, no CORS)
              return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);

                // Add cache-busting parameter
                const cacheBuster = `&_=${Date.now()}`;
                img.src =
                  fullUrl +
                  (fullUrl.includes("?") ? cacheBuster : "?" + cacheBuster);

                // Timeout after 3 seconds
                setTimeout(() => resolve(false), 3000);
              });
            }
          }
        }
        /**
         * @method handleSafelightAutoOff
         * @description Implements the safelight auto-off feature to prevent fogging during exposures.
         * Automatically turns off safelight when enlarger activates and restores it after exposure.
         * This is the core method that implements the critical safelight protection flow.
         * @param {number} relayNum - The relay number being controlled (1-4)
         * @param {boolean} newState - The intended new state of the relay (true=ON, false=OFF)
         * @returns {Promise<void>} Resolves when safelight control operations complete
         * @description Safelight Auto-Off Flow:
         * 1. If enlarger (relay 1) is turning ON:
         *    - Check if safelight (relay 2) is currently ON
         *    - If yes, remember state and turn safelight OFF
         * 2. If enlarger (relay 1) is turning OFF:
         *    - Check if safelight was previously turned off by this system
         *    - If yes, immediately restore safelight to previous state
         * @fires setRelay - Controls safelight relay (2) when needed
         * @fires setTimeout - Restores safelight immediately
         * @example
         * // Called automatically by setRelay and toggleRelay methods
         * await relayManager.handleSafelightAutoOff(1, true); // Enlarger turning on
         */
        async handleSafelightAutoOff(relayNum, newState) {
          // If safelight auto-off is disabled, do nothing
          if (!this.safelightAutoOff) return;

          // If enlarger (relay 1) is being turned ON
          if (relayNum === 1 && newState === true) {
            // Check if safelight (relay 2) is currently on
            if (this.relayStates[2]) {
              // Remember that safelight was on
              this.safelightWasOn = true;
              console.log(
                "Safelight was on, turning it off because enlarger is on"
              );

              // Turn off safelight
              await this.setRelay(2, false);
            } else {
              this.safelightWasOn = false;
            }
          }
          // If enlarger (relay 1) is being turned OFF
          else if (relayNum === 1 && newState === false) {
            // Check if we previously turned off the safelight
            if (this.safelightWasOn) {
              console.log("Enlarger turned off, restoring safelight");

              // Restore safelight immediately
              setTimeout(async () => {
                // Only restore if user hasn't manually turned it back on
                if (!this.relayStates[2]) {
                  await this.setRelay(2, true);
                }
                this.safelightWasOn = false;
              }, 0); // Immediate restoration
            }
          }
        }

        /**
         * @method toggleRelay
         * @description Toggles a specific relay between ON and OFF states.
         * Handles safelight auto-off logic before toggling, sends request to server,
         * updates local state, and provides audio/visual feedback.
         * @param {number} relayNum - The relay number to toggle (1-4)
         * @returns {Promise<void>} Resolves when toggle operation completes
         * @throws {Error} Logs error if server request fails
         * @fires handleSafelightAutoOff - Processes safelight protection before toggle
         * @fires sendRequest - Sends relay control command to server
         * @fires localStorage.setItem - Updates relay state persistence
         * @fires updateRelayButtons - Updates UI button states
         * @fires updateStatus - Updates status display
         * @fires playBeep - Audio feedback (800Hz for ON, 400Hz for OFF)
         * @example
         * // Toggle enlarger relay (relay 1)
         * await relayManager.toggleRelay(1);
         *
         * // Toggle safelight relay (relay 2)
         * await relayManager.toggleRelay(2);
         */
        async toggleRelay(relayNum) {
          const newState = !this.relayStates[relayNum];
          const gpioPin = this.getGPIOPin(relayNum);

          // Handle safelight auto-off logic BEFORE toggling
          await this.handleSafelightAutoOff(relayNum, newState);

          const success = await this.sendRequest("relay", {
            gpio: gpioPin,
            state: newState ? "on" : "off",
          });

          if (success) {
            this.relayStates[relayNum] = newState;
            localStorage.setItem(
              "relayStates",
              JSON.stringify(this.relayStates)
            );
            this.updateRelayButtons();
            this.updateStatus(
              `Relay ${relayNum} ${newState ? "ON" : "OFF"}`,
              "success"
            );
            playBeep(newState ? 800 : 400, 0.1, 0.3);
          }
        }

        /**
         * @method setRelay
         * @description Sets a specific relay to a specific state (ON/OFF).
         * Handles safelight auto-off logic, sends request to server, and updates local state.
         * Unlike toggleRelay, this method sets an explicit state rather than toggling.
         * @param {number} relayNum - The relay number to control (1-4)
         * @param {boolean} state - The desired state (true=ON, false=OFF)
         * @returns {Promise<void>} Resolves when set operation completes
         * @throws {Error} Logs error if server request fails
         * @fires handleSafelightAutoOff - Processes safelight protection before setting
         * @fires sendRequest - Sends relay control command to server
         * @fires localStorage.setItem - Updates relay state persistence
         * @fires updateRelayButtons - Updates UI button states
         * @example
         * // Turn on enlarger
         * await relayManager.setRelay(1, true);
         *
         * // Turn off safelight
         * await relayManager.setRelay(2, false);
         *
         * // Turn on ventilation
         * await relayManager.setRelay(3, true);
         */
        async setRelay(relayNum, state) {
          const gpioPin = this.getGPIOPin(relayNum);
          const stateStr = state ? "on" : "off";

          // Handle safelight auto-off logic
          await this.handleSafelightAutoOff(relayNum, state);

          const success = await this.sendRequest("relay", {
            gpio: gpioPin,
            state: stateStr,
          });

          if (success) {
            this.relayStates[relayNum] = state;
            localStorage.setItem(
              "relayStates",
              JSON.stringify(this.relayStates)
            );
            this.updateRelayButtons();
          }
        }

        /**
         * @method getGPIOPin
         * @description Maps relay numbers to their corresponding GPIO pin numbers.
         * Provides the hardware pin mapping for relay control.
         * @param {number} relayNum - The relay number (1-4)
         * @returns {number} The GPIO pin number for the specified relay
         * @constant {Object} pinMap - Static mapping of relay to GPIO pins
         * @example
         * const pin = relayManager.getGPIOPin(1); // Returns 25 (Enlarger)
         * const pin = relayManager.getGPIOPin(2); // Returns 17 (Safelight)
         */
        getGPIOPin(relayNum) {
          const pinMap = {
            1: 25, // Enlarger Timer
            2: 17, // Safelight
            3: 27, // Ventilation
            4: 22, // White Light
          };
          return pinMap[relayNum] || 14;
        }

        /**
         * @method triggerTimerRelay
         * @description Triggers the enlarger relay with a timed duration.
         * This is the primary method used by CALC, TEST, and TIMER tabs for exposures.
         * Implements the complete safelight auto-off flow with immediate restoration.
         * @param {number} durationSeconds - The exposure duration in seconds
         * @returns {Promise<void>} Resolves when timer trigger completes
         * @throws {Error} Logs error if timer request fails
         * @fires console.log - Logs safelight state changes for debugging
         * @fires sendRequest - Sends timer command to server (gpio=25, duration=durationSeconds)
         * @fires updateStatus - Updates UI with timer status
         * @fires setTimeout - Schedules safelight restoration after exposure
         * @fires setRelay - Controls safelight (relay 2) before and after exposure
         * @description Critical Safelight Flow:
         * 1. Check if auto-trigger is enabled (required for this method)
         * 2. If safelight auto-off is enabled and safelight is on:
         *    - Remember safelight was on
         *    - Turn off safelight (relay 2)
         * 3. Send timer request to server (gpio=25, duration=durationSeconds)
         * 4. After duration:
         *    - Restore safelight if it was on
         *    - Reset safelightWasOn flag
         * @example
         * // From CALC tab with 10.5 second exposure
         * await relayManager.triggerTimerRelay(10.5);
         *
         * // From TEST tab with 2.5 second step
         * await relayManager.triggerTimerRelay(2.5);
         *
         * // From TIMER tab (Dev timer)
         * await relayManager.triggerTimerRelay(60.0);
         */
        async triggerTimerRelay(durationSeconds) {
          if (!this.autoTrigger) {
            console.log("Auto-trigger disabled");
            return;
          }

          // NEW: Handle safelight auto-off when timer starts
          if (this.safelightAutoOff && this.relayStates[2]) {
            console.log("Timer starting - turning off safelight");
            this.safelightWasOn = true;
            await this.setRelay(2, false);
          }

          // Send single request with duration parameter
          const success = await this.sendRequest("timer", {
            gpio: 25,
            duration: durationSeconds.toFixed(3),
          });

          if (success) {
            this.updateStatus(
              `Timer relay triggered for ${durationSeconds}s`,
              "success"
            );

            // NEW: Restore safelight after timer completes
            if (this.safelightAutoOff && this.safelightWasOn) {
              setTimeout(async () => {
                console.log("Timer completed - restoring safelight");
                if (!this.relayStates[2]) {
                  await this.setRelay(2, true);
                }
                this.safelightWasOn = false;
              }, durationSeconds * 1000); // Immediate restoration
            }
          } else {
            this.updateStatus("Timer relay failed", "error");
          }
        }

        /**
         * @method testConnection
         * @description Tests the connection to the Flask server.
         * Sends a ping request to verify server is reachable and responsive.
         * Provides audio and visual feedback based on connection result.
         * @returns {Promise<void>} Resolves when connection test completes
         * @fires updateStatus - Updates UI with connection status
         * @fires sendRequest - Sends "ping" request to server
         * @fires playBeep - Audio feedback (600Hz for success)
         * @example
         * // Test connection before starting exposure
         * await relayManager.testConnection();
         */
        async testConnection() {
          this.updateStatus("Testing connection...", "info");

          // Try to ping the server
          const success = await this.sendRequest("ping");

          if (success) {
            this.updateStatus("Connected successfully!", "success");
            playBeep(600, 0.3, 0.3);
          } else {
            this.updateStatus("Connection failed", "error");
          }
        }

        /**
         * @method testTimerRelay
         * @description Tests the timer relay functionality with a user-specified duration.
         * Reads duration from UI input and triggers the enlarger with safelight handling.
         * Useful for testing exposure timing and safelight auto-off feature.
         * @returns {Promise<void>} Resolves when test timer completes
         * @fires parseFloat - Reads duration from testTimerSeconds input element
         * @fires triggerTimerRelay - Starts exposure with specified duration
         * @example
         * // User clicks "Test Timer Relay" button
         * // Reads value from testTimerSeconds input (default: 5 seconds)
         * await relayManager.testTimerRelay();
         */
        async testTimerRelay() {
          const seconds = parseFloat(
            this.testTimerSeconds ? this.testTimerSeconds.value : 5
          );
          if (seconds > 0) {
            await this.triggerTimerRelay(seconds);
          }
        }

        /**
         * @method allRelaysOn
         * @description Turns ON all relays simultaneously.
         * Respects safelight auto-off setting: if enabled and enlarger is on,
         * safelight will not be turned on to prevent fogging.
         * @returns {Promise<void>} Resolves when all relays are turned on
         * @fires setRelay - Controls each relay individually
         * @fires updateStatus - Updates UI with success message
         * @fires playBeep - Audio feedback (800Hz, 0.5s duration)
         * @example
         * // Turn on all relays (respecting safelight auto-off)
         * await relayManager.allRelaysOn();
         */
        async allRelaysOn() {
          // If safelight auto-off is enabled and we're turning on enlarger,
          // we should handle safelight appropriately
          if (this.safelightAutoOff) {
            // Turn on all relays except safelight if enlarger is being turned on
            for (let i = 1; i <= 4; i++) {
              if (i === 2 && this.relayStates[1]) {
                // Skip turning on safelight if enlarger is already on or about to be on
                continue;
              }
              await this.setRelay(i, true);
            }
          } else {
            // Original behavior
            for (let i = 1; i <= 4; i++) {
              await this.setRelay(i, true);
            }
          }

          this.updateStatus("All relays ON", "success");
          playBeep(800, 0.5, 0.3);
        }

        /**
         * @method allRelaysOff
         * @description Turns OFF all relays simultaneously.
         * Resets the safelightWasOn flag to prevent unexpected safelight restoration.
         * @returns {Promise<void>} Resolves when all relays are turned off
         * @fires setRelay - Controls each relay individually
         * @fires updateStatus - Updates UI with success message
         * @fires playBeep - Audio feedback (400Hz, 0.5s duration)
         * @example
         * // Turn off all relays
         * await relayManager.allRelaysOff();
         */
        async allRelaysOff() {
          for (let i = 1; i <= 4; i++) {
            await this.setRelay(i, false);
          }
          this.safelightWasOn = false; // Reset the flag
          this.updateStatus("All relays OFF", "success");
          playBeep(400, 0.5, 0.3);
        }

        /**
         * @method updateRelayButtons
         * @description Updates all relay control buttons in the UI to reflect current states.
         * Changes button text (ON/OFF) and CSS classes based on relayStates.
         * @returns {void}
         * @fires document.querySelectorAll - Finds all relay control buttons
         * @fires Element.textContent - Updates button text
         * @fires Element.classList.toggle - Updates CSS classes
         * @example
         * // Called after any relay state change
         * relayManager.updateRelayButtons();
         */
        updateRelayButtons() {
          document
            .querySelectorAll(".settings-btn[data-relay]")
            .forEach((btn) => {
              const relayNum = parseInt(btn.getAttribute("data-relay"));
              const state = this.relayStates[relayNum];

              btn.textContent = state ? "ON" : "OFF";
              btn.classList.toggle("on", state);
            });
        }

        /**
         * @method updateStatus
         * @description Updates the relay status display element with a message and color.
         * Theme-aware: adapts colors for dark, light, and day schemes.
         * @param {string} message - The status message to display
         * @param {string} [type="info"] - Message type: "success", "error", or "info"
         * @returns {void}
         * @fires Element.textContent - Updates status text
         * @fires Element.style.color - Updates text color based on type and theme
         * @theme-aware - Uses different colors for each theme scheme
         * @example
         * // Success message
         * relayManager.updateStatus("Connected successfully!", "success");
         *
         * // Error message
         * relayManager.updateStatus("Connection failed", "error");
         *
         * // Info message
         * relayManager.updateStatus("Testing connection...", "info");
         */
        updateStatus(message, type = "info") {
          if (!this.relayStatus) return;

          this.relayStatus.textContent = message;

          // Set color based on type and theme
          if (document.body.classList.contains("light-scheme")) {
            this.relayStatus.style.color =
              type === "success"
                ? "#006600"
                : type === "error"
                ? "#cc0000"
                : "#666";
          } else if (document.body.classList.contains("day-scheme")) {
            this.relayStatus.style.color =
              type === "success"
                ? "#33cc33"
                : type === "error"
                ? "#ff3333"
                : "#ccc";
          } else {
            const colors = {
              success: "#0a0",
              error: "#f00",
              info: "#900",
            };
            this.relayStatus.style.color = colors[type] || "#900";
          }
        }
      }

      // Load settings to UI - UPDATED with countdown settings AND auto advance
      function loadSettingsToUI() {
        if (!settingsManager) return;

        document.getElementById("settingBaseTime").value =
          settingsManager.settings.baseTime;
        document.getElementById("settingDevTime").value =
          settingsManager.settings.devTime;
        document.getElementById("settingStopTime").value =
          settingsManager.settings.stopTime;
        document.getElementById("settingFixTime").value =
          settingsManager.settings.fixTime;
        document.getElementById("settingFloTime").value =
          settingsManager.settings.floTime;
        document.getElementById("settingCalcWarningBeep").checked =
          settingsManager.settings.calcWarningBeep;
        document.getElementById("settingCalcEndBeep").checked =
          settingsManager.settings.calcEndBeep;
        document.getElementById("settingTimerWarningBeep").checked =
          settingsManager.settings.timerWarningBeep;
        document.getElementById("settingTimerEndBeep").checked =
          settingsManager.settings.timerEndBeep;
        document.getElementById("settingDefaultPhotoFlo").checked =
          settingsManager.settings.defaultPhotoFlo;

        // Countdown settings
        document.getElementById("settingCountdownDelay").value =
          settingsManager.settings.countdownDelay;
        document.getElementById("settingCountdownBeep").checked =
          settingsManager.settings.countdownBeep;
        document.getElementById("settingCountdownPattern").value =
          settingsManager.settings.countdownPattern || "every-second"; // NEW

        // NEW: Auto advance setting
        document.getElementById("settingAutoAdvance").checked =
          settingsManager.settings.autoAdvance;

        // Apply auto advance to F-Stop Test generator
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.setAutoAdvance(
            settingsManager.settings.autoAdvance
          );
        }
        document.getElementById("settingAutoAdvanceDelay").value =
          settingsManager.settings.autoAdvanceDelay || 1;

        // Apply auto advance to F-Stop Test generator
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.setAutoAdvance(
            settingsManager.settings.autoAdvance
          );
          window.fstopTestGenerator.setAutoAdvanceDelay(
            (settingsManager.settings.autoAdvanceDelay || 1) * 1000
          );
        }

        // Load base time slider limits
        const baseTimeMinInput = document.getElementById("baseTimeMin");
        const baseTimeMaxInput = document.getElementById("baseTimeMax");
        if (baseTimeMinInput) {
          baseTimeMinInput.value = settingsManager.settings.baseTimeMin || 0.4;
        }
        if (baseTimeMaxInput) {
          baseTimeMaxInput.value = settingsManager.settings.baseTimeMax || 50;
        }

        // Apply limits to BASE TIME slider
        const baseTimeSlider = document.getElementById("baseTimeSlider");
        if (baseTimeSlider) {
          baseTimeSlider.min = settingsManager.settings.baseTimeMin || 0.4;
          baseTimeSlider.max = settingsManager.settings.baseTimeMax || 50;
        }

        // Load test base time slider limits
        const testBaseTimeMinInput = document.getElementById("testBaseTimeMin");
        const testBaseTimeMaxInput = document.getElementById("testBaseTimeMax");
        if (testBaseTimeMinInput) {
          testBaseTimeMinInput.value =
            settingsManager.settings.testBaseTimeMin || 1;
        }
        if (testBaseTimeMaxInput) {
          testBaseTimeMaxInput.value =
            settingsManager.settings.testBaseTimeMax || 50;
        }

        // Apply limits to TEST BASE TIME slider
        const testBaseSlider = document.getElementById("testBaseSlider");
        if (testBaseSlider) {
          testBaseSlider.min = settingsManager.settings.testBaseTimeMin || 1;
          testBaseSlider.max = settingsManager.settings.testBaseTimeMax || 50;
        }

        // F-stop increment denominator (persisted setting)
        const savedDenom = settingsManager.settings.stopDenominator || 3;
        const cSeg = document.getElementById("calcIncrementSeg");
        const tSeg = document.getElementById("testIncrementSeg");
        if (cSeg) {
          Array.from(cSeg.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === savedDenom;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        if (tSeg) {
          Array.from(tSeg.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === savedDenom;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        const oldC = document.getElementById("calcIncrementDenom");
        if (oldC) oldC.value = savedDenom;
        const oldT = document.getElementById("testIncrementDenom");
        if (oldT) oldT.value = savedDenom;
        const settingsSel = document.getElementById("settingStopIncrement");
        if (settingsSel) settingsSel.value = savedDenom;
        window.stopDenominator = savedDenom;

        // Apply base time to calculator and test generator (on load)
        (function applyLoadedBaseAndTimerDefaults() {
          const newBase = parseFloat(
            settingsManager.settings.baseTime || DEFAULT_SETTINGS.baseTime
          );
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            baseSlider.value = newBase;
            baseSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }
          const testBase = document.getElementById("testBaseSlider");
          if (testBase) {
            testBase.value = newBase;
            testBase.dispatchEvent(new Event("input", { bubbles: true }));
          }

          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = newBase;
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }

          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.baseTime = newBase;
            if (window.fstopTestGenerator.testBaseSlider) {
              window.fstopTestGenerator.testBaseSlider.value = newBase;
            }
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }

          // Apply saved default timer values
          const mapping = {
            Dev: parseInt(settingsManager.settings.devTime, 10),
            Stop: parseInt(settingsManager.settings.stopTime, 10),
            Fix: parseInt(settingsManager.settings.fixTime, 10),
            Flo: parseInt(settingsManager.settings.floTime, 10),
          };

          // Update DEFAULT_TIMER_TIMES so future timers use these defaults
          Object.keys(mapping).forEach((k) => {
            if (typeof mapping[k] === "number" && !isNaN(mapping[k])) {
              DEFAULT_TIMER_TIMES[k] = mapping[k];
            }
          });

          // Update any existing timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              const newTime = mapping[timer.name];
              if (typeof newTime === "number" && !isNaN(newTime)) {
                if (!timer.isRunning) {
                  timer.setTime(newTime);
                } else {
                  timer.totalTime = newTime;
                  timer.timeLeft = newTime;
                  timer.warningPlayed = false;
                  timer.updateDisplay();
                  timer.updateButtonStates();
                }
              }
            });
          }
        })();

        // NEW: Safelight auto-off setting
        document.getElementById("safelightAutoOff").checked =
          settingsManager.settings.safelightAutoOff !== false; // Default to true
      }

      // Timer Manager
      timerManager = {
        timers: [],
        init: function () {
          // Create timers
          this.timers = [
            new Timer("Dev"),
            new Timer("Stop"),
            new Timer("Fix"),
            new Timer("Flo"),
          ];

          // Apply settings if available
          if (settingsManager) {
            // Apply saved profile if exists
            if (appState.persistent.currentProfile) {
              const profile = settingsManager.profiles.find(
                (p) => p.name === appState.persistent.currentProfile
              );
              if (profile && profile.times) {
                this.timers.forEach((timer) => {
                  if (profile.times[timer.name] !== undefined) {
                    timer.setTime(profile.times[timer.name]);
                  }
                });
              }
            }

            // Apply Photo Wash toggle
            const photoFloToggle = document.getElementById("photoFloToggle");
            photoFloToggle.checked = settingsManager.settings.defaultPhotoFlo;
            const floTimer = this.timers.find((t) => t.name === "Flo");
            if (floTimer) {
              floTimer.updateEnabledState(
                settingsManager.settings.defaultPhotoFlo
              );
            }

            // Add change listener
            photoFloToggle.addEventListener("change", () => {
              const floTimer = this.timers.find((t) => t.name === "Flo");
              if (floTimer) {
                floTimer.updateEnabledState(photoFloToggle.checked);
              }
            });
          }

          // Start All button - NEW: Start/Pause/Resume with countdown integration
          window.startAllState = {
            isCountdown: false,
            isRunning: false,
            isPaused: false,
            countdownResolve: null,
            firstTimer: null,
            originalDisplayText: null,
          };

          const updateStartAllButton = () => {
            const btn = document.getElementById("startAll");
            if (!btn) return;

            if (window.startAllState.isCountdown) {
              btn.textContent = "Cancel";
              btn.disabled = false;
            } else if (window.startAllState.isRunning) {
              btn.textContent = "Pause";
              btn.disabled = false;
            } else if (window.startAllState.isPaused) {
              btn.textContent = "Resume";
              btn.disabled = false;
            } else {
              btn.textContent = "Start All";
              btn.disabled = false;
            }
          };

          document
            .getElementById("startAll")
            .addEventListener("click", async () => {
              const firstEnabledTimer = this.timers.find(
                (t) => t.state.isEnabled
              );
              if (!firstEnabledTimer) return;

              // CANCEL countdown
              if (window.startAllState.isCountdown) {
                if (window.startAllState.countdownResolve) {
                  window.startAllState.countdownResolve("cancelled");
                  // Also cancel the countdown manager to stop the timer
                  if (window.countdownManager) {
                    window.countdownManager.cancel();
                  }
                }
                return;
              }

              // PAUSE running sequence
              if (window.startAllState.isRunning) {
                // Stop all timers in the sequence
                this.timers.forEach((timer) => {
                  if (timer.state.isRunning) {
                    timer.stop();
                  }
                });
                window.startAllState.isRunning = false;
                window.startAllState.isPaused = true;
                updateStartAllButton();
                return;
              }

              // RESUME paused sequence
              if (window.startAllState.isPaused) {
                // Find the first timer that has time left and resume it
                const timerToResume = this.timers.find(
                  (t) =>
                    t.state.isEnabled &&
                    t.state.timeLeft > 0 &&
                    !t.state.isRunning
                );
                if (timerToResume) {
                  window.startAllState.isPaused = false;
                  window.startAllState.isRunning = true;
                  timerToResume.start(true); // Start as sequence
                  updateStartAllButton();
                }
                return;
              }

              // START NEW SEQUENCE
              // Start countdown on first timer's display
              const display = document.getElementById(
                `display${firstEnabledTimer.name}`
              );
              window.startAllState.originalDisplayText = display.textContent;
              window.startAllState.firstTimer = firstEnabledTimer;
              window.startAllState.isCountdown = true;
              window.startAllState.isRunning = false;
              window.startAllState.isPaused = false;

              // Update button states during countdown
              updateStartAllButton();
              document.getElementById("resetAll").disabled = false; // Keep reset enabled

              const countdownResult = await new Promise((resolve) => {
                window.startAllState.countdownResolve = resolve;
                window.countdownManager.startCountdown(display, () => {
                  resolve("complete");
                });
              });

              // Restore display
              display.textContent = window.startAllState.originalDisplayText;
              window.startAllState.countdownResolve = null;
              window.startAllState.isCountdown = false;

              if (countdownResult === "cancelled") {
                updateStartAllButton();
                return;
              }

              // Start the timer as part of a sequence
              window.startAllState.isRunning = true;
              firstEnabledTimer.reset();
              firstEnabledTimer.start(true);
              updateStartAllButton();
            });

          // Reset All button - NEW: Stop/Reset functionality
          document.getElementById("resetAll").addEventListener("click", () => {
            // If countdown is running, cancel it
            if (
              window.startAllState.isCountdown &&
              window.startAllState.countdownResolve
            ) {
              window.startAllState.countdownResolve("cancelled");
              // Also cancel the countdown manager to stop the timer
              if (window.countdownManager) {
                window.countdownManager.cancel();
              }
              // The click handler will handle cleanup
              return;
            }

            // Stop all running timers
            this.timers.forEach((timer) => {
              if (timer.state.isRunning) {
                timer.stop();
              }
              // Reset all enabled timers
              if (timer.state.isEnabled) {
                timer.reset();
              }
            });

            // Reset start all state
            window.startAllState.isCountdown = false;
            window.startAllState.isRunning = false;
            window.startAllState.isPaused = false;
            window.startAllState.countdownResolve = null;
            updateStartAllButton();
          });

          // Audio context init is now in centralized delegation
        },
      };

      // Calculator functions
      const baseTimeSlider = document.getElementById("baseTimeSlider");
      const stopSlider = document.getElementById("stopSlider");
      const chartBaseSlider = document.getElementById("chartBaseSlider");

      /**
       * @function formatStop
       * @description Formats a stop value as a human-readable string with fractions.
       * Supports denominators 2, 3, 4, 6 with Unicode fraction characters.
       * @param {number} value - Stop value (in fractional steps)
       * @returns {string} Formatted stop string (e.g., "1⅓", "2½", "-3.0")
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * formatStop(4); // Returns "1⅓" if denominator is 3
       */
      function formatStop(value) {
        const denom = window.stopDenominator || 3;
        const val = value / denom; // actual stops
        const sign = val < 0 ? "-" : "";
        const absVal = Math.abs(val);
        const whole = Math.floor(absVal);
        const frac = absVal - whole;
        const tol = 1e-6;

        if (Math.abs(frac) < tol) return `${sign}${whole}.0`;

        if (denom === 2) {
          if (Math.abs(frac - 0.5) < tol) return `${sign}${whole}½`;
        } else if (denom === 3) {
          if (Math.abs(frac - 1 / 3) < tol) return `${sign}${whole}⅓`;
          if (Math.abs(frac - 2 / 3) < tol) return `${sign}${whole}⅔`;
        } else if (denom === 4) {
          if (Math.abs(frac - 0.25) < tol) return `${sign}${whole}¹⁄₄`;
          if (Math.abs(frac - 0.5) < tol) return `${sign}${whole}²⁄₄`;
          if (Math.abs(frac - 0.75) < tol) return `${sign}${whole}³⁄₄`;
        } else if (denom === 6) {
          if (Math.abs(frac - 1 / 6) < tol) return `${sign}${whole}¹⁄₆`;
          if (Math.abs(frac - 2 / 6) < tol) return `${sign}${whole}²⁄₆`;
          if (Math.abs(frac - 3 / 6) < tol) return `${sign}${whole}³⁄₆`;
          if (Math.abs(frac - 4 / 6) < tol) return `${sign}${whole}⁴⁄₆`;
          if (Math.abs(frac - 5 / 6) < tol) return `${sign}${whole}⁵⁄₆`;
        }

        return `${sign}${absVal.toFixed(1)}`;
      }

      /**
       * @function formatStopCompact
       * @description Formats stop value in compact form for rulers and small displays.
       * Shows fraction-only when <1 stop, includes whole number otherwise.
       * @param {number} stopValue - Stop value in full stops
       * @returns {string} Compact formatted stop string (e.g., "⅓", "1½", "2")
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * formatStopCompact(0.33); // Returns "⅓" if denominator is 3
       */
      function formatStopCompact(stopValue) {
        const denom = window.stopDenominator || 3;
        const whole = Math.floor(stopValue);
        const fraction = stopValue - whole;
        const tol = 1e-6;

        if (Math.abs(fraction) < tol) {
          return `${whole}`;
        }

        let fracLabel = "";
        if (denom === 2) {
          if (Math.abs(fraction - 0.5) < tol) fracLabel = "½";
        } else if (denom === 3) {
          if (Math.abs(fraction - 1 / 3) < tol) fracLabel = "⅓";
          else if (Math.abs(fraction - 2 / 3) < tol) fracLabel = "⅔";
        } else if (denom === 4) {
          if (Math.abs(fraction - 0.25) < tol) fracLabel = "¹⁄₄";
          else if (Math.abs(fraction - 0.5) < tol) fracLabel = "²⁄₄";
          else if (Math.abs(fraction - 0.75) < tol) fracLabel = "³⁄₄";
        } else if (denom === 6) {
          if (Math.abs(fraction - 1 / 6) < tol) fracLabel = "¹⁄₆";
          else if (Math.abs(fraction - 2 / 6) < tol) fracLabel = "²⁄₆";
          else if (Math.abs(fraction - 3 / 6) < tol) fracLabel = "³⁄₆";
          else if (Math.abs(fraction - 4 / 6) < tol) fracLabel = "⁴⁄₆";
          else if (Math.abs(fraction - 5 / 6) < tol) fracLabel = "⁵⁄₆";
        }

        if (fracLabel) {
          return whole === 0 ? fracLabel : `${whole}${fracLabel}`;
        }

        return stopValue.toFixed(1);
      }

      /**
       * @function calculateTime
       * @description Calculates exposure time for a given stop value.
       * Uses the formula: time = base * 2^(stop/denominator)
       * @param {number} base - Base exposure time in seconds
       * @param {number} stop - Stop value (in fractional steps)
       * @returns {number} Calculated exposure time in seconds
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * calculateTime(10, 3); // Returns 20.0 if denominator is 3 (1 stop = 2x time)
       */
      function calculateTime(base, stop) {
        const denom = window.stopDenominator || 3;
        return base * Math.pow(2, stop / denom);
      }

      /**
       * @class IncrementalTimer
       * @classdesc Dodge/burn calculator with step-by-step exposure progression.
       * Manages incremental exposure calculations for darkroom printing, allowing
       * users to build up exposure through multiple steps with f-stop precision.
       *
       * @property {number} baseTime - Base exposure time in seconds
       * @property {number} currentStop - Current f-stop increment value
       * @property {number} previousTotalTime - Total time from previous step
       * @property {number} currentTotalTime - Total time for current step
       * @property {number} thisExposureTime - Time for this specific step
       * @property {number} accumulatedTime - Cumulative time across all steps
       * @property {number} currentTime - Current countdown time
       * @property {boolean} isRunning - Whether exposure is in progress
       * @property {boolean} isPaused - Whether exposure is paused
       * @property {boolean} isCountdown - Whether countdown is active
       * @property {number} lastExposureTime - Time of last completed exposure
       * @property {DriftCorrectedTimer|null} driftTimer - High-precision timer instance
       * @property {number|null} lastBeepSecond - Last second that beep played
       * @property {Function|null} countdownResolve - Promise resolver for countdown
       *
       * @description
       * The calculator works by accumulating exposure time across multiple steps.
       * Each step adds time based on f-stop increments (1/3, 1/2, 1 stop, etc.).
       *
       * F-Stop Formula: time = baseTime × 2^(stop/denominator)
       *
       * Integration Points:
       * - Uses CountdownManager before starting exposure
       * - Triggers RelayManager for automatic enlarger control
       * - Syncs with appState.calculator for persistence
       * - Updates UI via render functions
       *
       * @example
       * // Initialize calculator
       * const calc = new IncrementalTimer();
       *
       * // Set base time and start
       * calc.baseTime = 10.0;
       * calc.currentStop = 1; // 1/3 stop
       * calc.updateCalculations();
       * await calc.start(); // Includes countdown and relay trigger
       *
       * // After exposure completes
       * calc.accumulatedTime = calc.currentTotalTime;
       * calc.updateCalculations(); // Ready for next step
       */
      class IncrementalTimer {
        /**
         * @constructor
         * @description Creates an IncrementalTimer instance and initializes state.
         * Syncs with appState.calculator, sets up event listeners, and renders UI.
         * @property {DriftCorrectedTimer|null} driftTimer - High-precision timer
         * @property {number|null} lastBeepSecond - Last beep second tracking
         * @property {Function|null} countdownResolve - Countdown promise resolver
         */
        constructor() {
          // Initialize state from appState
          this.syncFromState();

          this.driftTimer = null; // Using drift-corrected timer
          this.lastBeepSecond = null;
          this.countdownResolve = null;

          this.init();
          this.render();
        }

        /**
         * @method syncFromState
         * @description Synchronizes local properties from central appState.calculator.
         * Called during initialization to load persisted runtime state.
         * @returns {void}
         * @fires appState.calculator - Reads from central calculator state
         * @example
         * this.syncFromState(); // Load state before operations
         */
        syncFromState() {
          const state = appState.calculator;
          this.baseTime = state.baseTime;
          this.currentStop = state.currentStop;
          this.previousTotalTime = 0;
          this.currentTotalTime = state.currentTotalTime;
          this.thisExposureTime = state.thisExposureTime;
          this.accumulatedTime = state.accumulatedTime;
          this.currentTime = state.currentTime;
          this.isRunning = state.isRunning;
          this.isPaused = state.isPaused;
          this.isCountdown = state.isCountdown;
          this.lastExposureTime = state.lastExposureTime;
        }

        /**
         * @method syncToState
         * @description Synchronizes central appState.calculator from local properties.
         * Called before rendering to ensure UI reflects current state.
         * @returns {void}
         * @fires appState.calculator - Writes to central calculator state
         * @example
         * this.syncToState(); // Save state before rendering
         */
        syncToState() {
          const state = appState.calculator;
          state.baseTime = this.baseTime;
          state.currentStop = this.currentStop;
          state.currentTotalTime = this.currentTotalTime;
          state.thisExposureTime = this.thisExposureTime;
          state.accumulatedTime = this.accumulatedTime;
          state.currentTime = this.currentTime;
          state.isRunning = this.isRunning;
          state.isPaused = this.isPaused;
          state.isCountdown = this.isCountdown;
          state.lastExposureTime = this.lastExposureTime;
        }

        /**
         * @method render
         * @description Unified render method that updates all calculator UI elements.
         * Syncs state to appState, then calls render functions for display, details, timer status, and chart.
         * @returns {void}
         * @fires syncToState - Updates central state before rendering
         * @fires renderCalculatorDisplay - Updates main display
         * @fires renderCalculatorExposureDetails - Updates exposure details
         * @fires renderCalculatorTimerStatus - Updates timer status
         * @fires updateChart - Updates f-stop chart
         * @example
         * this.render(); // Update all UI elements
         */
        render() {
          this.syncToState();
          renderCalculatorDisplay();
          renderCalculatorExposureDetails();
          renderCalculatorTimerStatus();
          updateChart();
        }

        /**
         * @method init
         * @description Initializes event listeners for calculator sliders.
         * Binds base time and stop increment sliders to update calculations.
         * @returns {void}
         * @fires addEventListener - Listens for slider input events
         * @fires updateFromSliders - Called when sliders change
         * @example
         * this.init(); // Set up slider listeners
         */
        init() {
          // Sliders still need direct listeners for input events
          baseTimeSlider.addEventListener("input", () =>
            this.updateFromSliders()
          );
          stopSlider.addEventListener("input", () => this.updateFromSliders());
        }

        /**
         * @method stopCurrentExposure
         * @description Stops the current exposure or cancels countdown.
         * Resets timer state and updates UI. If countdown is active, cancels it.
         * If exposure is running, stops it and resets current time.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires driftTimer.stop - Stops high-precision timer
         * @fires updateStatus - Updates UI with stop status
         * @fires playPreset - Audio feedback
         * @example
         * // User clicks "Stop" button during countdown or exposure
         * this.stopCurrentExposure();
         */
        stopCurrentExposure() {
          if (!this.isRunning && !this.isPaused && !this.isCountdown) return;

          const wasCountdown = this.isCountdown;

          if (this.isCountdown && window.countdownManager?.isActive) {
            window.countdownManager.cancel();
            if (this.countdownResolve) {
              this.countdownResolve("cancelled");
              this.countdownResolve = null;
            }
          }

          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.isCountdown = false;
          this.lastBeepSecond = null;

          // Reset current time to current exposure time
          this.currentTime = this.thisExposureTime;

          // Update state and render
          appState.ui.timerStatus = wasCountdown
            ? "COUNTDOWN CANCELLED"
            : "EXPOSURE STOPPED";
          this.render();

          playPreset("pause");
        }

        /**
         * @method repeatLast
         * @description Repeats the last completed exposure time.
         * Sets current exposure time to the last completed exposure time
         * and prepares the timer for immediate restart.
         * @returns {void}
         * @fires driftTimer.stop - Stops any running timer
         * @fires updateStatus - Updates UI with repeat status
         * @fires playPreset - Audio feedback
         * @example
         * // User clicks "Repeat" button after completing an exposure
         * this.repeatLast();
         */
        repeatLast() {
          if (this.lastExposureTime <= 0) return;

          // Set current exposure to last exposure time
          this.thisExposureTime = this.lastExposureTime;
          this.currentTime = this.lastExposureTime;

          // Reset timer state
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Update state and render
          appState.ui.timerStatus = "READY TO REPEAT";
          this.render();

          playPreset("pause");
        }

        /**
         * @method updateFromSliders
         * @description Updates calculator from slider values.
         * Reads base time and stop increment from UI sliders, recalculates
         * exposure times, and updates display.
         * @returns {void}
         * @fires updateCalculations - Recalculates exposure times
         * @fires render - Updates UI display
         * @example
         * // Called when user moves sliders
         * this.updateFromSliders();
         */
        updateFromSliders() {
          this.baseTime = parseFloat(baseTimeSlider.value);
          this.currentStop = parseInt(stopSlider.value);
          this.updateCalculations();
          this.render();
        }

        /**
         * @method updateCalculations
         * @description Recalculates all exposure times based on current parameters.
         * Uses f-stop formula: time = baseTime × 2^(stop/denominator)
         * Updates currentTotalTime, thisExposureTime, and currentTime.
         * @returns {void}
         * @fires calculateTime - F-stop time calculation function
         * @example
         * // After changing base time or stop increment
         * this.updateCalculations();
         */
        updateCalculations() {
          this.currentTotalTime = calculateTime(
            this.baseTime,
            this.currentStop
          );
          this.thisExposureTime = this.currentTotalTime - this.accumulatedTime;

          if (this.thisExposureTime < 0) {
            this.thisExposureTime = 0;
          }

          if (!this.isRunning && !this.isPaused) {
            this.currentTime = this.thisExposureTime;
          }
        }

        /**
         * @method updateAllDisplays
         * @deprecated Use render() instead
         * @description Legacy method that calls render().
         * @returns {void}
         * @fires render - Updates all displays
         */
        updateAllDisplays() {
          // Deprecated - use render() instead
          this.render();
        }

        /**
         * @method triggerRelayForTimer
         * @description Triggers the enlarger relay for the current exposure time.
         * Only triggers if auto-trigger is enabled in RelayManager.
         * @returns {Promise<void>} Resolves when relay trigger completes
         * @fires relayManager.triggerTimerRelay - Sends timer command to server
         * @example
         * // Called automatically during start() method
         * await this.triggerRelayForTimer();
         */
        async triggerRelayForTimer() {
          if (window.relayManager && window.relayManager.autoTrigger) {
            // Use the current exposure time
            const exposureTime = this.thisExposureTime;

            // Send relay trigger with the exposure time
            await window.relayManager.triggerTimerRelay(exposureTime);
          }
        }

        /**
         * @method start
         * @description Starts the exposure with countdown and relay trigger.
         * Performs countdown using CountdownManager, triggers enlarger relay,
         * and starts the exposure timer with drift correction.
         * @returns {Promise<void>} Resolves when countdown completes or is cancelled
         * @throws {Error} Logs error if relay trigger fails
         * @fires countdownManager.startCountdown - Visual/audio countdown
         * @fires relayManager.triggerTimerRelay - Triggers enlarger
         * @fires startInterval - Begins exposure timer
         * @fires updateStatus - Updates UI status
         * @fires render - Updates UI display
         * @example
         * // User clicks "Start Exposure" button
         * await this.start();
         */
        async start() {
          if (
            this.isRunning ||
            this.isPaused ||
            this.isCountdown ||
            this.thisExposureTime <= 0
          )
            return;

          // Start countdown
          const display = document.getElementById("calcTimerDisplay");
          const originalText = display.textContent;
          this.isCountdown = true;
          appState.ui.timerStatus = "COUNTDOWN STARTING...";
          this.render();

          // During countdown: disable start/repeat/reset, keep stop enabled
          const startBtn = document.getElementById("startExposure");
          const stopBtn = document.getElementById("stopCalcTimer");
          const resetBtn = document.getElementById("resetCalcTimer");
          const repeatBtn = document.getElementById("repeatExposure");
          if (startBtn) startBtn.disabled = true;
          if (stopBtn) stopBtn.disabled = false;
          if (resetBtn) resetBtn.disabled = true;
          if (repeatBtn) repeatBtn.disabled = true;

          const countdownResult = await new Promise((resolve) => {
            this.countdownResolve = resolve;
            window.countdownManager.startCountdown(display, () => {
              resolve("complete");
            });
          });

          this.countdownResolve = null;
          this.isCountdown = false;

          // Ensure display is restored even if countdown was cancelled
          display.textContent = originalText;

          if (countdownResult === "cancelled") {
            appState.ui.timerStatus = "COUNTDOWN CANCELLED";
            this.render();
            return;
          }

          appState.ui.timerStatus = "EXPOSURE IN PROGRESS";

          // TRIGGER RELAY HERE
          if (window.relayManager && window.relayManager.autoTrigger) {
            try {
              await window.relayManager.triggerTimerRelay(
                this.thisExposureTime
              );
            } catch (error) {
              console.error("Failed to trigger relay:", error);
            }
          }

          // Now start the actual exposure timer
          this.isRunning = true;
          this.isPaused = false;
          this.lastBeepSecond = null;

          this.render();
          this.startInterval();
        }

        /**
         * @method startInterval
         * @description Starts the drift-corrected exposure timer.
         * Creates a DriftCorrectedTimer that decrements currentTime by 0.1s intervals.
         * Updates display, plays warning beeps, and calls complete() when finished.
         * @returns {void}
         * @fires DriftCorrectedTimer - High-precision timer instance
         * @fires playPreset - Warning beeps at 3 seconds
         * @fires complete - Called when timer reaches zero
         * @example
         * // Called by start() after countdown
         * this.startInterval();
         */
        startInterval() {
          this.driftTimer = new DriftCorrectedTimer(() => {
            this.currentTime -= 0.1;

            if (this.currentTime <= 0) {
              this.currentTime = 0;
              this.complete();
            } else {
              // Update display directly for performance
              document.getElementById("calcTimerDisplay").textContent =
                this.currentTime.toFixed(2);

              // Sync state periodically
              appState.calculator.currentTime = this.currentTime;

              if (this.currentTime <= 3 && appState.settings.calcWarningBeep) {
                const currentSecond = Math.ceil(this.currentTime);

                if (
                  currentSecond !== this.lastBeepSecond &&
                  currentSecond <= 3 &&
                  currentSecond > 0
                ) {
                  this.lastBeepSecond = currentSecond;
                  playPreset("calcWarning");
                  document
                    .getElementById("calcTimerDisplay")
                    .classList.add("warning");

                  setTimeout(() => {
                    document
                      .getElementById("calcTimerDisplay")
                      .classList.remove("warning");
                  }, 500);
                }
              }
            }
          }, 100);

          this.driftTimer.start();
        }

        /**
         * @method pause
         * @description Pauses the running exposure timer.
         * Stops the drift timer and updates state to paused.
         * @returns {void}
         * @fires driftTimer.stop - Stops high-precision timer
         * @fires updateStatus - Updates UI with pause status
         * @fires playPreset - Audio feedback
         * @example
         * // User clicks "Pause" button during exposure
         * this.pause();
         */
        pause() {
          if (!this.isRunning) return;

          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = true;

          appState.ui.timerStatus = "EXPOSURE PAUSED";
          this.render();

          playPreset("pause");
        }

        /**
         * @method resume
         * @description Resumes a paused exposure timer.
         * Restarts the drift timer and continues countdown from paused time.
         * @returns {void}
         * @fires startInterval - Restarts timer with remaining time
         * @fires updateStatus - Updates UI with resume status
         * @example
         * // User clicks "Resume" button after pausing
         * this.resume();
         */
        resume() {
          if (!this.isPaused) return;

          this.isRunning = true;
          this.isPaused = false;
          this.lastBeepSecond = null;

          appState.ui.timerStatus = "EXPOSURE IN PROGRESS";
          this.render();

          this.startInterval();
        }

        /**
         * @method complete
         * @description Called when exposure timer reaches zero.
         * Stops timer, saves exposure time, updates accumulated time,
         * plays completion sound, and prepares for next step.
         * @returns {void}
         * @fires driftTimer.stop - Stops high-precision timer
         * @fires updateCalculations - Recalculates for next step
         * @fires playPreset - Completion beep
         * @fires updateStatus - Updates UI with complete status
         * @fires render - Updates display
         * @example
         * // Called automatically when timer reaches zero
         * this.complete();
         */
        complete() {
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Save the exposure time that just completed
          this.lastExposureTime = this.thisExposureTime;

          this.accumulatedTime = this.currentTotalTime;

          if (appState.settings.calcEndBeep) {
            playPreset("calcComplete");
          }

          appState.ui.timerStatus = "EXPOSURE COMPLETE";
          this.updateCalculations();
          this.currentTime = this.thisExposureTime;

          this.render();
        }

        /**
         * @method reset
         * @description Resets calculator to initial state.
         * Stops any running timer, clears accumulated time, and resets
         * to ready state for new exposure sequence.
         * @returns {void}
         * @fires driftTimer.stop - Stops any running timer
         * @fires updateCalculations - Recalculates base exposure
         * @fires updateStatus - Updates UI with ready status
         * @fires render - Updates display
         * @example
         * // User clicks "Reset" button
         * this.reset();
         */
        reset() {
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.isCountdown = false;
          this.lastBeepSecond = null;

          this.accumulatedTime = 0;
          this.updateCalculations();
          this.currentTime = this.thisExposureTime;

          appState.ui.timerStatus = "READY FOR EXPOSURE";
          this.render();
        }

        /**
         * @method toggle
         * @description Toggles between start, pause, and resume states.
         * Convenience method that handles state transitions based on current state.
         * @returns {void}
         * @fires start - If idle
         * @fires pause - If running
         * @fires resume - If paused
         * @example
         * // User clicks main exposure button
         * this.toggle();
         */
        toggle() {
          if (this.isCountdown) return;
          if (this.isRunning) {
            this.pause();
          } else if (this.isPaused) {
            this.resume();
          } else {
            this.start();
          }
        }
      }

      /**
       * @class EnlargerHeightCalculator
       * @classdesc Comprehensive darkroom exposure calculator integrating height, aperture, paper size, and contrast.
       * Calculates new exposure time based on multiple variables using the inverse square law and f-stop formulas.
       *
       * @property {IncrementalTimer} incrementalTimer - Reference to main calculator for time synchronization
       * @property {number} originalTime - Base exposure time in seconds
       * @property {number} originalHeight - Original enlarger height in cm
       * @property {number} newHeight - New enlarger height in cm
       * @property {number} originalFStop - Original lens aperture (f-stop)
       * @property {number} newFStop - New lens aperture (f-stop)
       * @property {number} originalPaperSize - Original paper area in m²
       * @property {number} newPaperSize - New paper area in m²
       * @property {number} originalPaperSizeCustom - Custom original paper area
       * @property {number} newPaperSizeCustom - Custom new paper area
       * @property {string} currentPaper - Selected paper type ('fomaspeed' or 'fomatonemg')
       * @property {string} currentFilter - Selected contrast filter
       * @property {number} filterFactor - Contrast filter factor from paper data
       * @property {number} customBankFactor - Custom filter bank multiplier
       * @property {string} customBankLabel - Name of custom filter bank
       * @property {number} heightFactor - Calculated height factor (squared)
       * @property {number} fstopFactor - Calculated f-stop factor (squared)
       * @property {number} paperSizeFactor - Calculated paper area ratio
       * @property {number} combinedFactor - Product of all factors
       * @property {number} newAdjustedTime - Final calculated exposure time
       *
       * @description
       * **Formula:** New Time = Original Time × Height Factor × F-Stop Factor × Paper Factor × Filter Factor × Custom Factor
       *
       * Where:
       * - Height Factor = (New Height ÷ Original Height)²
       * - F-Stop Factor = (New F-Stop ÷ Original F-Stop)²
       * - Paper Factor = New Paper Area ÷ Original Paper Area
       * - Filter Factor = Selected contrast filter multiplier
       * - Custom Factor = Custom filter bank multiplier
       *
       * **Integration:**
       * - Syncs with IncrementalTimer for current exposure time
       * - Updates CALC tab base time when applied
       * - Integrates with CustomFilterBankManager for contrast control
       * - Uses paper-specific filter data for accurate calculations
       *
       * @example
       * // Initialize calculator
       * const calc = new EnlargerHeightCalculator(window.incrementalTimer);
       *
       * // Copy current time from calculator
       * calc.copyCurrentTime();
       *
       * // Adjust parameters
       * calc.newHeight = 45; // Raise enlarger
       * calc.updateCalculations();
       * calc.updateDisplay();
       *
       * // Apply to CALC tab
       * calc.applyNewTime();
       */
      class EnlargerHeightCalculator {
        /**
         * @constructor
         * @description Creates an EnlargerHeightCalculator instance with default values.
         * Initializes all calculation parameters and sets up UI event listeners.
         * @param {IncrementalTimer} incrementalTimer - Reference to main calculator
         * @property {Object} paperTypes - Paper-specific contrast filter data
         */
        constructor(incrementalTimer) {
          this.incrementalTimer = incrementalTimer;
          this.originalTime = 10.0;
          this.originalHeight = 30.0;
          this.newHeight = 30.0;
          this.originalFStop = 5.6;
          this.newFStop = 5.6;
          this.originalPaperSize = 0.052; // Changed from 0.080
          this.newPaperSize = 0.052; // Changed from 0.080
          this.originalPaperSizeCustom = 0.052; // Changed from 0.080
          this.newPaperSizeCustom = 0.052; // Changed from 0.080

          // NEW: Contrast control variables
          this.currentPaper = "fomaspeed";
          this.currentFilter = "none";
          this.filterFactor = 1.0;
          this.customBankFactor = 1.0;
          this.customBankLabel = "";

          // Paper types data from contrast calculator
          this.paperTypes = {
            fomaspeed: {
              name: "FOMASPEED Variant III / FOMABROM Variant III",
              filters: {
                "2xY": { iso: 135, factor: 1.6 },
                Y: { iso: 120, factor: 1.4 },
                none: { iso: 105, factor: 1.0 },
                M1: { iso: 90, factor: 1.4 },
                "2xM1": { iso: 80, factor: 2.1 },
                M2: { iso: 65, factor: 2.6 },
                "2xM2": { iso: 55, factor: 4.6 },
              },
            },
            fomatonemg: {
              name: "FOMATONE MG / FOMATONE MG Classic",
              filters: {
                "2xY": { iso: 120, factor: 2.0 },
                Y: { iso: 105, factor: 1.5 },
                none: { iso: 90, factor: 1.0 },
                M1: { iso: 80, factor: 1.5 },
                "2xM1": { iso: 75, factor: 1.8 },
                M2: { iso: 65, factor: 2.0 },
                "2xM2": { iso: 55, factor: 3.0 },
              },
            },
          };

          this.heightFactor = 1.0;
          this.fstopFactor = 1.0;
          this.paperSizeFactor = 1.0;
          this.combinedFactor = 1.0;
          this.newAdjustedTime = 10.0;

          this.init();
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method init
         * @description Initializes UI elements and event listeners for the calculator.
         * Binds all sliders, dropdowns, and buttons to their respective handler functions.
         * @returns {void}
         * @fires addEventListener - Binds input/change/click events
         * @fires updateFromControls - Called by sliders and dropdowns
         * @fires copyCurrentTime - Called by "Use Current" button
         * @fires applyNewTime - Called by "Apply" button
         * @fires selectPaper - Called by paper type buttons
         * @example
         * this.init(); // Set up all UI bindings
         */
        init() {
          // Get existing elements
          this.originalHeightCoarseSlider = document.getElementById(
            "originalHeightCoarseSlider"
          );
          this.originalHeightFineSlider = document.getElementById(
            "originalHeightFineSlider"
          );
          this.newHeightCoarseSlider = document.getElementById(
            "newHeightCoarseSlider"
          );
          this.newHeightFineSlider = document.getElementById(
            "newHeightFineSlider"
          );
          this.originalHeightValue = document.getElementById(
            "originalHeightValue"
          );
          this.newHeightValue = document.getElementById("newHeightValue");
          this.originalTimeValue = document.getElementById("originalTimeValue");
          this.heightFactorElement = document.getElementById(
            "heightFactorDisplay"
          );
          this.fstopFactorElement = document.getElementById("fstopFactor");
          this.combinedFactorElement =
            document.getElementById("combinedFactor");
          this.newAdjustedTimeElement =
            document.getElementById("newAdjustedTime");
          this.copyCurrentTimeBtn = document.getElementById("copyCurrentTime");
          this.applyHeightTimeBtn = document.getElementById("applyHeightTime");
          this.originalFStopElement = document.getElementById("originalFStop");
          this.newFStopElement = document.getElementById("newFStop");
          this.originalPaperSizeElement =
            document.getElementById("originalPaperSize");
          this.newPaperSizeElement = document.getElementById("newPaperSize");
          this.originalCustomPaperSizeDiv = document.getElementById(
            "originalCustomPaperSize"
          );
          this.newCustomPaperSizeDiv =
            document.getElementById("newCustomPaperSize");
          this.originalCustomPaperSizeValue = document.getElementById(
            "originalCustomPaperSizeValue"
          );
          this.newCustomPaperSizeValue = document.getElementById(
            "newCustomPaperSizeValue"
          );
          this.setOriginalCustomPaperBtn = document.getElementById(
            "setOriginalCustomPaper"
          );
          this.setNewCustomPaperBtn =
            document.getElementById("setNewCustomPaper");

          // NEW: Get contrast control elements
          this.btnFomaspeed = document.getElementById("btnFomaspeed");
          this.btnFomatonemg = document.getElementById("btnFomatonemg");
          this.contrastFilterSelect = document.getElementById(
            "contrastFilterSelect"
          );
          this.isoValueElement = document.getElementById("isoValue");
          this.filterFactorValueElement =
            document.getElementById("filterFactorValue");
          this.filterFactorValueDisplay = document.getElementById(
            "filterFactorValueDisplay"
          );
          this.customBankFactorDisplay = document.getElementById(
            "customBankFactorDisplay"
          );

          // Set initial values
          this.originalCoarseHeight = 30;
          this.originalFineHeight = 0;
          this.newCoarseHeight = 30;
          this.newFineHeight = 0;

          // Add event listeners for existing controls
          this.originalHeightCoarseSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.originalHeightFineSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.newHeightCoarseSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.newHeightFineSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.originalFStopElement.addEventListener("change", () =>
            this.updateFromControls()
          );
          this.newFStopElement.addEventListener("change", () =>
            this.updateFromControls()
          );
          this.copyCurrentTimeBtn.addEventListener("click", () =>
            this.copyCurrentTime()
          );
          this.applyHeightTimeBtn.addEventListener("click", () =>
            this.applyNewTime()
          );
          this.originalPaperSizeElement.addEventListener("change", (e) => {
            const value = e.target.value;
            if (value === "custom") {
              this.originalCustomPaperSizeDiv.style.display = "block";
            } else {
              this.originalCustomPaperSizeDiv.style.display = "none";
              this.originalPaperSize = parseFloat(value);
              this.updateCalculations();
              this.updateDisplay();
            }
          });

          // New paper size change handler
          this.newPaperSizeElement.addEventListener("change", (e) => {
            const value = e.target.value;
            if (value === "custom") {
              this.newCustomPaperSizeDiv.style.display = "block";
            } else {
              this.newCustomPaperSizeDiv.style.display = "none";
              this.newPaperSize = parseFloat(value);
              this.updateCalculations();
              this.updateDisplay();
            }
          });
          this.setNewCustomPaperBtn.addEventListener("click", () => {
            const customValue = parseFloat(this.newCustomPaperSizeValue.value);
            if (customValue && customValue > 0) {
              this.newPaperSizeCustom = customValue;
              if (this.newPaperSizeElement.value === "custom") {
                this.newPaperSize = customValue;
                this.updateCalculations();
                this.updateDisplay();
                // Show visual feedback
                this.setNewCustomPaperBtn.textContent = "✓ Set";
                this.setNewCustomPaperBtn.classList.add("active");
                setTimeout(() => {
                  this.setNewCustomPaperBtn.textContent = "Set";
                  this.setNewCustomPaperBtn.classList.remove("active");
                }, 1000);
              }
            }
          });

          // Set original custom paper size button
          this.setOriginalCustomPaperBtn.addEventListener("click", () => {
            const customValue = parseFloat(
              this.originalCustomPaperSizeValue.value
            );
            if (customValue && customValue > 0) {
              this.originalPaperSizeCustom = customValue;
              if (this.originalPaperSizeElement.value === "custom") {
                this.originalPaperSize = customValue;
                this.updateCalculations();
                this.updateDisplay();
                // Show visual feedback
                this.setOriginalCustomPaperBtn.textContent = "✓ Set";
                this.setOriginalCustomPaperBtn.classList.add("active");
                setTimeout(() => {
                  this.setOriginalCustomPaperBtn.textContent = "Set";
                  this.setOriginalCustomPaperBtn.classList.remove("active");
                }, 1000);
              }
            }
          });

          // NEW: Add event listeners for contrast controls
          this.btnFomaspeed.addEventListener("click", () =>
            this.selectPaper("fomaspeed")
          );
          this.btnFomatonemg.addEventListener("click", () =>
            this.selectPaper("fomatonemg")
          );
          this.contrastFilterSelect.addEventListener("change", () => {
            this.currentFilter = this.contrastFilterSelect.value;
            this.updateCalculations();
            this.updateDisplay();
          });

          this.applyHeightTimeBtn.addEventListener("click", initAudioContext);
        }

        /**
         * @method selectPaper
         * @description Selects paper type for contrast filter calculations.
         * Updates button states and recalculates exposure with new paper's filter data.
         * @param {string} paperType - 'fomaspeed' or 'fomatonemg'
         * @returns {void}
         * @fires updateCalculations - Recalculates with new paper
         * @fires updateDisplay - Updates UI
         * @example
         * this.selectPaper('fomaspeed'); // Use FOMASPEED paper filters
         */
        selectPaper(paperType) {
          this.currentPaper = paperType;

          // Update button states
          this.btnFomaspeed.classList.remove("active");
          this.btnFomatonemg.classList.remove("active");
          if (paperType === "fomaspeed") {
            this.btnFomaspeed.classList.add("active");
          } else {
            this.btnFomatonemg.classList.add("active");
          }

          // Update calculations
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method updateCustomPaperSizeDisplays
         * @description Updates custom paper size input fields and visibility.
         * Shows/hides custom input fields based on dropdown selection.
         * @returns {void}
         * @fires Element.style.display - Shows/hides custom inputs
         * @fires Element.value - Updates input values
         * @example
         * this.updateCustomPaperSizeDisplays(); // Sync custom inputs
         */
        updateCustomPaperSizeDisplays() {
          // Update custom input fields with current values
          this.originalCustomPaperSizeValue.value =
            this.originalPaperSizeCustom.toFixed(3);
          this.newCustomPaperSizeValue.value =
            this.newPaperSizeCustom.toFixed(3);

          // Show/hide custom inputs based on selection
          if (this.originalPaperSizeElement.value === "custom") {
            this.originalCustomPaperSizeDiv.style.display = "block";
          } else {
            this.originalCustomPaperSizeDiv.style.display = "none";
          }

          if (this.newPaperSizeElement.value === "custom") {
            this.newCustomPaperSizeDiv.style.display = "block";
          } else {
            this.newCustomPaperSizeDiv.style.display = "none";
          }
        }

        /**
         * @method copyCurrentTime
         * @description Copies current exposure time from IncrementalTimer to calculator.
         * Resets fine height adjustments to zero and updates all calculations.
         * @returns {void}
         * @fires updateCalculations - Recalculates with new base time
         * @fires updateDisplay - Updates UI
         * @fires playBeep - Audio feedback
         * @example
         * this.copyCurrentTime(); // Use current calculator time as base
         */
        copyCurrentTime() {
          this.originalTime = this.incrementalTimer.currentTotalTime;

          // Reset fine adjustments to zero
          this.originalFineHeight = 0;
          this.newFineHeight = 0;

          // Update sliders
          this.originalHeightFineSlider.value = 0;
          this.newHeightFineSlider.value = 0;

          this.updateCalculations();
          this.updateDisplay();
          playBeep(600, 0.3, 0.2);
        }

        /**
         * @method updateFromControls
         * @description Reads all control values and updates calculator state.
         * Processes height sliders (coarse + fine), f-stop dropdowns, and paper size selections.
         * Handles custom paper size inputs and visibility.
         * @returns {void}
         * @fires updateCalculations - Recalculates all factors
         * @fires updateDisplay - Updates UI
         * @fires updateCustomPaperSizeDisplays - Syncs custom inputs
         * @example
         * // Called when any control changes
         * this.updateFromControls();
         */
        updateFromControls() {
          // Get coarse and fine values
          this.originalCoarseHeight = parseInt(
            this.originalHeightCoarseSlider.value
          );
          this.originalFineHeight =
            parseInt(this.originalHeightFineSlider.value) / 10; // Convert to decimal
          this.newCoarseHeight = parseInt(this.newHeightCoarseSlider.value);
          this.newFineHeight = parseInt(this.newHeightFineSlider.value) / 10;

          // Calculate total heights
          this.originalHeight =
            this.originalCoarseHeight + this.originalFineHeight;
          this.newHeight = this.newCoarseHeight + this.newFineHeight;

          // Get f-stop values
          this.originalFStop = parseFloat(this.originalFStopElement.value);
          this.newFStop = parseFloat(this.newFStopElement.value);

          // Get paper size values
          const originalPaperSizeSelect = this.originalPaperSizeElement.value;
          const newPaperSizeSelect = this.newPaperSizeElement.value;

          // Handle original paper size
          if (originalPaperSizeSelect === "custom") {
            // Show custom input and set current value
            this.originalCustomPaperSizeDiv.style.display = "block";
            this.originalCustomPaperSizeValue.value =
              this.originalPaperSizeCustom.toFixed(3);
            this.originalPaperSize = this.originalPaperSizeCustom;
          } else {
            // Hide custom input and use preset value
            this.originalCustomPaperSizeDiv.style.display = "none";
            this.originalPaperSize = parseFloat(originalPaperSizeSelect);
          }

          // Handle new paper size
          if (newPaperSizeSelect === "custom") {
            // Show custom input and set current value
            this.newCustomPaperSizeDiv.style.display = "block";
            this.newCustomPaperSizeValue.value =
              this.newPaperSizeCustom.toFixed(3);
            this.newPaperSize = this.newPaperSizeCustom;
          } else {
            // Hide custom input and use preset value
            this.newCustomPaperSizeDiv.style.display = "none";
            this.newPaperSize = parseFloat(newPaperSizeSelect);
          }

          this.updateCalculations();
          this.updateDisplay();
          this.updateCustomPaperSizeDisplays();
        }

        /**
         * @method updateCalculations
         * @description Calculates all exposure factors and final adjusted time.
         * Applies inverse square law for height and f-stop, area ratio for paper size,
         * and multiplies by filter factors.
         * @returns {void}
         * @description Formula: New Time = Original Time × Height² × F-Stop² × Paper Area × Filter × Custom
         * @fires Math.pow - For squared calculations
         * @fires paperTypes - Reads filter data from paper database
         * @example
         * this.updateCalculations(); // Recalculate all factors
         */
        updateCalculations() {
          // Height factor: (newHeight ÷ originalHeight)²
          if (this.originalHeight > 0) {
            this.heightFactor = Math.pow(
              this.newHeight / this.originalHeight,
              2
            );
          } else {
            this.heightFactor = 1.0;
          }

          // F-stop factor: (New F-Stop ÷ Original F-Stop)²
          if (this.newFStop > 0) {
            this.fstopFactor = Math.pow(this.newFStop / this.originalFStop, 2);
          } else {
            this.fstopFactor = 1.0;
          }

          // Paper size factor: New Paper Area ÷ Original Paper Area
          if (this.originalPaperSize > 0) {
            // CORRECT: (√New Paper Area ÷ √Original Paper Area)² = New Paper Area ÷ Original Paper Area
            // This is actually mathematically the same as newPaperSize / originalPaperSize
            // The issue was with the VALUES, not the formula!
            this.paperSizeFactor = this.newPaperSize / this.originalPaperSize;
          } else {
            this.paperSizeFactor = 1.0;
          }

          // Filter factor comes from contrast control selection
          const paper = this.paperTypes[this.currentPaper];
          const filter = paper?.filters?.[this.currentFilter];
          if (filter) {
            this.filterFactor = filter.factor;
          } else {
            this.filterFactor = 1.0;
          }

          // Combined factor includes ALL factors plus custom bank factor
          this.combinedFactor =
            this.heightFactor *
            this.fstopFactor *
            this.paperSizeFactor *
            this.filterFactor *
            this.customBankFactor;
          this.newAdjustedTime = this.originalTime * this.combinedFactor;
        }

        /**
         * @method updateDisplay
         * @description Updates all UI elements with current calculation results.
         * Displays factors, times, and filter data. Updates button text with calculation summary.
         * @returns {void}
         * @fires Element.textContent - Updates all display elements
         * @fires Element.classList - Updates button states
         * @example
         * this.updateDisplay(); // Refresh all UI displays
         */
        updateDisplay() {
          // Update height displays with one decimal
          this.originalHeightValue.textContent = `${this.originalHeight.toFixed(
            1
          )}`;
          this.newHeightValue.textContent = `${this.newHeight.toFixed(1)}`;
          this.originalTimeValue.textContent = this.originalTime.toFixed(2);
          this.heightFactorElement.textContent = `${this.heightFactor.toFixed(
            2
          )}x`;
          this.fstopFactorElement.textContent = `${this.fstopFactor.toFixed(
            2
          )}x`;
          document.getElementById(
            "paperSizeFactor"
          ).textContent = `${this.paperSizeFactor.toFixed(2)}x`;
          this.filterFactorValueDisplay.textContent = `${this.filterFactor.toFixed(
            2
          )}x`;
          this.combinedFactorElement.textContent = `${this.combinedFactor.toFixed(
            2
          )}x`;
          this.newAdjustedTimeElement.textContent =
            this.newAdjustedTime.toFixed(2);

          // Update contrast control displays from selected paper/filter only
          const paper = this.paperTypes[this.currentPaper];
          const filter = paper?.filters?.[this.currentFilter];
          if (filter) {
            this.isoValueElement.textContent = filter.iso;
            this.filterFactorValueElement.textContent = `${filter.factor.toFixed(
              1
            )}×`;
          }

          // Update custom bank factor display
          if (this.customBankFactorDisplay) {
            this.customBankFactorDisplay.textContent = `${this.customBankFactor.toFixed(
              2
            )}x`;
          }

          // Update button text to show calculation
          const timeDiff = ((this.combinedFactor - 1) * 100).toFixed(0);
          const direction = this.combinedFactor > 1 ? "increase" : "decrease";

          if (this.combinedFactor !== 1.0) {
            this.applyHeightTimeBtn.textContent = `Apply ${this.newAdjustedTime.toFixed(
              1
            )}s (${direction} ${Math.abs(timeDiff)}%)`;
          } else {
            this.applyHeightTimeBtn.textContent =
              "Apply Adjusted Time as Base Time";
          }
        }

        /**
         * @method applyCustomFilterFactor
         * @description Applies a custom filter factor from a filter bank.
         * Updates the custom factor and recalculates exposure.
         * @param {string} label - Name of the custom filter
         * @param {string|number} value - Filter factor multiplier
         * @returns {void}
         * @fires updateCalculations - Recalculates with new factor
         * @fires updateDisplay - Updates UI
         * @example
         * this.applyCustomFilterFactor('Custom Bank 1', '1.5'); // Apply 1.5x factor
         */
        applyCustomFilterFactor(label, value) {
          const factor = parseFloat(value);
          if (!factor || factor <= 0) return;
          this.customBankLabel = label || "Custom";
          this.customBankFactor = factor;
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method clearCustomFilterOverride
         * @description Clears any custom filter factor override.
         * Resets custom factor to 1.0 and clears label.
         * @returns {void}
         * @fires updateCalculations - Recalculates without custom factor
         * @fires updateDisplay - Updates UI
         * @example
         * this.clearCustomFilterOverride(); // Remove custom filter factor
         */
        clearCustomFilterOverride() {
          this.customBankLabel = "";
          this.customBankFactor = 1.0;
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method applyNewTime
         * @description Applies calculated time to CALC tab base time slider.
         * Clamps time to 1-50 seconds range, updates slider, and triggers calculator update.
         * @returns {void}
         * @fires baseTimeSlider.value - Updates base time slider
         * @fires incrementalTimer.updateFromSliders - Syncs calculator
         * @fires playBeep - Audio feedback
         * @fires setTimeout - Visual button feedback
         * @example
         * this.applyNewTime(); // Apply calculated time to CALC tab
         */
        applyNewTime() {
          const newBaseTime = this.newAdjustedTime;
          const baseTimeSlider = document.getElementById("baseTimeSlider");
          const clampedTime = Math.max(1, Math.min(50, newBaseTime));
          baseTimeSlider.value = clampedTime.toFixed(1);

          this.incrementalTimer.updateFromSliders();
          playBeep(800, 0.1, 0.3);

          const btn = this.applyHeightTimeBtn;
          const originalText = btn.textContent;
          btn.textContent = "Applied!";
          btn.classList.add("active");

          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove("active");
          }, 1000);
        }
      }

      /**
       * @class CustomFilterBankManager
       * @classdesc Manages custom filter banks for contrast control in exposure calculations.
       * Provides user-defined filter factors that can be applied to the EnlargerHeightCalculator.
       * Supports 3 groups (A, B, C) with 12 slots each for storing custom contrast factors.
       *
       * @property {EnlargerHeightCalculator} calculator - Reference to main calculator
       * @property {Array} groups - Array of filter bank groups (max 3)
       * @property {number} currentGroupIndex - Currently selected group (0-2)
       * @property {HTMLElement} groupSelect - Dropdown for group selection
       * @property {HTMLElement} groupNameInput - Input for group name
       * @property {HTMLElement} rowsContainer - Container for filter rows
       *
       * @description
       * **Purpose:** Allows users to store custom contrast factors (e.g., for variable contrast papers,
       * custom filter sets, or experimental multipliers) and quickly apply them to calculations.
       *
       * **Structure:**
       * - 3 Groups (A, B, C) - Each can have a custom name
       * - 12 Slots per group - Each slot has a label and value (factor)
       * - Values persist in localStorage via StorageManager
       * - Can be exported/imported with all app data
       *
       * **Integration:**
       * - Connects to EnlargerHeightCalculator via applyCustomFilterFactor()
       * - Updates calculator's customBankFactor and customBankLabel
       * - Multiplies into combined factor: Custom Factor × Other Factors
       *
       * @example
       * // Initialize manager
       * const filterManager = new CustomFilterBankManager(heightCalculator);
       *
       * // Apply a custom factor
       * filterManager.calculator.applyCustomFilterFactor('My Filter', 1.5);
       *
       * // Save custom bank data
       * filterManager.save();
       */
      class CustomFilterBankManager {
        /**
         * @constructor
         * @description Creates a CustomFilterBankManager instance.
         * Loads saved filter banks from localStorage, initializes UI elements,
         * and sets up event listeners.
         * @param {EnlargerHeightCalculator} enlargerCalculator - Reference to main calculator
         * @property {Function} normalize - Validates and normalizes bank data
         * @property {Function} bindEvents - Sets up UI event listeners
         * @property {Function} render - Updates UI display
         */
        constructor(enlargerCalculator) {
          this.calculator = enlargerCalculator;
          this.groups = this.normalize(StorageManager.loadCustomFilterBanks());
          this.currentGroupIndex = 0;

          this.groupSelect = document.getElementById("customFilterGroup");
          this.groupNameInput = document.getElementById(
            "customFilterGroupName"
          );
          this.rowsContainer = document.getElementById("customFilterRows");

          this.bindEvents();
          this.render();
        }

        /**
         * @method normalize
         * @description Validates and normalizes filter bank data from localStorage.
         * Ensures data structure is valid, pads to 3 groups with 12 slots each,
         * and applies default values where needed.
         * @param {Array} banks - Raw bank data from storage
         * @returns {Array} Normalized array of 3 groups with 12 slots each
         * @fires getDefaultCustomFilterBanks - Gets default structure
         * @example
         * const normalized = this.normalize(rawData); // Validate and pad data
         */
        normalize(banks) {
          const defaults = getDefaultCustomFilterBanks();
          if (!Array.isArray(banks)) return defaults;

          const normalized = banks.slice(0, 3).map((group, idx) => {
            const base = defaults[idx] || defaults[0];
            const name =
              (group && typeof group.name === "string" && group.name.trim()) ||
              base.name;
            const slots = Array.isArray(group?.slots) ? group.slots : [];
            const paddedSlots = [...slots];
            while (paddedSlots.length < 12) {
              paddedSlots.push({
                label: base.slots[paddedSlots.length].label,
                value: 1.0,
              });
            }
            return {
              name,
              slots: paddedSlots.slice(0, 12).map((slot, slotIdx) => ({
                label:
                  (slot &&
                    typeof slot.label === "string" &&
                    slot.label.trim()) ||
                  base.slots[slotIdx].label,
                value:
                  typeof slot?.value === "number" && slot.value > 0
                    ? slot.value
                    : 1.0,
              })),
            };
          });

          while (normalized.length < 3) {
            normalized.push(defaults[normalized.length]);
          }

          return normalized;
        }

        /**
         * @method bindEvents
         * @description Sets up all UI event listeners for the filter bank interface.
         * Handles group selection, name changes, slot value updates, and "Use" button clicks.
         * @returns {void}
         * @fires addEventListener - Binds change/input/click events
         * @fires renderGroupHeader - Updates group display
         * @fires renderRows - Updates slot rows
         * @fires save - Persists changes
         * @fires calculator.applyCustomFilterFactor - Applies factor to calculator
         * @example
         * this.bindEvents(); // Set up all UI interactions
         */
        bindEvents() {
          if (this.groupSelect) {
            this.groupSelect.addEventListener("change", () => {
              this.currentGroupIndex =
                parseInt(this.groupSelect.value, 10) || 0;
              this.renderGroupHeader();
              this.renderRows();
            });
          }

          if (this.groupNameInput) {
            this.groupNameInput.addEventListener("input", (e) => {
              const name = e.target.value || "Group";
              this.groups[this.currentGroupIndex].name = name;
              this.save();
              this.renderGroupHeader();
            });
          }

          if (this.rowsContainer) {
            this.rowsContainer.addEventListener("input", (e) => {
              const row = e.target.closest(".custom-filter-row");
              if (!row) return;
              const idx = parseInt(row.getAttribute("data-index"), 10);
              const role = e.target.getAttribute("data-role");
              if (Number.isNaN(idx) || idx < 0 || idx >= 12) return;

              if (role === "name") {
                this.groups[this.currentGroupIndex].slots[idx].label =
                  e.target.value || `Slot ${idx + 1}`;
                this.save();
              } else if (role === "value") {
                const val = parseFloat(e.target.value);
                if (val && val > 0) {
                  this.groups[this.currentGroupIndex].slots[idx].value = val;
                  this.save();
                }
              }
            });

            this.rowsContainer.addEventListener("click", (e) => {
              const btn = e.target.closest("button[data-role='use']");
              if (!btn) return;
              const row = btn.closest(".custom-filter-row");
              if (!row) return;
              const idx = parseInt(row.getAttribute("data-index"), 10);
              const slot = this.groups[this.currentGroupIndex].slots[idx];
              if (!slot) return;
              this.calculator.applyCustomFilterFactor(
                slot.label || `Slot ${idx + 1}`,
                slot.value
              );
              btn.textContent = "Using";
              btn.disabled = true;
              setTimeout(() => {
                btn.textContent = "Use";
                btn.disabled = false;
              }, 800);
            });
          }
        }

        /**
         * @method render
         * @description Updates the entire UI display for the filter bank.
         * Calls renderGroupHeader() and renderRows() to update all visual elements.
         * @returns {void}
         * @fires renderGroupHeader - Updates group selector and name
         * @fires renderRows - Updates slot rows
         * @example
         * this.render(); // Refresh entire UI
         */
        render() {
          this.renderGroupHeader();
          this.renderRows();
        }

        /**
         * @method renderGroupHeader
         * @description Updates the group selector dropdown and name input.
         * Populates options for all 3 groups and sets current group name.
         * @returns {void}
         * @fires Element.innerHTML - Updates group selector options
         * @fires Element.value - Updates name input value
         * @example
         * this.renderGroupHeader(); // Update group display
         */
        renderGroupHeader() {
          if (!this.groupSelect || !this.groupNameInput) return;
          this.groupSelect.innerHTML = this.groups
            .map(
              (g, idx) =>
                `<option value="${idx}" ${
                  idx === this.currentGroupIndex ? "selected" : ""
                }>${g.name || `Group ${idx + 1}`}</option>`
            )
            .join("");
          const current = this.groups[this.currentGroupIndex];
          this.groupNameInput.value = current.name;
        }

        /**
         * @method renderRows
         * @description Renders all 12 filter slots for the current group.
         * Creates HTML for each slot with name input, value input, and "Use" button.
         * @returns {void}
         * @fires Element.innerHTML - Updates rows container
         * @example
         * this.renderRows(); // Update slot display
         */
        renderRows() {
          if (!this.rowsContainer) return;
          const current = this.groups[this.currentGroupIndex];
          const rowsHtml = current.slots
            .map(
              (slot, idx) => `
                <div class="custom-filter-row" data-index="${idx}">
                  <input
                    type="text"
                    data-role="name"
                    value="${slot.label || `Slot ${idx + 1}`}"
                    aria-label="Custom filter name ${idx + 1}"
                  />
                  <input
                    type="number"
                    data-role="value"
                    step="0.01"
                    min="0.001"
                    value="${(slot.value || 1).toFixed(2)}"
                    aria-label="Custom filter value ${idx + 1}"
                  />
                  <button type="button" data-role="use">Use</button>
                </div>
              `
            )
            .join("");
          this.rowsContainer.innerHTML = rowsHtml;
        }

        /**
         * @method save
         * @description Saves current filter bank data to localStorage.
         * Persists all groups and slots via StorageManager.
         * @returns {void}
         * @fires StorageManager.saveCustomFilterBanks - Saves to localStorage
         * @example
         * this.save(); // Persist changes
         */
        save() {
          StorageManager.saveCustomFilterBanks(this.groups);
        }

        /**
         * @method replaceData
         * @description Replaces all filter bank data (used during import).
         * Normalizes new data, resets to first group, and updates UI.
         * @param {Array} banks - New filter bank data
         * @returns {void}
         * @fires normalize - Validates and normalizes data
         * @fires render - Updates UI
         * @example
         * // During data import
         * this.replaceData(importedBanks);
         */
        replaceData(banks) {
          this.groups = this.normalize(banks);
          this.currentGroupIndex = 0;
          this.render();
        }
      }

      // F-Stop Test Strip Generator Class with both Cumulative and Incremental methods and countdown AND AUTO ADVANCE
      // F-Stop Test Strip Generator - Profile Management Functions
      // These need to be defined before the class for proper scope access
      function getSelectedFromSeg(containerId) {
        const cont = document.getElementById(containerId);
        if (!cont) return null;
        const btn =
          cont.querySelector(".segmented-btn.active") ||
          cont.querySelector('.segmented-btn[aria-pressed="true"]');
        return btn ? parseInt(btn.dataset.denom, 10) : null;
      }
      function setActiveSeg(containerOrId, d) {
        const cont =
          typeof containerOrId === "string"
            ? document.getElementById(containerOrId)
            : containerOrId;
        if (!cont) return;
        Array.from(cont.querySelectorAll(".segmented-btn")).forEach((b) => {
          const bd = parseInt(b.dataset.denom, 10);
          const active = bd === d;
          b.classList.toggle("active", active);
          b.setAttribute("aria-pressed", active ? "true" : "false");
        });
      }
      function initSegControl(containerId) {
        const cont = document.getElementById(containerId);
        if (!cont) return;
        cont.addEventListener("click", (e) => {
          const btn = e.target.closest(".segmented-btn");
          if (!btn) return;
          const d = parseInt(btn.dataset.denom, 10);
          setActiveSeg(cont, d);
          applyDenomChange(d);
        });
      }

      // applyDenomChange now takes numeric denom and rescales sliders to preserve absolute stop values
      function applyDenomChange(d) {
        const newDenom = parseInt(d, 10) || 3;
        const prevDenom =
          window.stopDenominator ||
          (settingsManager && settingsManager.settings.stopDenominator) ||
          3;

        // If denom changed, rescale relevant sliders so the same absolute stop is preserved
        if (newDenom !== prevDenom) {
          // Rescale calculator stop slider (stopSlider values are fractional-step counts)
          const stopSlider = document.getElementById("stopSlider");
          if (stopSlider) {
            const oldVal = parseInt(stopSlider.value, 10) || 0;
            const stopInStops = oldVal / prevDenom; // current stop in full stops
            const newVal = Math.round(stopInStops * newDenom);
            stopSlider.value = newVal;
            // Trigger input handler to update displays
            stopSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }

          // Rescale test increment slider (step increments expressed in fractional-step counts)
          const testInc = document.getElementById("testIncrementSlider");
          if (testInc) {
            const oldInc = parseInt(testInc.value, 10) || 0;
            const incInStops = oldInc / prevDenom;
            let newInc = Math.round(incInStops * newDenom);
            const min = parseInt(testInc.min, 10) || 1;
            const max = parseInt(testInc.max, 10) || 99;
            newInc = Math.max(min, Math.min(max, newInc));
            testInc.value = newInc;
            testInc.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }

        window.stopDenominator = newDenom;

        // Persist setting and keep UI in sync
        if (settingsManager) {
          settingsManager.settings.stopDenominator = newDenom;
          StorageManager.saveSettings(settingsManager.settings);
        }
        const settingsSel = document.getElementById("settingStopIncrement");
        if (settingsSel) settingsSel.value = newDenom;
        // Update assistive live region
        try {
          const live = document.getElementById("settingsLiveStatus");
          if (live)
            live.textContent = `Default stop increment set to ${denomLabel(
              newDenom
            )}`;
        } catch (e) {}

        // Reflect change in segmented controls (if not already set) - keeps buttons active
        setActiveSeg("calcIncrementSeg", newDenom);
        setActiveSeg("testIncrementSeg", newDenom);

        if (window.incrementalTimer) {
          window.incrementalTimer.updateCalculations();
          window.incrementalTimer.updateAllDisplays();
        }
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.generateSteps();
          window.fstopTestGenerator.updateDisplay();
        }
        updateAllRulers();
        updateChart();
      }

      // Helper: render/refresh rulers and denominator handling for stops
      /**
       * @function renderRuler
       * @description Renders a visual ruler showing f-stop values between min and max steps.
       * Creates a horizontal scale with formatted stop values for visual reference.
       * @param {string} containerId - ID of the container element to render ruler in
       * @param {number} minStep - Minimum stop value (can be negative)
       * @param {number} maxStep - Maximum stop value
       * @returns {void}
       * @throws {Error} If container not found
       * @fires Element.setAttribute - Sets aria-label
       * @fires Element.innerHTML - Clears and rebuilds ruler
       * @fires formatStop - Formats stop values for display
       * @example
       * renderRuler("calcStopRuler", -6, 6); // Render ruler from -6 to +6 stops
       */
      function renderRuler(containerId, minStep, maxStep) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.setAttribute("aria-label", "Stops scale");
        const total = maxStep - minStep;
        const frag = document.createDocumentFragment();
        for (let i = 0; i <= total; i++) {
          const step = minStep + i;
          const span = document.createElement("span");
          span.style.fontSize = "0.7rem";
          span.style.color = "var(--text-secondary)";
          span.style.flex = "1";
          span.style.textAlign = "center";
          span.textContent = formatStop(step);
          span.setAttribute("aria-hidden", "true");
          frag.appendChild(span);
        }
        container.innerHTML = "";
        container.appendChild(frag);
      }

      /**
       * @function updateAllRulers
       * @description Updates all visual rulers in the UI.
       * Renders the calculator stop ruler and test increment ruler with current settings.
       * @returns {void}
       * @fires renderRuler - Renders calculator ruler
       * @fires Element.getElementById - Gets test increment ruler
       * @fires Element.innerHTML - Clears and rebuilds rulers
       * @fires formatStopCompact - Formats stop values for compact display
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * updateAllRulers(); // Update all visual rulers
       */
      function updateAllRulers() {
        renderRuler("calcStopRuler", -6, 6);

        const testContainer = document.getElementById("testIncrementRuler");
        if (!testContainer) return;
        const min = parseInt(
          document.getElementById("testIncrementSlider").min,
          10
        );
        const max = parseInt(
          document.getElementById("testIncrementSlider").max,
          10
        );
        const total = max - min;
        const frag = document.createDocumentFragment();
        for (let i = 0; i <= total; i++) {
          const val = min + i;
          const span = document.createElement("span");
          span.style.fontSize = "0.7rem";
          span.style.color = "var(--text-secondary)";
          span.style.flex = "1";
          span.style.textAlign = "center";
          const denom = window.stopDenominator || 3;
          const stopValue = val / denom;
          span.textContent = formatStopCompact(stopValue);
          frag.appendChild(span);
        }
        testContainer.innerHTML = "";
        testContainer.appendChild(frag);
      }

      /**
       * @class FStopTestStripGenerator
       * @classdesc Generates and manages f-stop test strips with cumulative or incremental methods.
       * Supports auto-advance mode, countdown integration, relay triggering, and profile management.
       *
       * @property {number} baseTime - Base exposure time in seconds
       * @property {number} stepIncrement - Increment value (1-9)
       * @property {number} numSteps - Number of test steps (default: 6)
       * @property {string} method - 'cumulative' or 'incremental'
       * @property {boolean} autoAdvance - Auto-advance between steps
       * @property {number} autoAdvanceDelay - Delay between steps in milliseconds
       * @property {Array} steps - Generated test steps array
       * @property {number} currentStep - Current step index (0-based)
       * @property {number} currentStepTime - Time remaining in current step
       * @property {boolean} isRunning - Test is running
       * @property {boolean} isPaused - Test is paused
       * @property {boolean} isWaitingForNextStep - Waiting for user to proceed
       * @property {DriftCorrectedTimer|null} interval - Timer instance
       * @property {number|null} lastBeepSecond - Last second that beep played
       * @property {Object|null} countdownCleanup - Stores display state during countdown
       *
       * @description
       * **Test Strip Methods:**
       * - **Cumulative**: Each strip is exposed for its total time (10s, 14s, 19s, etc.)
       * - **Incremental**: Each strip adds time to previous (10s, 4s, 5s, etc.)
       *
       * **F-Stop Formula**: time = baseTime × 2^(stop/denominator)
       *
       * **Auto-Advance**: Automatically proceeds to next step after configurable delay
       *
       * **Integration:**
       * - Uses CountdownManager before starting
       * - Triggers RelayManager for each step
       * - Click-to-apply: Click steps to send time to CALC tab
       * - Profile management: Save/load test configurations
       *
       * @example
       * // Initialize generator
       * const testGen = new FStopTestStripGenerator();
       *
       * // Generate and display test strip
       * testGen.generateSteps();
       * testGen.updateDisplay();
       *
       * // Start test
       * await testGen.start();
       *
       * // Apply step to CALC tab
       * testGen.applyStepToCalc(2); // Apply 3rd step time
       */
      class FStopTestStripGenerator {
        /**
         * @constructor
         * @description Creates a FStopTestStripGenerator instance.
         * Initializes all properties, generates steps, updates UI, and loads profiles.
         * @property {number} baseTime - Base exposure time (default: 10.0s)
         * @property {number} stepIncrement - Increment in fractional steps (default: 1)
         * @property {number} numSteps - Number of test steps (default: 6)
         * @property {string} method - 'cumulative' or 'incremental' (default: 'cumulative')
         * @property {boolean} autoAdvance - Auto-advance mode (default: false)
         * @property {number} autoAdvanceDelay - Delay in ms (default: 1000)
         */
        constructor() {
          this.baseTime = 10.0;
          this.stepIncrement = 1; // 1 = one fractional step (denominator controlled by stopDenominator)
          // Denominator applied in calculations; default to 3 (1/3 stop)
          window.stopDenominator = window.stopDenominator || 3;
          this.numSteps = 6;
          this.method = "cumulative"; // 'cumulative' or 'incremental'
          this.autoAdvance = false; // NEW: Auto advance mode
          this.autoAdvanceDelay = 1000; // Delay between steps in ms

          if (settingsManager) {
            this.autoAdvance = settingsManager.settings.autoAdvance || false;
            this.autoAdvanceDelay =
              (settingsManager.settings.autoAdvanceDelay || 1) * 1000; // Convert to ms
          } else {
            this.autoAdvance = false;
            this.autoAdvanceDelay = 1000; // Default 1 second
          }

          this.currentStep = 0;
          this.steps = [];
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.interval = null;
          this.lastBeepSecond = null;
          this.currentStepTime = 0;

          this.init();
          this.generateSteps();
          this.updateDisplay();
          this.updateInstructions();

          // Initialize countdown cleanup properties
          this.countdownCleanup = null;
          this.countdownCleanupTimeout = null;

          // Load current test strip profile from storage
          appState.persistent.currentTestStripProfile =
            StorageManager.loadCurrentTestStripProfile();

          // Initialize test strip profile list
          this.updateTestStripProfileList();
        }

        /**
         * @method init
         * @description Initializes UI elements and event listeners for test strip generator.
         * Binds all sliders, buttons, toggles, and method selectors to their handlers.
         * @returns {void}
         * @fires addEventListener - Binds input/change/click events
         * @fires updateFromControls - Called by sliders
         * @fires toggle - Called by start/pause button
         * @fires stopCurrentTest - Called by stop button
         * @fires reset - Called by reset button
         * @fires setMethod - Called by method selector
         * @fires setAutoAdvance - Called by auto-advance toggle
         * @example
         * this.init(); // Set up all UI bindings
         */
        init() {
          // Get elements
          this.testBaseSlider = document.getElementById("testBaseSlider");
          this.testIncrementSlider = document.getElementById(
            "testIncrementSlider"
          );
          this.testStepsSlider = document.getElementById("testStepsSlider");
          this.testBaseValue = document.getElementById("testBaseValue");
          this.testIncrementValue =
            document.getElementById("testIncrementValue");
          this.testStepsValue = document.getElementById("testStepsValue");
          this.testSequenceInfo = document.getElementById("testSequenceInfo");
          this.testTimeRange = document.getElementById("testTimeRange");
          this.testStripPreview = document.getElementById("testStripPreview");

          // NEW: Auto advance toggle elements
          this.autoAdvanceToggle = document.getElementById("autoAdvanceToggle");
          this.autoAdvanceValue = document.getElementById("autoAdvanceValue");
          this.autoAdvanceDescription = document.getElementById(
            "autoAdvanceDescription"
          );

          // Timer elements
          this.testTimerStatus = document.getElementById("testTimerStatus");
          this.testTimerDisplay = document.getElementById("testTimerDisplay");
          this.currentStepDisplay =
            document.getElementById("currentStepDisplay");
          this.currentTimeDisplay =
            document.getElementById("currentTimeDisplay");
          this.currentStopDisplay =
            document.getElementById("currentStopDisplay");
          this.stepSizeDisplay = document.getElementById("stepSizeDisplay");
          this.timeMultiplierDisplay = document.getElementById(
            "timeMultiplierDisplay"
          );
          this.totalTestTimeDisplay = document.getElementById(
            "totalTestTimeDisplay"
          );
          this.testProgressBar = document.getElementById("testProgressBar");
          this.progressStart = document.getElementById("progressStart");
          this.progressMiddle = document.getElementById("progressMiddle");
          this.progressEnd = document.getElementById("progressEnd");

          // Control buttons
          this.startTestStripBtn = document.getElementById("startTestStrip");
          this.stopTestTimerBtn = document.getElementById("stopTestTimer");
          this.resetTestTimerBtn = document.getElementById("resetTestTimer");

          // Sound controls
          this.testWarningBeep = document.getElementById("testWarningBeep");
          this.testStepBeep = document.getElementById("testStepBeep");
          this.testEndBeep = document.getElementById("testEndBeep");

          // Preview controls
          this.previewMode = document.getElementById("previewMode");

          // Add event listeners
          this.testBaseSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.testIncrementSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.testStepsSlider.addEventListener("input", () =>
            this.updateFromControls()
          );

          // NEW: Auto advance toggle event
          this.autoAdvanceToggle.addEventListener("change", () => {
            this.setAutoAdvance(this.autoAdvanceToggle.checked);
          });

          // In the init() method of FStopTestStripGenerator (around line 2300), update the startTestStripBtn event listener:
          this.startTestStripBtn.addEventListener("click", async () => {
            await this.toggle();
          });
          this.stopTestTimerBtn.addEventListener("click", () =>
            this.stopCurrentTest()
          );
          this.resetTestTimerBtn.addEventListener("click", () => this.reset());

          this.previewMode.addEventListener("change", () =>
            this.updatePreview()
          );

          // Method selector event listeners
          document
            .querySelectorAll(".toggle-btn[data-method]")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                const method = e.target.getAttribute("data-method");
                this.setMethod(method);
              });
            });

          // Audio context initialization
          this.startTestStripBtn.addEventListener("click", initAudioContext);
        }

        /**
         * @method setAutoAdvance
         * @description Enables or disables auto-advance mode.
         * When enabled, automatically proceeds to next step after configured delay.
         * @param {boolean} enabled - Whether to enable auto-advance
         * @returns {void}
         * @fires updateAutoAdvanceDisplay - Updates UI
         * @fires updateInstructions - Updates help text
         * @fires nextStep - If currently waiting between steps
         * @example
         * this.setAutoAdvance(true); // Enable auto-advance
         * this.setAutoAdvance(false); // Disable auto-advance
         */
        setAutoAdvance(enabled) {
          this.autoAdvance = enabled;
          this.updateAutoAdvanceDisplay();
          this.updateInstructions();

          // If test is running and auto advance is enabled, check if we should proceed
          if (this.isRunning && !this.isPaused && this.autoAdvance) {
            // If we're currently paused between steps, start next step
            if (
              this.currentStepTime <= 0 &&
              this.currentStep < this.steps.length - 1
            ) {
              this.nextStep();
            }
          }
        }

        /**
         * @method setAutoAdvanceDelay
         * @description Sets the delay between steps in auto-advance mode.
         * @param {number} delayMs - Delay in milliseconds
         * @returns {void}
         * @fires updateAutoAdvanceDisplay - Updates UI
         * @fires updateInstructions - Updates help text
         * @example
         * this.setAutoAdvanceDelay(2000); // 2 second delay
         */
        setAutoAdvanceDelay(delayMs) {
          this.autoAdvanceDelay = delayMs;
          this.updateAutoAdvanceDisplay();
          this.updateInstructions();
        }

        /**
         * @method updateAutoAdvanceDisplay
         * @description Updates the auto-advance UI display elements.
         * Shows ON/OFF status, delay time, and updates toggle state.
         * @returns {void}
         * @fires Element.textContent - Updates status text
         * @fires Element.checked - Updates toggle state
         * @example
         * this.updateAutoAdvanceDisplay(); // Refresh UI
         */
        updateAutoAdvanceDisplay() {
          if (this.autoAdvanceValue) {
            this.autoAdvanceValue.textContent = this.autoAdvance ? "ON" : "OFF";
          }
          if (this.autoAdvanceDescription) {
            const delaySec = this.autoAdvanceDelay / 1000;
            this.autoAdvanceDescription.textContent = this.autoAdvance
              ? `Automatically advance to next step (${delaySec}s delay)`
              : "Pause after each step";
          }
          if (this.autoAdvanceToggle) {
            this.autoAdvanceToggle.checked = this.autoAdvance;
          }
        }

        /**
         * @method updateInstructions
         * @description Updates instruction text based on method and auto-advance mode.
         * Shows different instructions for cumulative vs incremental methods.
         * Theme-aware styling for status text.
         * @returns {void}
         * @fires Element.textContent - Updates instruction text
         * @fires Element.style.color - Updates theme-aware colors
         * @example
         * this.updateInstructions(); // Refresh instruction display
         */
        updateInstructions() {
          const cumulativeText = document.getElementById(
            "cumulativeAdvanceText"
          );
          const incrementalText = document.getElementById(
            "incrementalAdvanceText"
          );
          const statusText = document.getElementById("autoAdvanceStatus");

          const delaySec = this.autoAdvanceDelay / 1000;

          if (this.autoAdvance) {
            cumulativeText.textContent = `Auto-advance: ON - Next step starts in ${delaySec}s`;
            incrementalText.textContent = `Auto-advance: ON - Slide mask, next step in ${delaySec}s`;
            statusText.textContent = `Current: Auto Advance (${delaySec}s delay) - press 'A' to toggle`;
          } else {
            cumulativeText.textContent =
              "Auto-advance: OFF - Press Next Step between exposures";
            incrementalText.textContent =
              "Auto-advance: OFF - Press Next Step after sliding mask";
            statusText.textContent =
              "Current: Manual Advance - press Next Step button";
          }

          // Update status text color based on theme
          if (document.body.classList.contains("light-scheme")) {
            statusText.style.color = this.autoAdvance
              ? "var(--accent)"
              : "var(--accent)";
          } else if (document.body.classList.contains("day-scheme")) {
            statusText.style.color = this.autoAdvance
              ? "var(--accent)"
              : "var(--accent)";
          } else {
            statusText.style.color = this.autoAdvance ? "#f00" : "#900";
          }
        }

        /**
         * @method setMethod
         * @description Sets the test strip method (cumulative or incremental).
         * Updates UI, regenerates steps, and resets if test is running.
         * @param {string} method - 'cumulative' or 'incremental'
         * @returns {void}
         * @fires generateSteps - Regenerates test steps
         * @fires updateDisplay - Updates UI
         * @fires updateInstructions - Updates help text
         * @fires stopCurrentTest - Stops running test
         * @fires reset - Resets test state
         * @example
         * this.setMethod('cumulative'); // Use cumulative method
         * this.setMethod('incremental'); // Use incremental method
         */
        setMethod(method) {
          if (this.method === method) return;

          this.method = method;

          // Update UI
          document
            .querySelectorAll(".toggle-btn[data-method]")
            .forEach((btn) => {
              btn.classList.remove("active");
              if (btn.getAttribute("data-method") === method) {
                btn.classList.add("active");
              }
            });

          document.getElementById("testMethodValue").textContent =
            method === "cumulative" ? "Cumulative" : "Incremental";

          // Show appropriate instructions
          if (method === "cumulative") {
            document.querySelector(".cumulative-instructions").style.display =
              "block";
            document.querySelector(".incremental-instructions").style.display =
              "none";
          } else {
            document.querySelector(".cumulative-instructions").style.display =
              "none";
            document.querySelector(".incremental-instructions").style.display =
              "block";
          }

          // Regenerate steps with new method
          this.generateSteps();
          this.updateDisplay();
          this.updateInstructions();

          // If running, stop and reset
          if (this.isRunning || this.isPaused) {
            this.stopCurrentTest();
            this.reset();
          }
        }

        /**
         * @method updateFromControls
         * @description Reads slider values and updates test strip configuration.
         * Regenerates steps and updates display.
         * @returns {void}
         * @fires generateSteps - Regenerates test steps
         * @fires updateDisplay - Updates UI
         * @example
         * // Called when sliders change
         * this.updateFromControls();
         */
        updateFromControls() {
          this.baseTime = parseFloat(this.testBaseSlider.value);
          this.stepIncrement = parseInt(this.testIncrementSlider.value);
          this.numSteps = parseInt(this.testStepsSlider.value);

          this.generateSteps();
          this.updateDisplay();
        }

        /**
         * @method generateSteps
         * @description Generates test strip steps based on current parameters.
         * Supports both cumulative and incremental methods with f-stop precision.
         * @returns {void}
         * @fires window.stopDenominator - Reads denominator setting
         * @fires Math.pow - Calculates f-stop times
         * @description Step Structure:
         * - step: Step number (1-based)
         * - stop: F-stop value
         * - time: Time for this step (incremental or cumulative)
         * - cumulativeTime: Total time (cumulative method only)
         * - incrementalTime: Time for this step (incremental method)
         * - totalExposure: Total exposure on paper
         * @example
         * this.generateSteps(); // Regenerate steps after parameter change
         */
        generateSteps() {
          this.steps = [];

          if (this.method === "cumulative") {
            // Existing cumulative method
            let totalTime = 0;
            for (let i = 0; i < this.numSteps; i++) {
              const denom = window.stopDenominator || 3;
              const stopValue = (i * this.stepIncrement) / denom; // Convert to stop value
              const time = this.baseTime * Math.pow(2, stopValue);
              totalTime += time;

              this.steps.push({
                step: i + 1,
                stop: stopValue,
                time: time,
                cumulativeTime: totalTime,
                incrementalTime: time, // Same as time for cumulative
                totalExposure: time, // Total exposure for this step
              });
            }
          } else {
            // New incremental method
            let previousTotalTime = this.baseTime;

            for (let i = 0; i < this.numSteps; i++) {
              const denom = window.stopDenominator || 3;
              const stopValue = (i * this.stepIncrement) / denom;
              const totalExposure = this.baseTime * Math.pow(2, stopValue);

              // For first step: incremental time = base time
              // For subsequent steps: incremental time = difference between current and previous total
              let incrementalTime;
              if (i === 0) {
                incrementalTime = this.baseTime;
              } else {
                const previousStop = ((i - 1) * this.stepIncrement) / denom;
                const previousTotal = this.baseTime * Math.pow(2, previousStop);
                incrementalTime = totalExposure - previousTotal;
              }

              this.steps.push({
                step: i + 1,
                stop: stopValue,
                time: incrementalTime, // Time to expose THIS step
                cumulativeTime: 0, // Not used in incremental method
                incrementalTime: incrementalTime,
                totalExposure: totalExposure, // Total exposure on paper for this strip
              });

              previousTotalTime = totalExposure;
            }
          }
        }

        getIncrementLabel(increment) {
          return formatStopCompact(increment / (window.stopDenominator || 3));
        }

        formatStop(stopValue) {
          const denom = window.stopDenominator || 3;
          const whole = Math.floor(stopValue);
          const fraction = stopValue - whole;
          const tolerance = 0.0001;

          if (Math.abs(fraction) < tolerance) return `${whole}.0`;
          if (denom === 2) {
            if (Math.abs(fraction - 0.5) < tolerance) return `${whole}½`;
          } else if (denom === 3) {
            if (Math.abs(fraction - 1 / 3) < tolerance) return `${whole}⅓`;
            if (Math.abs(fraction - 2 / 3) < tolerance) return `${whole}⅔`;
          } else if (denom === 4) {
            if (Math.abs(fraction - 0.25) < tolerance) return `${whole}¹⁄₄`;
            if (Math.abs(fraction - 0.5) < tolerance) return `${whole}²⁄₄`;
            if (Math.abs(fraction - 0.75) < tolerance) return `${whole}³⁄₄`;
          }

          return `${stopValue.toFixed(1)}`;
        }

        /**
         * @method updateDisplay
         * @description Updates all UI elements with current test strip configuration.
         * Displays control values, sequence info, time ranges, progress labels, and preview.
         * @returns {void}
         * @fires updatePreview - Updates visual preview
         * @fires Element.textContent - Updates all display elements
         * @fires Element.style.width - Updates progress bar
         * @example
         * this.updateDisplay(); // Refresh all UI elements
         */
        updateDisplay() {
          // Update control values
          this.testBaseValue.textContent = `${this.baseTime.toFixed(1)}s`;
          this.testIncrementValue.textContent = `${this.getIncrementLabel(
            this.stepIncrement
          )} stop`;
          this.testStepsValue.textContent = this.numSteps;

          // Update sequence info with method
          const methodText =
            this.method === "cumulative" ? "Cumulative" : "Incremental";
          this.testSequenceInfo.textContent = `${
            this.numSteps
          } steps × ${this.getIncrementLabel(
            this.stepIncrement
          )} stop (${methodText})`;

          // Update time range based on method
          let minTime, maxTime;
          if (this.method === "cumulative") {
            minTime = this.baseTime;
            maxTime = this.steps[this.steps.length - 1]?.time || this.baseTime;
            this.testTimeRange.textContent = `${minTime.toFixed(
              2
            )}s to ${maxTime.toFixed(2)}s`;

            // Update progress labels
            this.progressStart.textContent = `${minTime.toFixed(1)}s`;
            this.progressMiddle.textContent = `${(
              (minTime + maxTime) /
              2
            ).toFixed(1)}s`;
            this.progressEnd.textContent = `${maxTime.toFixed(1)}s`;
          } else {
            // For incremental method, show incremental times range
            minTime = this.steps[0]?.incrementalTime || this.baseTime;
            maxTime =
              this.steps[this.steps.length - 1]?.incrementalTime ||
              this.baseTime;
            this.testTimeRange.textContent = `Step times: ${minTime.toFixed(
              2
            )}s to ${maxTime.toFixed(2)}s`;

            // Show total exposure range for incremental method
            const minTotal = this.baseTime;
            const maxTotal =
              this.steps[this.steps.length - 1]?.totalExposure || this.baseTime;
            this.progressStart.textContent = `${minTotal.toFixed(1)}s`;
            this.progressMiddle.textContent = `${(
              (minTotal + maxTotal) /
              2
            ).toFixed(1)}s`;
            this.progressEnd.textContent = `${maxTotal.toFixed(1)}s`;
          }

          // Update preview
          this.updatePreview();

          // Update info displays
          if (this.steps.length > 0) {
            const totalTime = this.steps.reduce(
              (sum, step) => sum + step.time,
              0
            );
            this.totalTestTimeDisplay.textContent = `${totalTime.toFixed(1)}s`;

            // Update step size display
            const denom = window.stopDenominator || 3;
            const stepSize = this.stepIncrement / denom;
            this.stepSizeDisplay.textContent = `${stepSize.toFixed(1)} stops`;
          }
        }

        /**
         * @method updatePreview
         * @description Updates the visual test strip preview display.
         * Creates colored step elements with click-to-apply functionality.
         * Theme-aware coloring for dark/light/day schemes.
         * @returns {void}
         * @fires Element.innerHTML - Creates step elements
         * @fires Element.style.backgroundColor - Sets theme-aware colors
         * @fires addEventListener - Click handler for applyStepToCalc
         * @fires Element.style.width - Updates progress bar
         * @example
         * this.updatePreview(); // Refresh visual preview
         */
        updatePreview() {
          this.testStripPreview.innerHTML = "";
          const showTimes = this.previewMode.checked;

          this.steps.forEach((step, index) => {
            const stepEl = document.createElement("div");
            stepEl.className = "test-step";
            stepEl.dataset.step = step.step;
            stepEl.style.cursor = "pointer";

            // Calculate color intensity based on method
            if (this.method === "cumulative") {
              // Color based on total exposure (cumulative method)
              const maxTime = this.steps[this.steps.length - 1].time;
              const intensity = Math.min(
                100 + (step.time / maxTime) * 150,
                250
              );
              stepEl.style.backgroundColor = `rgb(${intensity}, 0, 0)`;
            } else {
              // Color based on total exposure on paper (incremental method)
              const maxTotal = this.steps[this.steps.length - 1].totalExposure;
              const intensity = Math.min(
                100 + (step.totalExposure / maxTotal) * 150,
                250
              );
              stepEl.style.backgroundColor = `rgb(${intensity}, 0, 0)`;
            }

            // Theme adjustments
            if (
              document.body.classList.contains("light-scheme") ||
              document.body.classList.contains("day-scheme")
            ) {
              // Create bigger steps: use index-based calculation for more distinct colors
              const stepIndex = index;
              const totalSteps = this.steps.length;
              // Use 50-250 range with bigger jumps between steps
              const greyIntensity = 50 + stepIndex * (150 / (totalSteps - 1));
              stepEl.style.backgroundColor = `rgb(${greyIntensity}, ${greyIntensity}, ${greyIntensity})`;
            }

            if (
              index === this.currentStep &&
              (this.isRunning || this.isPaused)
            ) {
              stepEl.classList.add("active");
            }

            // Store the total exposure time for this step
            // Both methods use totalExposure for consistency
            const timeValue = step.totalExposure;
            stepEl.dataset.time = timeValue;

            // Add click handler to apply this time to CALC tab
            stepEl.addEventListener("click", () => {
              this.applyStepToCalc(index);
            });

            if (showTimes) {
              if (this.method === "cumulative") {
                stepEl.innerHTML = `
                            <div class="step-time">${step.time.toFixed(
                              1
                            )}s</div>
                            <div class="step-stop">${this.formatStop(
                              step.stop
                            )}</div>
                        `;
              } else {
                stepEl.innerHTML = `
                            <div class="step-time">${step.time.toFixed(
                              1
                            )}s</div>
                            <div class="step-stop">+${this.getIncrementLabel(
                              this.stepIncrement
                            )}</div>
                            <div style="font-size: 0.4rem; color: var(--accent); margin-top: 1px;">
                                Total: ${step.totalExposure.toFixed(1)}s
                            </div>
                        `;
              }
            } else {
              stepEl.innerHTML = `
                        <div class="step-time">${step.step}</div>
                        <div class="step-stop">${this.getIncrementLabel(
                          this.stepIncrement
                        )}</div>
                    `;
            }

            this.testStripPreview.appendChild(stepEl);
          });

          // Update progress bar
          const progressFill = document.getElementById("progressFill");
          // Show progress including the current step being executed (currentStep is 0-indexed)
          const progressPercent =
            ((this.currentStep + 1) / this.steps.length) * 100;
          if (progressFill) {
            progressFill.style.width = `${progressPercent}%`;
          }
        }

        /**
         * @method start
         * @description Starts the test strip with countdown and relay triggering.
         * Performs countdown, triggers relay for first step, and begins timer.
         * @returns {Promise<void>} Resolves when countdown completes and test starts
         * @fires countdownManager.startCountdown - Visual/audio countdown
         * @fires startStep - Begins first step
         * @fires playBeep - Audio feedback
         * @fires updateStatus - Updates UI status
         * @example
         * await this.start(); // Start test strip
         */
        async start() {
          if (this.isRunning || this.steps.length === 0) return;

          // Disable buttons during countdown
          this.startTestStripBtn.disabled = true;
          this.stopTestTimerBtn.disabled = false; // Keep Stop enabled
          this.resetTestTimerBtn.disabled = true;

          // Start countdown
          const display = this.testTimerDisplay;
          const originalText = display.textContent;
          this.testTimerStatus.textContent = "COUNTDOWN STARTING...";

          await new Promise((resolve) => {
            window.countdownManager.startCountdown(display, () => {
              resolve();
            });
          });

          // Restore display and enable buttons
          display.textContent = originalText;
          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";

          // Continue with original start logic
          this.isRunning = true;
          this.isPaused = false;
          this.currentStep = 0;
          await this.startStep(); // Add await here

          this.startTestStripBtn.textContent = "Pause";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = false;
          this.resetTestTimerBtn.disabled = true;

          // Play start beep
          if (this.testStepBeep.checked) {
            playBeep(600, 0.1, 0.3);
          }
        }

        /**
         * @method triggerRelayForStep
         * @description Triggers the enlarger relay for a specific test step.
         * Only triggers if auto-trigger is enabled and step time is positive.
         * @param {number} stepTime - Exposure time for this step in seconds
         * @returns {Promise<void>} Resolves when relay trigger completes
         * @throws {Error} Logs error if relay trigger fails
         * @fires relayManager.triggerTimerRelay - Sends timer command to server
         * @example
         * await this.triggerRelayForStep(10.5); // Trigger for 10.5s
         */
        async triggerRelayForStep(stepTime) {
          if (
            window.relayManager &&
            window.relayManager.autoTrigger &&
            stepTime > 0
          ) {
            try {
              await window.relayManager.triggerTimerRelay(stepTime);
            } catch (error) {
              console.error("Failed to trigger relay for step:", error);
            }
          }
        }

        /**
         * @method startStep
         * @description Starts a single test strip step with relay triggering.
         * Updates UI displays, triggers relay, and starts interval timer.
         * @returns {Promise<void>} Resolves when step starts
         * @throws {Error} Logs error if relay trigger fails
         * @fires updatePreview - Updates visual preview
         * @fires triggerRelayForStep - Triggers enlarger
         * @fires startInterval - Begins countdown timer
         * @fires Element.textContent - Updates all displays
         * @example
         * await this.startStep(); // Start current step
         */
        async startStep() {
          if (this.currentStep >= this.steps.length) {
            this.complete();
            return;
          }

          const step = this.steps[this.currentStep];
          this.currentStepTime = step.time;
          this.lastBeepSecond = null;

          // Always show running status while the timer counts down
          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";

          this.currentStepDisplay.textContent = `${this.currentStep + 1}/${
            this.steps.length
          }`;

          if (this.method === "cumulative") {
            this.currentTimeDisplay.textContent = `${step.time.toFixed(2)}s`;
            this.currentStopDisplay.textContent = `${this.formatStop(
              step.stop
            )}`;
            this.timeMultiplierDisplay.textContent = `${Math.pow(
              2,
              step.stop
            ).toFixed(2)}×`;
          } else {
            this.currentTimeDisplay.textContent = `${step.time.toFixed(2)}s`;
            this.currentStopDisplay.textContent = `+${this.getIncrementLabel(
              this.stepIncrement
            )}`;

            const totalExposure = step.totalExposure;
            this.timeMultiplierDisplay.textContent = `${totalExposure.toFixed(
              1
            )}s total`;
          }

          this.testTimerDisplay.textContent = step.time.toFixed(2);

          this.updatePreview();

          // TRIGGER RELAY FOR THIS STEP - AWAIT HERE
          if (window.relayManager && window.relayManager.autoTrigger) {
            try {
              await window.relayManager.triggerTimerRelay(step.time);
            } catch (error) {
              console.error("Failed to trigger relay:", error);
            }
          }

          // Start the interval timer
          this.startInterval();
        }

        /**
         * @method startInterval
         * @description Starts the interval timer for the current step.
         * Decrements time by 0.1s intervals, updates display, plays warning beeps.
         * @returns {void}
         * @fires stepComplete - Called when step time reaches zero
         * @fires playBeep - Warning beeps at 3 seconds
         * @fires Element.textContent - Updates timer display
         * @fires Element.classList - Adds/removes warning class
         * @example
         * this.startInterval(); // Begin countdown for current step
         */
        startInterval() {
          this.interval = setInterval(() => {
            this.currentStepTime -= 0.1;

            if (this.currentStepTime <= 0) {
              this.currentStepTime = 0;
              this.stepComplete();
            } else {
              this.testTimerDisplay.textContent =
                this.currentStepTime.toFixed(2);

              // 3-second warning beep
              if (this.currentStepTime <= 3 && this.testWarningBeep.checked) {
                const currentSecond = Math.ceil(this.currentStepTime);

                if (
                  currentSecond !== this.lastBeepSecond &&
                  currentSecond <= 3 &&
                  currentSecond > 0
                ) {
                  this.lastBeepSecond = currentSecond;
                  playBeep(400, 0.1, 0.3);
                  this.testTimerDisplay.classList.add("warning");

                  setTimeout(() => {
                    this.testTimerDisplay.classList.remove("warning");
                  }, 300);
                }
              }
            }
          }, 100);
        }

        /**
         * @method stepComplete
         * @description Called when a step's timer reaches zero.
         * Handles auto-advance or manual advance mode, updates UI, and proceeds to next step.
         * @returns {void}
         * @fires updatePreview - Updates visual preview
         * @fires complete - If last step
         * @fires startStep - If auto-advance and more steps remain
         * @fires setTimeout - Delays next step in auto-advance mode
         * @fires playBeep - Step completion beep
         * @example
         * // Called automatically when step timer reaches zero
         * this.stepComplete();
         */
        stepComplete() {
          clearInterval(this.interval);

          // Play step complete beep
          if (this.testStepBeep.checked) {
            playBeep(800, 0.1, 0.3);
          }

          // Update preview to show completed step
          this.updatePreview();

          // Cancel any ongoing countdown (safety check)
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Determine next action based on auto advance setting
          if (this.autoAdvance && !this.isPaused) {
            // Auto advance: move to next step after configured delay
            this.currentStep++;

            if (this.currentStep < this.steps.length) {
              // Update status to show auto advance countdown
              const delaySec = this.autoAdvanceDelay / 1000;
              this.testTimerStatus.textContent = `Auto advancing in ${delaySec}s...`;

              // Start next step after configured delay
              setTimeout(() => {
                if (this.isRunning && !this.isPaused) {
                  this.startStep();
                }
              }, this.autoAdvanceDelay); // Use configured delay
            } else {
              this.complete();
            }
          } else {
            // Manual advance mode
            // Check if this was the last step
            if (this.currentStep >= this.steps.length - 1) {
              // Last step completed - finish immediately
              this.complete();
            } else {
              // More steps remain - pause and wait for user input
              this.isRunning = false; // Pause the timer
              this.isWaitingForNextStep = true; // Track waiting state
              this.testTimerStatus.textContent =
                "STEP COMPLETE - PRESS NEXT STEP";

              // Update Start button to act as Next Step and keep Stop enabled
              this.startTestStripBtn.textContent = "Next Step";
              this.stopTestTimerBtn.disabled = false;

              // Update step number to show current (completed) step
              this.currentStepDisplay.textContent = `${this.currentStep + 1}/${
                this.steps.length
              } (Completed)`;

              // Show instruction based on method
              if (this.method === "incremental") {
                this.testTimerStatus.textContent =
                  "SLIDE MASK → THEN PRESS NEXT STEP";
              }
            }
          }
        }

        /**
         * @method pause
         * @description Pauses the running test strip.
         * Stops the interval timer and updates UI to show paused state.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires restoreDisplayAfterCountdown - Restores display
         * @fires playBeep - Audio feedback
         * @fires Element.textContent - Updates status
         * @fires Element.classList - Removes warning class
         * @example
         * this.pause(); // Pause current test
         */
        pause() {
          if (!this.isRunning) return;

          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = true;

          this.testTimerStatus.textContent = "TEST STRIP PAUSED";
          this.startTestStripBtn.textContent = "Resume";
          this.testTimerDisplay.classList.remove("warning");

          playBeep(400, 0.1, 0.2);
        }

        /**
         * @method resume
         * @description Resumes a paused test strip.
         * Restarts the interval timer from the current step time.
         * @returns {void}
         * @fires startInterval - Resumes countdown
         * @fires Element.textContent - Updates status
         * @example
         * this.resume(); // Resume paused test
         */
        resume() {
          if (!this.isPaused) return;

          this.isRunning = true;
          this.isPaused = false;

          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";
          this.startTestStripBtn.textContent = "Pause";

          // RESUME from current time instead of restarting the step
          this.startInterval();
        }

        /**
         * @method stopCurrentTest
         * @description Stops the current test and resets to initial state.
         * Can be called at any time to abort the test.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires restoreDisplayAfterCountdown - Restores display
         * @fires playBeep - Audio feedback
         * @fires Element.textContent - Updates all displays
         * @fires Element.classList - Removes warning class
         * @example
         * this.stopCurrentTest(); // Stop and reset test
         */
        stopCurrentTest() {
          // Allow stopping at any time - no return check

          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.currentStep = 0;
          this.currentStepTime = 0;
          this.lastBeepSecond = null;

          this.testTimerStatus.textContent = "READY FOR TEST STRIP";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;
          this.testTimerDisplay.textContent = "0.00";
          this.testTimerDisplay.classList.remove("warning");

          // Reset step display
          if (this.steps.length > 0) {
            const firstStep = this.steps[0];
            this.currentStepDisplay.textContent = `1/${this.steps.length}`;
            this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
              2
            )}s`;
            this.currentStopDisplay.textContent =
              this.method === "cumulative"
                ? `${this.formatStop(firstStep.stop)}`
                : `+${this.getIncrementLabel(this.stepIncrement)}`;
            this.timeMultiplierDisplay.textContent =
              this.method === "cumulative"
                ? `${Math.pow(2, firstStep.stop).toFixed(2)}×`
                : `${firstStep.totalExposure.toFixed(1)}s total`;
            this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
          }

          this.updatePreview();

          playBeep(600, 0.1, 0.2);
        }

        /**
         * @method nextStep
         * @description Proceeds to the next test step.
         * Handles countdown if auto-advance is off, or proceeds immediately if on.
         * @returns {void}
         * @fires startCountdownForNextStep - Countdown before next step
         * @fires proceedToNextStep - Immediate next step
         * @example
         * this.nextStep(); // Proceed to next step
         */
        nextStep() {
          if (
            this.isPaused ||
            (!this.isRunning && this.currentStep < this.steps.length)
          ) {
            // If auto advance is OFF, do countdown before next step
            if (!this.autoAdvance) {
              this.startCountdownForNextStep();
            } else {
              // If auto advance is ON, proceed immediately
              this.proceedToNextStep();
            }
          }
        }

        /**
         * @method startCountdownForNextStep
         * @description Starts countdown before proceeding to next step.
         * Prevents multiple countdowns, saves display state, and handles completion.
         * @returns {void}
         * @fires countdownManager.startCountdown - Visual/audio countdown
         * @fires restoreDisplayAfterCountdown - Restores display after countdown
         * @fires proceedToNextStep - Called when countdown completes
         * @fires console.warn - If countdown already active
         * @fires console.error - If countdown fails
         * @example
         * this.startCountdownForNextStep(); // Countdown before next step
         */
        startCountdownForNextStep() {
          // Prevent multiple countdowns
          if (window.countdownManager && window.countdownManager.isActive) {
            console.warn("Countdown already active");
            return;
          }
          // Disable buttons during countdown, but keep Stop enabled
          this.startTestStripBtn.disabled = true;
          this.stopTestTimerBtn.disabled = false; // Keep Stop enabled
          this.resetTestTimerBtn.disabled = true;

          // Save original display values AND style properties
          const originalDisplay = this.testTimerDisplay.textContent;
          const originalStatus = this.testTimerStatus.textContent;
          const originalTimerBgColor =
            this.testTimerDisplay.style.backgroundColor;
          const originalTimerColor = this.testTimerDisplay.style.color;
          const originalTimerFontWeight =
            this.testTimerDisplay.style.fontWeight;

          // Store references for cleanup
          this.countdownCleanup = {
            display: originalDisplay,
            status: originalStatus,
            timerBgColor: originalTimerBgColor,
            timerColor: originalTimerColor,
            timerFontWeight: originalTimerFontWeight,
          };

          // Start countdown
          this.testTimerStatus.textContent = "COUNTDOWN FOR NEXT STEP...";

          // Clear any existing cleanup reference first
          if (this.countdownCleanupTimeout) {
            clearTimeout(this.countdownCleanupTimeout);
          }

          try {
            window.countdownManager.startCountdown(
              this.testTimerDisplay,
              () => {
                // Countdown complete callback
                this.restoreDisplayAfterCountdown();
                // Proceed to the actual next step
                this.proceedToNextStep();
              }
            );
          } catch (error) {
            console.error("Countdown failed:", error);
            // Fallback: proceed without countdown
            this.restoreDisplayAfterCountdown();
            this.proceedToNextStep();
          }
        }

        /**
         * @method restoreDisplayAfterCountdown
         * @description Restores display after countdown completes or is cancelled.
         * Resets text, colors, and font weights to original or theme defaults.
         * @returns {void}
         * @fires Element.textContent - Restores original text
         * @fires Element.style - Restores original styles
         * @fires Element.disabled - Re-enables buttons
         * @example
         * this.restoreDisplayAfterCountdown(); // Restore after countdown
         */
        restoreDisplayAfterCountdown() {
          if (this.countdownCleanup) {
            this.testTimerDisplay.textContent = this.countdownCleanup.display;
            this.testTimerStatus.textContent = this.countdownCleanup.status;
            this.testTimerDisplay.style.backgroundColor =
              this.countdownCleanup.timerBgColor;
            this.testTimerDisplay.style.color =
              this.countdownCleanup.timerColor;
            this.testTimerDisplay.style.fontWeight =
              this.countdownCleanup.timerFontWeight;
            this.countdownCleanup = null;
          } else {
            // Default restoration based on theme
            if (document.body.classList.contains("light-scheme")) {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#0066cc";
            } else if (document.body.classList.contains("day-scheme")) {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#ffcc00";
            } else {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#f00";
            }
            this.testTimerDisplay.style.fontWeight = "";
          }

          // Re-enable appropriate buttons
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = false;
          this.resetTestTimerBtn.disabled = true;
        }

        // NEW METHOD: Actual next step logic (moved from original nextStep)
        /**
         * @method proceedToNextStep
         * @description Advances to the next test step or completes the test.
         * Cleans up countdown display, increments step counter, and starts next step.
         * If all steps complete, calls complete() to finish the test.
         * @returns {Promise<void>} Resolves when step transition is complete
         * @throws {Error} If called when no test is active
         * @fires Element.textContent - Updates step counter display
         * @fires Element.style - Restores display styles
         * @fires Element.disabled - Updates button states
         * @example
         * await this.proceedToNextStep(); // Move to next step or finish
         */
        async proceedToNextStep() {
          // Clean up any remaining countdown display properties
          this.restoreDisplayAfterCountdown();

          this.currentStep++;

          if (this.currentStep < this.steps.length) {
            this.isRunning = true;
            this.isPaused = false;
            this.isWaitingForNextStep = false;
            await this.startStep(); // Add await here

            // Update button states
            this.startTestStripBtn.textContent = "Pause";
            this.stopTestTimerBtn.disabled = false;
            this.resetTestTimerBtn.disabled = true;
          } else {
            this.complete();
          }
        }

        /**
         * @method complete
         * @description Marks the test strip as complete and updates UI accordingly.
         * Cancels any active countdown, restores display, stops the timer, and shows completion status.
         * Plays completion beep if enabled, updates button states, and highlights all steps.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires Element.textContent - Shows "TEST STRIP COMPLETE" message
         * @fires Element.disabled - Updates all button states
         * @fires Element.textContent - Updates start button text
         * @fires AudioService.playBeep - Plays completion sound if enabled
         * @fires this.updatePreview - Updates step preview display
         * @example
         * this.complete(); // Mark test as complete
         */
        complete() {
          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;

          if (this.testEndBeep.checked) {
            playBeep(800, 0.1, 0.3);
          }

          this.testTimerStatus.textContent = "TEST STRIP COMPLETE";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;

          // Highlight all steps as complete
          this.currentStep = this.steps.length;
          this.updatePreview();
        }

        /**
         * @method reset
         * @description Resets the test strip to initial state.
         * Cancels any active countdown, clears intervals, resets all state variables,
         * and restores UI to ready state with default styling and step display.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires Element.textContent - Resets displays to initial values
         * @fires Element.classList - Removes warning class
         * @fires Element.disabled - Resets all button states
         * @fires this.updatePreview - Updates step preview display
         * @example
         * this.reset(); // Reset test strip to initial state
         */
        reset() {
          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.currentStep = 0;
          this.currentStepTime = 0;

          this.testTimerStatus.textContent = "READY FOR TEST STRIP";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;
          this.testTimerDisplay.textContent = "0.00";
          this.testTimerDisplay.classList.remove("warning");

          // Reset step display
          if (this.steps.length > 0) {
            const firstStep = this.steps[0];
            this.currentStepDisplay.textContent = `1/${this.steps.length}`;
            this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
              2
            )}s`;
            this.currentStopDisplay.textContent =
              this.method === "cumulative"
                ? `${this.formatStop(firstStep.stop)}`
                : `+${this.getIncrementLabel(this.stepIncrement)}`;
            this.timeMultiplierDisplay.textContent =
              this.method === "cumulative"
                ? `${Math.pow(2, firstStep.stop).toFixed(2)}×`
                : `${firstStep.totalExposure.toFixed(1)}s total`;
            this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
          }

          this.updatePreview();
        }

        /**
         * @method toggle
         * @description Toggles the test strip state (start/pause/resume/next).
         * Acts as a universal control button that changes behavior based on current state:
         * - Running → Pause
         * - Paused → Resume
         * - Waiting for next → Next step
         * - Stopped → Start
         * @returns {Promise<void>} Resolves when toggle action completes
         * @fires this.pause - When running
         * @fires this.resume - When paused
         * @fires this.nextStep - When waiting for next step
         * @fires this.start - When stopped
         * @example
         * await this.toggle(); // Toggle current state
         */
        async toggle() {
          if (this.isRunning) {
            this.pause();
          } else if (this.isPaused) {
            await this.resume();
          } else if (this.isWaitingForNextStep) {
            // Waiting for next step - act like Next Step button
            this.nextStep();
          } else {
            await this.start();
          }
        }

        /**
         * @method applyStepToCalc
         * @description Applies a test step's total exposure time to the CALC tab's base time.
         * Updates the base time slider, triggers state update, switches to CALC tab, and scrolls to top.
         * @param {number} stepIndex - Index of the step to apply (0-based)
         * @returns {void}
         * @throws {Error} If stepIndex is out of bounds
         * @fires Element.value - Updates base time slider value
         * @fires Event.input - Triggers slider input event to update calculator state
         * @fires switchTab - Switches to CALC tab
         * @fires Element.scrollTop - Scrolls container to top
         * @fires window.scrollTo - Scrolls window to top as fallback
         * @example
         * this.applyStepToCalc(2); // Apply third step's total exposure to CALC tab
         */
        applyStepToCalc(stepIndex) {
          if (stepIndex < 0 || stepIndex >= this.steps.length) return;

          const step = this.steps[stepIndex];

          // Get the total exposure time for this step
          // Both methods use totalExposure for consistency
          const timeValue = step.totalExposure;

          // Update the CALC tab's base time slider
          const baseTimeSlider = document.getElementById("baseTimeSlider");
          if (baseTimeSlider) {
            baseTimeSlider.value = timeValue.toFixed(1);

            // Trigger the input event to update the IncrementalTimer state
            baseTimeSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }

          // Switch to CALC tab
          switchTab("calc");

          // Scroll to top using container
          const container = document.querySelector(".container");
          if (container) {
            container.scrollTop = 0;
          }
          // Also scroll window as fallback
          window.scrollTo(0, 0);
        }

        /**
         * @method getCurrentTestStripProfile
         * @description Gets the currently loaded test strip profile name from appState.
         * Returns the single source of truth for the active profile.
         * @returns {string|null} The profile name or null if no profile loaded
         * @fires appState.persistent.currentTestStripProfile - Reads current profile
         * @example
         * const profile = this.getCurrentTestStripProfile(); // Get active profile name
         */
        getCurrentTestStripProfile() {
          return appState.persistent.currentTestStripProfile;
        }

        /**
         * @method setCurrentTestStripProfile
         * @description Sets the current test strip profile in appState and persists to storage.
         * Updates the single source of truth and saves to localStorage.
         * @param {string} profileName - The name of the profile to set as current
         * @returns {void}
         * @fires appState.persistent.currentTestStripProfile - Updates current profile
         * @fires StorageManager.saveCurrentTestStripProfile - Persists to storage
         * @example
         * this.setCurrentTestStripProfile("My Test Profile"); // Set and save profile
         */
        setCurrentTestStripProfile(profileName) {
          appState.persistent.currentTestStripProfile = profileName;
          StorageManager.saveCurrentTestStripProfile(profileName);
        }

        /**
         * @method getCurrentSettings
         * @description Gets current test strip settings as a configuration object.
         * Collects base time, step increment, denominator, and number of steps.
         * @returns {Object} Settings object with baseTime, stepIncrement, denominator, numSteps
         * @fires Element.value - Reads slider values
         * @fires window.stopDenominator - Reads global denominator setting
         * @example
         * const settings = this.getCurrentSettings(); // Get current configuration
         */
        /**
         * @method getCurrentSettings
         * @description Gets current test strip settings as a configuration object.
         * Collects base time, step increment, denominator, number of steps, method, and auto-advance settings.
         * @returns {Object} Settings object with baseTime, stepIncrement, denominator, numSteps, method, autoAdvance, autoAdvanceDelay
         * @fires Element.value - Reads slider values
         * @fires window.stopDenominator - Reads global denominator setting
         * @example
         * const settings = this.getCurrentSettings(); // Get current configuration
         */
        getCurrentSettings() {
          return {
            baseTime: parseFloat(this.testBaseSlider.value),
            stepIncrement: parseInt(this.testIncrementSlider.value),
            denominator: window.stopDenominator || 3,
            numSteps: parseInt(this.testStepsSlider.value),
            method: this.method,
            autoAdvance: this.autoAdvance,
            autoAdvanceDelay: this.autoAdvanceDelay / 1000, // Convert to seconds
          };
        }

        /**
         * @method applyProfile
         * @description Applies settings from a profile to the test strip controls.
         * Stops any running test, updates all controls, sets denominator, method, auto-advance,
         * and refreshes the UI with visual feedback.
         * @param {Object} profile - The profile object to apply
         * @returns {void}
         * @throws {Error} If profile is invalid
         * @fires this.stopCurrentTest - Stops running test
         * @fires Element.value - Updates slider values
         * @fires window.stopDenominator - Updates global denominator
         * @fires setActiveSeg - Updates segment control
         * @fires this.setMethod - Sets test method
         * @fires this.setAutoAdvance - Sets auto-advance mode
         * @fires StorageManager.saveSettings - Persists auto-advance delay
         * @fires this.setCurrentTestStripProfile - Sets current profile name
         * @fires this.updateFromControls - Refreshes all displays
         * @fires updateAllRulers - Updates visual rulers
         * @fires this.updateTestStripProfileList - Updates profile list UI
         * @fires AudioService.playBeep - Plays confirmation sound
         * @example
         * this.applyProfile(myProfile); // Apply profile settings
         */
        applyProfile(profile) {
          if (!profile) return;

          // Stop current test if running
          if (this.isRunning) {
            this.stopCurrentTest();
          }

          // Apply settings to controls
          this.testBaseSlider.value = profile.baseTime;
          this.testIncrementSlider.value = profile.stepIncrement;
          this.testStepsSlider.value = profile.numSteps;

          // Set denominator
          window.stopDenominator = profile.denominator;
          setActiveSeg("testIncrementSeg", profile.denominator);

          // Set method
          this.setMethod(profile.method);

          // Set auto advance
          this.setAutoAdvance(profile.autoAdvance);
          if (profile.autoAdvanceDelay !== undefined) {
            this.autoAdvanceDelay = profile.autoAdvanceDelay * 1000;
            if (settingsManager) {
              settingsManager.settings.autoAdvanceDelay =
                profile.autoAdvanceDelay;
              StorageManager.saveSettings(settingsManager.settings);
            }
          }

          // Set current profile
          this.setCurrentTestStripProfile(profile.name);

          // Update from controls to refresh everything
          this.updateFromControls();
          if (typeof updateAllRulers === "function") {
            updateAllRulers();
          }

          // Update profile list to show active state
          this.updateTestStripProfileList();

          // Visual feedback
          playBeep(600, 0.3, 0.3);
        }

        /**
         * @method saveProfile
         * @description Saves current settings as a named profile.
         * Creates a profile object with current settings and timestamp, saves to storage,
         * and updates the profile list UI with visual feedback.
         * @param {string} name - The name for the new profile
         * @returns {boolean} True if saved successfully, false otherwise
         * @throws {Error} If storage operation fails
         * @fires this.getCurrentSettings - Collects current settings
         * @fires StorageManager.loadTestStripProfiles - Loads existing profiles
         * @fires StorageManager.saveTestStripProfiles - Saves updated profiles
         * @fires this.updateTestStripProfileList - Updates UI
         * @fires AudioService.playBeep - Plays confirmation sound
         * @example
         * const success = this.saveProfile("My Profile"); // Save current settings
         */
        saveProfile(name) {
          if (!name || name.trim() === "") {
            alert("Please enter a profile name");
            return false;
          }

          const profile = {
            name: name.trim(),
            ...this.getCurrentSettings(),
            date: new Date().toISOString(),
          };

          // Get existing profiles
          const profiles = StorageManager.loadTestStripProfiles();

          // Check if profile already exists
          const existingIndex = profiles.findIndex(
            (p) => p.name === profile.name
          );
          if (existingIndex >= 0) {
            profiles[existingIndex] = profile;
          } else {
            profiles.push(profile);
          }

          // Save to storage
          if (StorageManager.saveTestStripProfiles(profiles)) {
            this.updateTestStripProfileList();
            playBeep(800, 0.3, 0.3);
            return true;
          }

          return false;
        }

        /**
         * @method loadProfile
         * @description Loads a profile by name and applies it to the test strip controls.
         * Searches through saved profiles and applies the matching one.
         * @param {string} profileName - The name of the profile to load
         * @returns {boolean} True if profile found and applied, false otherwise
         * @fires StorageManager.loadTestStripProfiles - Loads all profiles
         * @fires this.applyProfile - Applies the profile settings
         * @example
         * const success = this.loadProfile("My Profile"); // Load and apply profile
         */
        loadProfile(profileName) {
          const profiles = StorageManager.loadTestStripProfiles();
          const profile = profiles.find((p) => p.name === profileName);

          if (profile) {
            this.applyProfile(profile);
            return true;
          }

          return false;
        }

        /**
         * @method deleteProfile
         * @description Deletes a profile by name after user confirmation.
         * Prompts user for confirmation, removes profile from storage, and updates UI.
         * @param {string} profileName - The name of the profile to delete
         * @returns {boolean} True if deleted successfully, false otherwise or cancelled
         * @fires confirm - User confirmation dialog
         * @fires StorageManager.loadTestStripProfiles - Loads all profiles
         * @fires StorageManager.saveTestStripProfiles - Saves filtered profiles
         * @fires this.updateTestStripProfileList - Updates UI
         * @fires AudioService.playBeep - Plays deletion sound
         * @example
         * const success = this.deleteProfile("Old Profile"); // Delete profile
         */
        deleteProfile(profileName) {
          if (confirm(`Delete test strip profile "${profileName}"?`)) {
            const profiles = StorageManager.loadTestStripProfiles();
            const filtered = profiles.filter((p) => p.name !== profileName);

            if (StorageManager.saveTestStripProfiles(filtered)) {
              this.updateTestStripProfileList();
              playBeep(400, 0.3, 0.3);
              return true;
            }
          }
          return false;
        }

        /**
         * @method clearAllProfiles
         * @description Clears all test strip profiles after user confirmation.
         * Prompts user for confirmation, clears storage, and updates UI.
         * @returns {boolean} True if cleared successfully, false otherwise or cancelled
         * @fires confirm - User confirmation dialog
         * @fires StorageManager.saveTestStripProfiles - Clears all profiles
         * @fires this.updateTestStripProfileList - Updates UI
         * @fires AudioService.playBeep - Plays confirmation sound
         * @example
         * const success = this.clearAllProfiles(); // Clear all profiles
         */
        clearAllProfiles() {
          if (
            confirm("Clear all test strip profiles? This cannot be undone.")
          ) {
            if (StorageManager.saveTestStripProfiles([])) {
              this.updateTestStripProfileList();
              playBeep(400, 0.3, 0.3);
              return true;
            }
          }
          return false;
        }

        /**
         * @method updateTestStripProfileList
         * @description Updates the profile list display in the UI.
         * Loads all profiles from storage, creates list items with load/delete buttons,
         * and highlights the currently active profile.
         * @returns {void}
         * @fires StorageManager.loadTestStripProfiles - Loads all profiles
         * @fires this.getCurrentTestStripProfile - Gets active profile name
         * @fires this.loadProfile - Called when profile is clicked
         * @fires this.deleteProfile - Called when delete button is clicked
         * @fires Element.innerHTML - Clears and rebuilds list
         * @example
         * this.updateTestStripProfileList(); // Refresh profile list UI
         */
        updateTestStripProfileList() {
          const listElement = document.getElementById("testStripProfileList");
          if (!listElement) return;

          const profiles = StorageManager.loadTestStripProfiles();
          const currentProfile = this.getCurrentTestStripProfile();
          listElement.innerHTML = "";

          if (profiles.length === 0) {
            listElement.innerHTML =
              '<div style="padding: 10px; text-align: center; color: var(--text-secondary); font-size: 0.75rem;">No profiles saved yet</div>';
            return;
          }

          profiles.forEach((profile) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = `shelf-life-item ${
              currentProfile === profile.name ? "active" : ""
            }`;

            const methodLabel =
              profile.method === "cumulative" ? "Cumulative" : "Incremental";
            const autoAdvanceLabel = profile.autoAdvance ? "Auto" : "Manual";
            const denomLabel = `1/${profile.denominator}`;

            itemDiv.innerHTML = `
              <div>
                <strong>${profile.name}</strong>
                <div style="font-size: 0.65rem; color: var(--text-secondary);">
                  ${profile.baseTime}s • ${
              profile.stepIncrement
            }×${denomLabel} • ${profile.numSteps} steps
                </div>
                <div style="font-size: 0.6rem; color: var(--accent);">
                  ${methodLabel} • ${autoAdvanceLabel}
                </div>
                <div style="font-size: 0.55rem; color: var(--text-secondary); margin-top: 2px;">
                  ${new Date(profile.date).toLocaleDateString()}
                </div>
              </div>
              <div class="shelf-life-actions">
                <button class="btn-action load-btn" data-context="teststrip" data-name="${
                  profile.name
                }">Load</button>
                <button class="btn-action delete-btn" data-context="teststrip" data-name="${
                  profile.name
                }">Delete</button>
              </div>
            `;

            listElement.appendChild(itemDiv);
          });
        }
      }

      /**
       * @function updateChart
       * @description Updates the f-stop calculation table with current base time and stop settings.
       * Generates a table showing total time, increment from base, and step increments for stops -6 to +6.
       * Highlights the currently selected stop row.
       * @returns {void}
       * @fires chartBaseSlider.value - Reads chart base time (if available)
       * @fires Element.getElementById - Gets base time slider and table body
       * @fires window.incrementalTimer - Reads calculator base time
       * @fires settingsManager.settings - Reads settings base time
       * @fires calculateTime - Calculates time for each stop
       * @fires formatStop - Formats stop values
       * @fires Element.innerHTML - Clears and rebuilds table
       * @fires Element.appendChild - Adds rows to table
       * @fires Element.style - Applies highlighting to current stop row
       * @example
       * updateChart(); // Update f-stop calculation table
       */
      function updateChart() {
        const baseTime = (function () {
          // Prefer chart slider if present, otherwise fall back to the main base time slider
          if (typeof chartBaseSlider !== "undefined" && chartBaseSlider)
            return parseFloat(chartBaseSlider.value);
          const bt = document.getElementById("baseTimeSlider");
          if (bt) return parseFloat(bt.value);
          if (window.incrementalTimer)
            return parseFloat(window.incrementalTimer.baseTime) || 10;
          if (settingsManager)
            return parseFloat(settingsManager.settings.baseTime) || 10;
          return 10;
        })();
        const chartBaseEl = document.getElementById("chartBaseValue");
        if (chartBaseEl) chartBaseEl.textContent = `${baseTime.toFixed(1)}s`;

        const tableBody = document.getElementById("tableBody");
        const currentStop = parseInt(stopSlider.value);

        tableBody.innerHTML = "";

        let previousTotalTime = null;

        for (let stop = -6; stop <= 6; stop++) {
          const totalTime = calculateTime(baseTime, stop);
          const fromBaseTime = totalTime - baseTime;

          let increment = 0;
          if (previousTotalTime !== null) {
            increment = totalTime - previousTotalTime;
          }
          previousTotalTime = totalTime;

          const stopLabel = formatStop(stop);
          const row = document.createElement("tr");

          if (stop === currentStop) {
            row.style.background = "var(--panel-light)";
            row.style.fontWeight = "bold";
          }

          row.innerHTML = `
                <td>${stopLabel}</td>
                <td><strong>${totalTime.toFixed(2)}</strong></td>
                <td>${fromBaseTime >= 0 ? "+" : ""}${fromBaseTime.toFixed(
            2
          )}</td>
                <td class="increment-cell">${
                  increment >= 0 ? "+" : ""
                }${increment.toFixed(2)}</td>
            `;

          tableBody.appendChild(row);
        }
      }

      // Fullscreen Manager
      /**
       * @class FullscreenManager
       * @description Manages fullscreen mode for the application.
       * Handles entering, exiting, and toggling fullscreen state across different browsers.
       * Monitors fullscreen change events and updates UI accordingly.
       * @property {boolean} isFullscreen - Current fullscreen state
       * @property {HTMLElement|null} toggleBtn - Fullscreen toggle button element
       * @example
       * const fullscreenManager = new FullscreenManager();
       */
      class FullscreenManager {
        /**
         * @constructor
         * @description Creates a new FullscreenManager instance.
         * Initializes state, finds toggle button, and sets up event listeners.
         * @fires this.init - Initializes event listeners
         */
        constructor() {
          this.isFullscreen = false;
          this.toggleBtn = document.getElementById("toggleFullscreen");
          this.init();
        }

        /**
         * @method init
         * @description Initializes event listeners for fullscreen management.
         * Sets up click handler for toggle button and fullscreen change listeners
         * for all browser prefixes (standard, WebKit, Mozilla, Microsoft).
         * @returns {void}
         * @fires Element.addEventListener - Adds click listener to toggle button
         * @fires document.addEventListener - Adds fullscreen change listeners
         * @example
         * this.init(); // Initialize event listeners
         */
        init() {
          if (this.toggleBtn) {
            this.toggleBtn.addEventListener("click", () => this.toggle());
          }

          document.addEventListener("fullscreenchange", () =>
            this.handleFullscreenChange()
          );
          document.addEventListener("webkitfullscreenchange", () =>
            this.handleFullscreenChange()
          );
          document.addEventListener("mozfullscreenchange", () =>
            this.handleFullscreenChange()
          );
          document.addEventListener("MSFullscreenChange", () =>
            this.handleFullscreenChange()
          );
        }

        /**
         * @method toggle
         * @description Toggles fullscreen mode on or off.
         * Calls enter() if not fullscreen, exit() if fullscreen.
         * @returns {void}
         * @fires this.enter - When entering fullscreen
         * @fires this.exit - When exiting fullscreen
         * @example
         * this.toggle(); // Toggle fullscreen state
         */
        toggle() {
          if (!this.isFullscreen) {
            this.enter();
          } else {
            this.exit();
          }
        }

        /**
         * @method enter
         * @description Enters fullscreen mode using browser-specific APIs.
         * Attempts standard requestFullscreen first, then falls back to prefixed versions,
         * and finally uses CSS class fallback if APIs are unavailable.
         * @returns {void}
         * @fires Element.requestFullscreen - Standard fullscreen API
         * @fires Element.webkitRequestFullscreen - WebKit prefix
         * @fires Element.mozRequestFullScreen - Mozilla prefix
         * @fires Element.msRequestFullscreen - Microsoft prefix
         * @fires Element.classList.add - Adds fullscreen-mode class
         * @fires this.updateButton - Updates button text
         * @example
         * this.enter(); // Enter fullscreen mode
         */
        enter() {
          const element = document.documentElement;

          if (element.requestFullscreen) {
            element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
          } else {
            document.body.classList.add("fullscreen-mode");
            this.isFullscreen = true;
            this.updateButton();
          }
        }

        /**
         * @method exit
         * @description Exits fullscreen mode using browser-specific APIs.
         * Attempts standard exitFullscreen first, then falls back to prefixed versions,
         * and finally uses CSS class fallback if APIs are unavailable.
         * @returns {void}
         * @fires document.exitFullscreen - Standard fullscreen API
         * @fires document.webkitExitFullscreen - WebKit prefix
         * @fires document.mozCancelFullScreen - Mozilla prefix
         * @fires document.msExitFullscreen - Microsoft prefix
         * @fires Element.classList.remove - Removes fullscreen-mode class
         * @fires this.updateButton - Updates button text
         * @example
         * this.exit(); // Exit fullscreen mode
         */
        exit() {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            document.body.classList.remove("fullscreen-mode");
            this.isFullscreen = false;
            this.updateButton();
          }
        }

        /**
         * @method handleFullscreenChange
         * @description Handles fullscreen change events from the browser.
         * Updates internal state, applies/removes fullscreen CSS class,
         * and updates the toggle button text.
         * @returns {void}
         * @fires document.fullscreenElement - Checks current fullscreen element
         * @fires Element.classList.add - Adds fullscreen-mode class
         * @fires Element.classList.remove - Removes fullscreen-mode class
         * @fires this.updateButton - Updates button text
         * @example
         * this.handleFullscreenChange(); // Handle fullscreen state change
         */
        handleFullscreenChange() {
          this.isFullscreen = !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
          );

          if (this.isFullscreen) {
            document.body.classList.add("fullscreen-mode");
          } else {
            document.body.classList.remove("fullscreen-mode");
          }

          this.updateButton();
        }

        /**
         * @method updateButton
         * @description Updates the toggle button text based on fullscreen state.
         * Shows "Exit Fullscreen" when in fullscreen mode, "Enter Fullscreen" otherwise.
         * @returns {void}
         * @fires Element.textContent - Updates button text
         * @example
         * this.updateButton(); // Update button display
         */
        updateButton() {
          if (this.toggleBtn) {
            this.toggleBtn.textContent = this.isFullscreen
              ? "Exit Fullscreen"
              : "Enter Fullscreen";
          }
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize audio service first (for all sound functionality)
        audioService = new AudioService();
        audioService.init();

        // Initialize settings manager first
        settingsManager = new SettingsManager();

        // Initialize calculator
        window.incrementalTimer = new IncrementalTimer();

        // Initialize the combined calculator (replaces both old calculators)
        window.heightCalculator = new EnlargerHeightCalculator(
          window.incrementalTimer
        );

        // Initialize custom filter bank (feeds contrast factor)
        window.customFilterBankManager = new CustomFilterBankManager(
          window.heightCalculator
        );

        // Initialize test strip generator
        window.fstopTestGenerator = new FStopTestStripGenerator();

        // Initialize chemical manager (UPDATED)
        window.chemicalManager = new ChemicalManager();

        // Initialize countdown manager
        window.countdownManager = new CountdownManager();

        // Initialize timers
        timerManager.init();

        // Apply saved settings to UI and instances on startup
        loadSettingsToUI();

        // Initialize fullscreen manager
        const fullscreenManager = new FullscreenManager();

        // Initialize relay manager
        window.relayManager = new RelayManager();

        // Color scheme selector
        document.querySelectorAll(".toggle-btn[data-scheme]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const scheme = btn.getAttribute("data-scheme");
            settingsManager.setColorScheme(scheme);
          });
        });

        document
          .getElementById("testCountdownBeep")
          ?.addEventListener("click", () => {
            // Test the different countdown beep patterns
            playCountdownBeep(5); // Early second beep
            setTimeout(() => playCountdownBeep(4), 300);
            setTimeout(() => playCountdownBeep(3), 600); // Last 3 seconds beep
            setTimeout(() => playPreset("countdownComplete"), 900); // Final beep
          });

        // Settings panel event listeners
        document
          .getElementById("saveGlobalSettings")
          .addEventListener("click", () => {
            settingsManager.saveGlobalSettings();
          });

        // Live-apply settings as user edits (debounced)
        (function bindLiveSettings() {
          const toBind = [
            { id: "settingBaseTime", evt: "input" },
            { id: "settingDevTime", evt: "input" },
            { id: "settingStopTime", evt: "input" },
            { id: "settingFixTime", evt: "input" },
            { id: "settingFloTime", evt: "input" },
            { id: "settingCountdownDelay", evt: "input" },
            { id: "settingCountdownBeep", evt: "change" },
            { id: "settingCountdownPattern", evt: "change" },
            { id: "settingAutoAdvance", evt: "change" },
            { id: "settingAutoAdvanceDelay", evt: "input" },
            { id: "safelightAutoOff", evt: "change" },
            { id: "settingCalcWarningBeep", evt: "change" },
            { id: "settingCalcEndBeep", evt: "change" },
            { id: "settingTimerWarningBeep", evt: "change" },
            { id: "settingTimerEndBeep", evt: "change" },
            { id: "settingDefaultPhotoFlo", evt: "change" },
            { id: "settingStopIncrement", evt: "change" },
          ];
          toBind.forEach(({ id, evt }) => {
            const el = document.getElementById(id);
            if (!el) return;
            let t = null;
            el.addEventListener(evt, () => {
              clearTimeout(t);
              t = setTimeout(() => {
                settingsManager.applyLiveSettings();
              }, 150);
            });
          });
        })();

        // Initialize denom and controls (functions moved outside DOMContentLoaded)
        window.stopDenominator =
          window.stopDenominator ||
          (settingsManager && settingsManager.settings.stopDenominator) ||
          3;
        setActiveSeg("calcIncrementSeg", window.stopDenominator);
        setActiveSeg("testIncrementSeg", window.stopDenominator);
        initSegControl("calcIncrementSeg");
        initSegControl("testIncrementSeg");
        // Backwards compatibility: update select values if present
        const calcOld = document.getElementById("calcIncrementDenom");
        const testOld = document.getElementById("testIncrementDenom");
        if (calcOld) calcOld.value = window.stopDenominator;
        if (testOld) testOld.value = window.stopDenominator;
        updateAllRulers();

        // Timer profile management in timer tab
        document
          .getElementById("saveTimerProfile")
          ?.addEventListener("click", () => {
            const profileName =
              document.getElementById("timerProfileName").value;
            if (settingsManager.saveCurrentProfile(profileName)) {
              document.getElementById("timerProfileName").value = "";
            }
          });

        document
          .getElementById("clearTimerProfiles")
          ?.addEventListener("click", () => {
            settingsManager.clearAllProfiles();
          });

        // Test strip profile management in test tab
        document
          .getElementById("saveTestStripProfile")
          ?.addEventListener("click", () => {
            const profileName = document.getElementById(
              "testStripProfileName"
            ).value;
            if (
              window.fstopTestGenerator &&
              window.fstopTestGenerator.saveProfile(profileName)
            ) {
              document.getElementById("testStripProfileName").value = "";
            }
          });

        document
          .getElementById("clearTestStripProfiles")
          ?.addEventListener("click", () => {
            if (window.fstopTestGenerator) {
              window.fstopTestGenerator.clearAllProfiles();
            }
          });

        // Combined export/import in settings tab
        document
          .getElementById("exportAllProfiles")
          ?.addEventListener("click", () => {
            settingsManager.exportAllData();
          });

        document
          .getElementById("importAllProfiles")
          ?.addEventListener("click", () => {
            document.getElementById("allProfilesFileInput").click();
          });

        document
          .getElementById("allProfilesFileInput")
          .addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
              settingsManager.importAllData(event.target.result);
              e.target.value = "";
            };
            reader.onerror = () => {
              settingsManager.showAllProfilesFeedback(
                "Error reading file",
                "error"
              );
              e.target.value = "";
            };
            reader.readAsText(file);
          });

        document
          .getElementById("resetAllSettings")
          .addEventListener("click", () => {
            settingsManager.resetAllSettings();
          });

        // Initialize audio context on any user interaction
        document.addEventListener("click", initAudioContext);

        // ===== CENTRALIZED EVENT DELEGATION =====
        // Handle all timer-related button clicks via delegation
        document.addEventListener("click", (e) => {
          // Timer toggle buttons (Start/Pause)
          const timerBtn = e.target.closest(
            '[id^="btn"][id$="Dev"], [id^="btn"][id$="Stop"], [id^="btn"][id$="Fix"], [id^="btn"][id$="Flo"]'
          );
          if (timerBtn && timerBtn.id.startsWith("btn")) {
            const timerName = timerBtn.id.replace("btn", "");
            const timer = timerManager?.timers.find(
              (t) => t.name === timerName
            );
            if (timer) {
              e.preventDefault();
              timer.toggle();
            }
            return;
          }

          // Timer action buttons (reset, plus, minus)
          const timerActionBtn = e.target.closest(
            "button[data-timer][data-action]"
          );
          if (timerActionBtn) {
            const timerName = timerActionBtn.getAttribute("data-timer");
            const action = timerActionBtn.getAttribute("data-action");
            const timer = timerManager?.timers.find(
              (t) => t.name === timerName
            );
            if (timer) {
              e.preventDefault();
              if (action === "reset") timer.reset();
              else if (action === "plus") timer.adjustTime(5);
              else if (action === "minus") timer.adjustTime(-5);
            }
            return;
          }

          // Calculator buttons
          if (e.target.id === "startExposure" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.toggle();
            return;
          }
          if (e.target.id === "stopCalcTimer" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.stopCurrentExposure();
            return;
          }
          if (e.target.id === "resetCalcTimer" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.reset();
            return;
          }
          if (e.target.id === "repeatExposure" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.repeatLast();
            return;
          }

          // Relay toggle buttons
          const relayToggleBtn = e.target.closest(".settings-btn[data-relay]");
          if (relayToggleBtn && window.relayManager) {
            const relayNum = parseInt(
              relayToggleBtn.getAttribute("data-relay")
            );
            e.preventDefault();
            window.relayManager.toggleRelay(relayNum);
            return;
          }

          // Load buttons (consolidated - profile, preset, chemical, or teststrip)
          const loadBtn = e.target.closest(
            ".load-btn[data-context][data-name]"
          );
          if (loadBtn) {
            const context = loadBtn.getAttribute("data-context");
            const name = loadBtn.getAttribute("data-name");
            e.preventDefault();

            if (context === "profile" && settingsManager) {
              const profile = settingsManager.profiles.find(
                (p) => p.name === name
              );
              if (profile) {
                settingsManager.loadProfile(profile);
              }
            } else if (context === "preset" && window.chemicalManager) {
              const preset = window.chemicalManager.chemicalPresets.find(
                (p) => p.name === name
              );
              if (preset) {
                window.chemicalManager.loadChemicalPreset(preset);
              }
            } else if (context === "teststrip" && window.fstopTestGenerator) {
              window.fstopTestGenerator.loadProfile(name);
            }
            return;
          }

          // Delete buttons (consolidated - profile, preset, chemical, or teststrip)
          const deleteBtn = e.target.closest(".delete-btn[data-context]");
          if (deleteBtn) {
            const context = deleteBtn.getAttribute("data-context");
            e.preventDefault();

            if (context === "profile" && settingsManager) {
              const profileName = deleteBtn.getAttribute("data-name");
              settingsManager.deleteProfile(profileName);
            } else if (context === "preset" && window.chemicalManager) {
              const presetName = deleteBtn.getAttribute("data-name");
              window.chemicalManager.deleteChemicalPreset(presetName);
            } else if (context === "chemical" && window.chemicalManager) {
              const id = parseInt(deleteBtn.getAttribute("data-id"));
              window.chemicalManager.deleteChemical(id);
            } else if (context === "teststrip" && window.fstopTestGenerator) {
              const profileName = deleteBtn.getAttribute("data-name");
              window.fstopTestGenerator.deleteProfile(profileName);
            }
            return;
          }

          // Renew button (for chemical shelf life)
          const renewBtn = e.target.closest(
            ".renew-btn[data-context][data-id]"
          );
          if (renewBtn && window.chemicalManager) {
            const id = parseInt(renewBtn.getAttribute("data-id"));
            e.preventDefault();
            window.chemicalManager.renewChemical(id);
            return;
          }

          // Dilution buttons
          const dilutionBtn = e.target.closest(".toggle-btn[data-ratio]");
          if (dilutionBtn && window.chemicalManager) {
            e.preventDefault();
            document
              .querySelectorAll(".toggle-btn[data-ratio]")
              .forEach((b) => b.classList.remove("active"));
            dilutionBtn.classList.add("active");
            window.chemicalManager.dilutionRatio =
              dilutionBtn.getAttribute("data-ratio");
            window.chemicalManager.updateMixCalculator();
            return;
          }

          // Paper size buttons
          const paperSizeBtn = e.target.closest(".toggle-btn[data-size]");
          if (paperSizeBtn && window.chemicalManager) {
            const size = parseFloat(paperSizeBtn.getAttribute("data-size"));
            if (size) {
              e.preventDefault();
              window.chemicalManager.setPaperSize(size);
              if (window.chemicalManager.customPaperSizeInput) {
                window.chemicalManager.customPaperSizeInput.value =
                  size.toFixed(3);
              }
            }
            return;
          }

          // Color scheme buttons
          const colorSchemeBtn = e.target.closest(".toggle-btn[data-scheme]");
          if (colorSchemeBtn && settingsManager) {
            const scheme = colorSchemeBtn.getAttribute("data-scheme");
            e.preventDefault();
            settingsManager.setColorScheme(scheme);
            return;
          }
        });

        // Event delegation for segmented controls (f-stop denominator)
        document.addEventListener("click", (e) => {
          const segmentedBtn = e.target.closest(".segmented-btn[data-denom]");
          if (segmentedBtn) {
            const container = segmentedBtn.closest(".segmented-control");
            if (container) {
              const denom = parseInt(
                segmentedBtn.getAttribute("data-denom"),
                10
              );
              e.preventDefault();

              // Update all buttons in this container
              container.querySelectorAll(".segmented-btn").forEach((btn) => {
                btn.classList.remove("active");
                btn.setAttribute("aria-pressed", "false");
              });
              segmentedBtn.classList.add("active");
              segmentedBtn.setAttribute("aria-pressed", "true");

              // Update global denominator
              window.stopDenominator = denom;

              // Sync all segmented controls
              document
                .querySelectorAll(".segmented-control")
                .forEach((cont) => {
                  cont.querySelectorAll(".segmented-btn").forEach((btn) => {
                    const btnDenom = parseInt(
                      btn.getAttribute("data-denom"),
                      10
                    );
                    if (btnDenom === denom) {
                      btn.classList.add("active");
                      btn.setAttribute("aria-pressed", "true");
                    } else {
                      btn.classList.remove("active");
                      btn.setAttribute("aria-pressed", "false");
                    }
                  });
                });

              // Update calculators
              if (window.incrementalTimer) {
                window.incrementalTimer.updateCalculations();
                window.incrementalTimer.render();
              }
              if (window.fstopTestGenerator) {
                window.fstopTestGenerator.generateSteps();
                window.fstopTestGenerator.updateDisplay();
              }
              try {
                updateAllRulers();
              } catch (e) {}
              try {
                updateChart();
              } catch (e) {}
            }
          }
        });

        // Initialize collapsible rows in the CALC, CHEMICAL and TIMER tabs
        (function initCalcCollapsibles() {
          const STORAGE_KEY = "calc_collapsed";
          let stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}");
          const sections = document.querySelectorAll(
            "#calc .collapsible, #fstop-test .collapsible, #chemical .collapsible, #timer .collapsible, #settings .collapsible"
          );
          // Clean up any stored keys that no longer correspond to existing sections
          const existingIds = Array.from(sections)
            .map((s) => s.getAttribute("data-id"))
            .filter(Boolean);
          Object.keys(stored).forEach((key) => {
            if (!existingIds.includes(key)) {
              delete stored[key];
            }
          });
          // Persist cleaned state back to storage
          localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
          sections.forEach((sec) => {
            const id = sec.getAttribute("data-id") || "";
            const header = sec.querySelector(".collapsible-header");
            const content = sec.querySelector(".collapsible-content");
            if (!header || !content) return;

            // Default: collapsed unless explicitly set to false in storage
            const collapsed = stored[id] !== false;
            header.setAttribute("aria-expanded", collapsed ? "false" : "true");
            content.style.maxHeight = collapsed
              ? "0px"
              : content.scrollHeight + "px";

            header.addEventListener("click", () => {
              const expanded = header.getAttribute("aria-expanded") === "true";
              header.setAttribute("aria-expanded", expanded ? "false" : "true");
              if (expanded) {
                content.style.maxHeight = "0px";
                stored[id] = true;
              } else {
                content.style.maxHeight = content.scrollHeight + "px";
                stored[id] = false;
              }
              localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
            });

            // Expand to fit dynamic content changes (new profiles/presets/etc.)
            const observer = new MutationObserver(() => {
              if (header.getAttribute("aria-expanded") === "true") {
                content.style.maxHeight = content.scrollHeight + "px";
              }
            });
            observer.observe(content, {
              childList: true,
              subtree: true,
              characterData: true,
            });
          });

          const activeTab = document.querySelector(".tab-content.active");
          if (activeTab) {
            refreshCollapsibleHeights(activeTab);
          }

          // Recalculate max-heights on resize (for fluid content)
          window.addEventListener("resize", () => {
            const currentTab = document.querySelector(".tab-content.active");
            if (currentTab) {
              refreshCollapsibleHeights(currentTab);
            }
          });
        })();

        // Initial chart update
        updateChart();
      });
    </script>
  </body>
</html>
