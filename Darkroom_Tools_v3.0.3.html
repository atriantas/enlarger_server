<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Darkroom Timer</title>
    <style>
      /* ===== CONSOLIDATED STYLES FOR REDUCED REDUNDANCY ===== */
      /* The following similar classes have been consolidated:
         1. Input fields: .input-field + .settings-input merged
         2. List containers: .profile-list + .chemical-preset-list merged
         3. List items: .list-item + .chemical-preset-item merged
         4. Toggle buttons: .btn-toggle consolidates .paper-btn, .dilution-btn, 
            .paper-size-btn, .preset-btn, .method-btn
         5. Action buttons: .btn-action consolidates .chemical-preset-btn, 
            .shelf-life-btn, .profile-btn
         6. Flexible buttons: .btn-flex consolidates .capacity-btn, .repeat-btn
         All variants use the same base styles with class-specific overrides.
      */

      /* ===== CSS VARIABLES - PRECISE MATCH TO ORIGINAL ===== */
      :root {
        /* Dark Scheme (Original Default) - EXACT matches */
        --bg: #000;
        --text: #f00;
        --text-secondary: #900;

        --accent: #f00;
        --accent-dark: #700;

        --panel: #100;
        --panel-light: #200;

        --border: #300;
        --border-light: #400;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #300, #600, #f00);
      }

      /* Light Scheme - EXACT matches to original */
      body.light-scheme {
        --bg: #ffffff;
        --text: rgb(0, 0, 0);
        --text-secondary: rgb(60, 60, 60);

        --accent: rgb(38, 133, 228);
        --accent-dark: rgb(89, 90, 92);

        --panel: rgb(243, 243, 243);
        --panel-light: rgb(255, 255, 255);

        --border: rgb(154, 195, 255);
        --border-light: rgb(184, 192, 209);

        --warning: #ff5500;

        --slider-track: linear-gradient(
          to right,
          rgb(0, 25, 51),
          rgb(0, 49, 102),
          rgb(0, 157, 255)
        );
      }

      /* Day Scheme - EXACT matches to original */
      body.day-scheme {
        --bg: #000000;
        --text: rgb(255, 255, 255);
        --text-secondary: rgb(194, 194, 194);

        --accent: rgb(255, 207, 118);
        --accent-dark: rgb(89, 90, 92);

        --panel: rgb(24, 24, 24);
        --panel-light: rgb(107, 107, 107);

        --border: rgb(201, 148, 0);
        --border-light: rgb(162, 116, 24);

        --warning: #ff5500;

        --slider-track: linear-gradient(
          to right,
          rgb(51, 32, 0),
          rgb(102, 61, 0),
          rgb(255, 157, 0)
        );
      }

      /* ===== BASE STYLES (IDENTICAL TO ORIGINAL) ===== */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        line-height: 1.3;
        padding: 6px;
        min-height: 100vh;
        transition: background-color 0.3s, color 0.3s;
      }

      .container {
        max-width: 480px;
        margin: 0 auto;
      }

      /* ===== HEADER (EXACT MATCH) ===== */
      header {
        text-align: center;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--border);
      }

      h1 {
        font-size: 1.2rem;
        margin-bottom: 3px;
      }

      .subtitle {
        font-size: 0.7rem;
        color: var(--text-secondary);
      }

      /* ===== TABS (EXACT MATCH) ===== */
      .tabs {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        margin-bottom: 8px;
        border-bottom: 1px solid var(--border);
        gap: 2px;
      }

      .tab-button {
        flex: 0 0 auto;
        min-width: 70px;
        padding: 6px 8px;
        background: var(--bg);
        color: var(--text-secondary);
        border: none;
        border-bottom: 2px solid transparent;
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
        font-size: 0.8rem;
        cursor: pointer;
        transition: all 0.2s ease;
        white-space: nowrap;
      }

      .tab-button:first-child {
        border-left: none;
      }

      .tab-button:last-child {
        border-right: none;
      }

      .tab-button.active {
        color: var(--title);
        border-bottom: 2px solid var(--title);
        background: var(--border);
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      /* ===== CALCULATOR CONTROLS (EXACT MATCH) ===== */
      .control {
        margin-bottom: 10px;
      }

      /* control-label now consolidated with settings-label */

      .slider {
        width: 100%;
        height: 24px;
        appearance: none;
        -webkit-appearance: none;
        background: transparent;
      }

      .slider::-webkit-slider-runnable-track {
        width: 100%;
        height: 3px;
        background: var(--slider-track);
      }

      .slider::-webkit-slider-thumb {
        appearance: none;
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--bg);
        border: 2px solid var(--accent);
        margin-top: -8px;
      }

      /* Unified result display containers */
      .result,
      .chemical-result-box,
      .info-box {
        text-align: center;
        background: var(--panel);
        border-radius: 3px;
        padding: 8px;
      }

      .result {
        margin: 12px 0;
        padding: 10px;
        border-radius: 4px;
      }

      .info-box {
        border: 1px solid var(--border);
        padding: 6px;
      }

      .chemical-result-box {
        background: var(--border);
        border: 1px solid var(--border-light);
      }

      .result-value {
        margin: 3px 0;
      }

      /* ===== INCREMENTAL TIMER (EXACT MATCH) ===== */
      .incremental-timer {
        background: var(--panel);
        padding: 10px;
        border-radius: 4px;
        margin-top: 12px;
      }

      .timer-status {
        font-size: 0.8rem;
        color: var(--text);
        text-align: center;
        margin-bottom: 8px;
        font-weight: bold;
      }

      .timer-display {
        font-size: 2.5rem;
        font-family: monospace;
        font-weight: bold;
        text-align: center;
        margin: 10px 0;
        color: var(--text);
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .timer-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }

      /* ===== BUTTON STYLES (EXACT MATCH) ===== */
      .exp-btn {
        flex: 1;
        padding: 8px;
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 3px;
        font-size: 0.8rem;
        cursor: pointer;
        min-width: 120px;
      }

      .exp-btn.active {
        background: var(--border-light);
        border-color: var(--accent);
      }

      .exp-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .exp-btn.warning {
        border-color: var(--warning);
        animation: pulse 1s infinite;
      }

      .exp-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 10px;
      }

      /* info-box and chemical-result-box now consolidated with result */

      /* Unified small label class - consolidates info-label, result-label, chemical-result-label, step-label */
      .label-sm,
      .info-label,
      .result-label,
      .chemical-result-label,
      .step-label {
        font-size: 0.65rem;
        color: var(--text-secondary);
        margin-bottom: 3px;
      }

      /* Unified value display class - consolidates info-value, result-value, chemical-result-value, step-value */
      .value-display,
      .info-value,
      .result-value,
      .chemical-result-value,
      .step-value {
        font-family: monospace;
        font-weight: bold;
        color: var(--text);
      }

      /* Size variants for value displays */
      .value-display {
        font-size: 0.8rem;
      }

      .info-value,
      .step-value {
        font-size: 0.85rem;
      }

      .result-value,
      .chemical-result-value {
        font-size: 1.2rem;
      }

      /* ===== TIMER GRID (EXACT MATCH) ===== */
      .timer-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 8px;
        height: 320px;
        margin-bottom: 10px;
      }

      .timer-box {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 4px;
        padding: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
      }

      /* Disabled state - black and red only */
      .timer-box.disabled {
        opacity: 0.2;
        background: var(--border-light);
      }

      .timer-box.disabled .timer-title {
        color: var(--border-light);
      }

      .timer-box.disabled .time-display {
        color: var(--border-light);
      }

      .timer-box.disabled .adjust-btn,
      .timer-box.disabled .timer-btn {
        background: var(--border-light);
        border-color: var(--border-light);
        color: var(--text-secondary);
        cursor: not-allowed;
      }

      /* Unified title classes */
      .title-sm,
      .timer-title {
        font-size: 0.75rem;
        color: var(--text);
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .title-md,
      .settings-title {
        font-size: 0.9rem;
        color: var(--title);
        margin-bottom: 8px;
        text-transform: uppercase;
      }

      .time-display {
        font-size: 1.6rem;
        font-family: monospace;
        font-weight: bold;
        color: var(--text);
        margin: 4px 0;
        text-align: center;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .timer-controls-2 {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .adjust-row {
        display: flex;
        gap: 6px;
        margin-bottom: 2px;
      }

      .adjust-btn {
        flex: 1;
        padding: 3px 4px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        color: var(--text-secondary);
        border-radius: 3px;
        font-size: 0.65rem;
        cursor: pointer;
      }

      .adjust-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .adjust-btn:active:not(:disabled) {
        background: var(--panel-light);
      }

      .action-row {
        display: flex;
        gap: 6px;
      }

      .timer-btn {
        flex: 1;
        padding: 4px;
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 3px;
        font-size: 0.7rem;
        cursor: pointer;
        white-space: nowrap;
      }

      .timer-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .timer-btn.active {
        background: var(--border);
        border-color: var(--accent);
      }

      /* Timer states */
      .timer-box.running {
        border-color: var(--accent);
        background: var(--panel-light);
      }

      .timer-box.warning {
        border-color: var(--warning);
        animation: pulse 1s infinite;
      }

      .timer-box.complete {
        border-color: var(--accent);
        background: var(--border);
      }

      /* ===== SETTINGS PANEL (EXACT MATCH) ===== */
      .settings-panel {
        background: var(--panel);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
      }

      .settings-section {
        margin-bottom: 10px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 10px;
      }

      .settings-section:last-child {
        border-bottom: none;
      }

      /* settings-title now uses .title-md */

      .settings-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }

      .settings-item {
        display: flex;
        flex-direction: column;
        gap: 3px;
      }

      /* Unified label for form controls */
      .control-label,
      .settings-label {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }

      .control-label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 3px;
      }

      /* Base input field (consolidated) */
      .input-field,
      .settings-input {
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 3px;
        color: var(--text);
        padding: 4px 6px;
        font-size: 0.8rem;
        font-family: monospace;
      }

      .input-field:focus,
      .settings-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      .settings-input.time-input {
        text-align: center;
      }

      /* Unified list container - consolidates profile-list, chemical-preset-list, shelf-life-list */
      .list-container,
      .profile-list,
      .chemical-preset-list,
      .shelf-life-list {
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 3px;
        max-height: 200px;
        overflow-y: auto;
        margin-bottom: 10px;
      }

      .shelf-life-list {
        background: var(--panel-light);
        margin-top: 10px;
      }

      /* Unified list item - consolidates profile-item, chemical-preset-item, shelf-life-item */
      .list-item-base,
      .profile-item,
      .chemical-preset-item,
      .shelf-life-item,
      .list-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 8px;
        border-bottom: 1px solid var(--border);
        font-size: 0.75rem;
      }

      .shelf-life-item {
        padding: 8px;
        border-bottom: 1px solid var(--border);
      }

      .profile-item:last-child {
        border-bottom: none;
      }

      .profile-item.active {
        background: var(--border);
        font-weight: bold;
      }

      .settings-btn {
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 3px;
        padding: 6px 12px;
        font-size: 0.8rem;
        cursor: pointer;
        width: 100%;
      }

      .settings-btn.primary {
        background: var(--border-light);
        border-color: var(--accent);
      }

      .settings-btn.danger {
        background: var(--border);
        border-color: var(--accent);
      }

      .settings-btn-group {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .settings-btn-group .settings-btn {
        flex: 1;
      }

      .global-controls {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .global-btn {
        flex: 1;
        padding: 8px;
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 3px;
        font-size: 0.75rem;
        cursor: pointer;
        text-transform: uppercase;
      }

      /* ===== TIMER SETTINGS (EXACT MATCH) ===== */
      .timer-settings {
        display: flex;
        justify-content: space-between;
        background: var(--panel);
        padding: 6px 8px;
        border-radius: 4px;
        margin-bottom: 10px;
      }

      /* setting-item now uses .item-container */

      /* Unified medium label class - consolidates setting-label, sound-label, preview-label */
      .label-md,
      .setting-label,
      .sound-label,
      .preview-label {
        font-size: 0.7rem;
        white-space: nowrap;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 28px;
        height: 14px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider-switch {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--border);
        transition: 0.2s;
        border-radius: 14px;
      }

      .slider-switch:before {
        position: absolute;
        content: "";
        height: 10px;
        width: 10px;
        left: 2px;
        bottom: 2px;
        background-color: var(--bg);
        transition: 0.2s;
        border-radius: 50%;
      }

      input:checked + .slider-switch {
        background-color: var(--accent);
      }

      input:checked + .slider-switch:before {
        transform: translateX(14px);
      }

      /* ===== CHEMICAL CALCULATOR (EXACT MATCH) ===== */
      .chemical-calculator {
        background: var(--panel);
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
      }

      .chemical-results,
      .test-strip-preview-container {
        background: var(--panel-light);
        padding: 10px;
        border-radius: 4px;
        margin-top: 12px;
      }

      .test-strip-preview-container {
        background: var(--panel);
        margin: 12px 0;
      }

      /* chemical-result-box now consolidated with result */

      /* chemical-result-label now uses .label-sm */
      /* chemical-result-value now uses unified value classes */

      /* test-strip-preview-container now consolidated with chemical-results */

      .test-strip-preview {
        display: flex;
        height: 60px;
        margin: 10px 0;
        border: 1px solid var(--border);
        border-radius: 3px;
        overflow: hidden;
      }

      .test-step {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: background-color 0.3s;
      }

      .test-step.active {
        background: var(--border-light) !important;
      }

      .step-time {
        font-size: 0.6rem;
        font-weight: bold;
        color: var(--bg);
        text-align: center;
        z-index: 2;
      }

      .step-stop {
        font-size: 0.6rem;
        color: var(--bg);
        margin-top: 2px;
      }

      /* ===== COLOR SCHEME SELECTOR (EXACT MATCH) ===== */
      .color-scheme-selector {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 10px;
      }

      .color-scheme-btn {
        padding: 8px;
        border: 2px solid transparent;
        border-radius: 4px;
        background: var(--panel-light);
        color: var(--text);
        cursor: pointer;
        font-size: 0.75rem;
        text-align: center;
      }

      .color-scheme-btn.active {
        border-color: var(--title);
        font-weight: bold;
      }

      /* ===== JSON BUTTONS (EXACT MATCH) ===== */
      .json-buttons {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .json-btn {
        flex: 1;
        padding: 8px 12px;
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 3px;
        font-size: 0.8rem;
        cursor: pointer;
      }

      /* ===== FULLSCREEN BUTTON (EXACT MATCH) ===== */
      .fullscreen-btn {
        padding: 8px 16px;
        background: var(--border-light);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 3px;
        font-size: 0.8rem;
        cursor: pointer;
        text-transform: uppercase;
        margin-top: 10px;
        width: 100%;
      }

      /* ===== FOOTER (EXACT MATCH) ===== */
      footer {
        text-align: center;
        margin-top: 10px;
        padding-top: 6px;
        border-top: 1px solid var(--border);
        font-size: 0.6rem;
        color: var(--text-secondary);
      }

      /* ===== ANIMATIONS (EXACT MATCH) ===== */
      @keyframes pulse {
        0% {
          border-color: var(--warning);
        }
        50% {
          border-color: var(--warning);
        }
        100% {
          border-color: var(--warning);
        }
      }

      /* ===== THE REST OF THE ORIGINAL STYLES WITH VARIABLES ===== */

      /* Chart styles */
      .chart-container {
        overflow-x: auto;
        margin-bottom: 10px;
      }

      .time-table {
        width: 100%;
        min-width: 400px;
        border-collapse: collapse;
        font-size: 0.7rem;
      }

      .time-table th,
      .time-table td {
        padding: 5px 3px;
        text-align: center;
        border-bottom: 1px solid var(--border);
      }

      .time-table th {
        background: var(--panel-light);
        color: var(--text);
        border-bottom: 1px solid var(--border);
        white-space: nowrap;
      }

      .time-table tr:nth-child(even) {
        background: var(--panel);
      }

      .current-stop {
        background: var(--panel-light) !important;
        font-weight: bold;
      }

      /* increment-cell can use .label-sm */

      /* Unified flex control groups */
      .sound-controls,
      .preview-controls {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
      }

      .preview-controls {
        justify-content: space-between;
        align-items: center;
      }

      .sound-label {
        color: var(--text-secondary);
      }

      /* Height calculator specific styles */
      .height-factor-display {
        font-size: 1.2rem;
        font-family: monospace;
        font-weight: bold;
        color: var(--accent);
        text-align: center;
        margin: 5px 0;
      }

      /* F-stop dropdown styles */
      .fstop-select {
        width: 100%;
        padding: 4px 6px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 3px;
        color: var(--text);
        font-size: 0.8rem;
        font-family: monospace;
        text-align: center;
        cursor: pointer;
        margin-top: 8px;
      }

      /* Repeat button styling - now uses .btn-flex alias */

      /* Unified panel-base class for all panel-style containers */
      .panel-base,
      .panel-container,
      .contrast-calculator,
      .chemical-presets,
      .capacity-tracker,
      .shelf-life-tracker,
      .instructions-panel,
      .incremental-timer {
        background: var(--panel);
        padding: 10px;
        border-radius: 3px;
        margin-top: 10px;
      }

      /* Special case: chemical calculator uses different background */
      .chemical-calculator {
        background: var(--panel);
        padding: 10px;
        border-radius: 3px;
        margin-top: 10px;
      }

      /* Incremental timer - removed override, uses panel-base margin-top: 10px */

      /* Unified grid-2col class for 2-column layouts */
      .grid-2col,
      .paper-selector,
      .method-selector,
      .paper-size-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }

      .method-selector {
        margin-top: 8px;
        margin-bottom: 0;
      }

      /* Base toggle button (consolidated for all variants) */
      .btn-toggle,
      .paper-btn,
      .dilution-btn,
      .paper-size-btn,
      .preset-btn,
      .method-btn {
        padding: 8px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 3px;
        color: var(--text);
        cursor: pointer;
        text-align: center;
        font-size: 0.75rem;
      }

      .btn-toggle.active,
      .paper-btn.active,
      .dilution-btn.active,
      .paper-size-btn.active,
      .preset-btn.active,
      .method-btn.active {
        background: var(--border);
        border-color: var(--border-light);
        font-weight: bold;
      }

      /* Chemical management styles */
      .dilution-selector {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 10px;
      }

      /* Unified flex-gap class */
      .flex-gap,
      .custom-dilution,
      .capacity-controls,
      .custom-paper-size {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .capacity-controls {
        margin: 10px 0;
      }

      .custom-dilution input {
        flex: 1;
        text-align: center;
        padding: 4px 6px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 3px;
        color: var(--text);
        font-size: 0.8rem;
        font-family: monospace;
      }

      /* Unified input focus already handled by .input-field:focus */

      /* Chemical Preset Styles - now using consolidated classes */
      .list-item,
      .chemical-preset-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 6px 8px;
        border-bottom: 1px solid var(--border);
        font-size: 0.75rem;
      }

      .list-item:last-child,
      .chemical-preset-item:last-child {
        border-bottom: none;
      }

      .list-item.active,
      .chemical-preset-item.active {
        background: var(--panel-light);
      }

      /* Unified flex-row class for action buttons */
      .flex-row,
      .chemical-preset-actions,
      .shelf-life-actions,
      .profile-actions {
        display: flex;
        gap: 6px;
      }

      /* Base action button (consolidated) */
      .btn-action,
      .chemical-preset-btn,
      .shelf-life-btn,
      .profile-btn {
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--accent);
        border-radius: 3px;
        padding: 2px 6px;
        font-size: 0.65rem;
        cursor: pointer;
      }

      .btn-action.delete,
      .profile-btn.delete {
        border-color: var(--accent);
        color: var(--accent);
      }

      .shelf-life-btn,
      .profile-btn {
        padding: 3px 6px;
        font-size: 0.65rem;
        min-width: 50px;
      }

      /* Base flexible button (consolidated) */
      .btn-flex,
      .capacity-btn,
      .repeat-btn {
        flex: 1;
        padding: 8px;
        background: var(--border);
        border: 1px solid var(--border-light);
        border-radius: 3px;
        color: var(--text);
        font-size: 0.75rem;
        cursor: pointer;
      }

      .btn-flex:disabled,
      .capacity-btn:disabled,
      .repeat-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .progress-container {
        height: 8px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
        margin: 10px 0;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: var(--accent);
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-labels,
      .test-progress-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
        color: var(--text-secondary);
        margin-top: 5px;
      }

      /* Paper Size Selector */
      .paper-size-selector {
        margin-top: 10px;
        margin-bottom: 10px;
      }

      .custom-paper-size {
        margin-top: 8px;
      }

      .custom-paper-size input,
      .custom-dilution input {
        flex: 1;
        text-align: center;
      }

      .shelf-life-list {
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 3px;
        max-height: 200px;
        overflow-y: auto;
        margin-top: 10px;
      }

      .list-item-base:last-child,
      .profile-item:last-child,
      .chemical-preset-item:last-child,
      .shelf-life-item:last-child,
      .list-item:last-child {
        border-bottom: none;
      }

      .shelf-life-item.expiring {
        background: var(--panel-light);
        border-left: 3px solid var(--accent);
      }

      .shelf-life-item.expired {
        background: var(--panel);
        border-left: 3px solid var(--accent);
        animation: pulse 2s infinite;
      }

      .shelf-life-days {
        font-weight: bold;
        font-family: monospace;
      }

      .shelf-life-days.expiring {
        color: var(--warning);
      }

      .shelf-life-days.expired {
        color: var(--accent);
      }

      .shelf-life-actions {
        display: flex;
        gap: 4px;
      }

      /* .shelf-life-btn now uses .btn-action with padding override */

      /* F-STOP TEST STRIP GENERATOR STYLES */
      /* preview-controls now consolidated with sound-controls */

      /* Unified small display groups */
      .preview-legend,
      .preview-options {
        display: flex;
        gap: 8px;
      }

      .preview-legend {
        gap: 15px;
      }

      .preview-options {
        align-items: center;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.7rem;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 3px;
      }

      /* preview-options now consolidated with preview-legend */

      .preview-label {
        color: var(--text-secondary);
      }

      .test-timer-display,
      .current-step-info {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 10px 0;
      }

      .current-step-info {
        text-align: center;
        flex: 1;
        justify-content: center;
      }

      /* step-label now uses .label-sm, step-value uses unified value classes */

      .test-progress-container {
        margin: 15px 0;
      }

      .test-progress-bar {
        height: 6px;
        background: var(--border);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
      }

      /* test-progress-labels now consolidated with progress-labels */

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--border-light), var(--accent));
        width: 0%;
        transition: width 0.5s ease;
      }

      .test-presets,
      .relay-controls {
        background: var(--panel-light);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
      }

      .test-presets {
        background: var(--panel-light);
        margin-top: 10px;
        margin-bottom: 0;
      }

      .preset-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      /* Method selector styles */
      .method-selector {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 5px;
      }

      /* Countdown display styles */
      .countdown-active {
        animation: countdown-pulse 1s infinite;
      }

      @keyframes countdown-pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Auto advance toggle specific styles */
      .control .switch {
        margin-top: 5px;
        align-self: center;
      }

      .control .slider-switch {
        background-color: var(--border);
      }

      .control input:checked + .slider-switch {
        background-color: var(--accent);
      }

      /* Visual feedback for auto advance toggle */
      #autoAdvanceToggle:checked + .slider-switch {
        animation: pulse-glow 2s infinite;
      }

      @keyframes pulse-glow {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
        }
      }

      /* Light scheme adjustment */
      body.light-scheme #autoAdvanceToggle:checked + .slider-switch {
        animation: pulse-glow-light 2s infinite;
      }

      @keyframes pulse-glow-light {
        0% {
          box-shadow: 0 0 0 0 rgba(0, 102, 204, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(0, 102, 204, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(0, 102, 204, 0);
        }
      }

      /* Day scheme adjustment */
      body.day-scheme #autoAdvanceToggle:checked + .slider-switch {
        animation: pulse-glow-day 2s infinite;
      }

      @keyframes pulse-glow-day {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 204, 0, 0.7);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(255, 204, 0, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 204, 0, 0);
        }
      }

      /* For the timer tab profiles section */
      #timer .settings-section {
        margin-top: 15px;
        background: var(--panel);
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 8px;
      }

      /* Adjust timer grid height when profiles are visible */
      #timer .timer-grid {
        height: 280px; /* Reduced slightly to accommodate profiles */
      }

      /* ===== FULLSCREEN STYLES ===== */
      body.fullscreen-mode {
        padding: 0;
      }

      /* Container: use a single canonical set of rules for fullscreen */
      body.fullscreen-mode .container {
        max-width: none;
        margin: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* container shouldn't scroll; tab content should */
      }

      /* Tabs should stay at top in fullscreen */
      body.fullscreen-mode .tabs {
        border-bottom: 1px solid var(--border);
        margin-bottom: 0;
        flex-shrink: 0;
      }

      body.fullscreen-mode .tab-button {
        padding: 12px 3px;
      }

      /* Hide header and footer in fullscreen */
      body.fullscreen-mode header,
      body.fullscreen-mode footer {
        display: none;
      }

      /* Tab content: scrollable and flexible in fullscreen */
      body.fullscreen-mode .tab-content.active {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 8px;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
      }

      /* Ensure tab contents are scrollable by default in fullscreen */
      body.fullscreen-mode .tab-content {
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
      }

      /* Timer tab specific adjustments */
      body.fullscreen-mode #timer.tab-content.active {
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
      }

      /* Make the timer grid flexible within fullscreen layout */
      body.fullscreen-mode #timer .timer-grid {
        flex: 1;
        min-height: 0;
        height: auto;
        margin-bottom: 8px;
      }

      /* Timer settings and profiles: keep visible and non-scrolling internally */
      body.fullscreen-mode #timer .settings-section {
        flex-shrink: 0;
        margin-top: 8px;
        margin-bottom: 8px;
        padding: 10px;
        background: var(--panel);
        border-radius: 4px;
        max-height: none;
        overflow-y: visible;
      }

      /* Tab-specific small adjustments (calc/chart/chemical/test) */
      body.fullscreen-mode #calc.tab-content.active,
      body.fullscreen-mode #chart.tab-content.active,
      body.fullscreen-mode #fstop-test.tab-content.active,
      body.fullscreen-mode #chemical.tab-content.active,
      body.fullscreen-mode #settings.tab-content.active {
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* Relay styles remain outside fullscreen concerns */
      /* relay-controls now consolidated with test-presets */

      .relay-item,
      .shelf-life-item {
        padding: 8px;
        margin-bottom: 8px;
        border-bottom: 1px solid var(--border);
      }

      .relay-item:last-child,
      .shelf-life-item:last-child {
        border-bottom: none;
      }

      .relay-toggle-btn {
        min-width: 80px;
      }

      .relay-toggle-btn.on {
        background: var(--border-light);
        border-color: var(--accent);
      }

      /* Settings tab adjustments */
      body.fullscreen-mode #settings.tab-content.active {
        overflow-y: auto;
        overflow-x: hidden;
      }

      body.fullscreen-mode #timer .timer-settings {
        flex-shrink: 0;
        margin-bottom: 8px;
      }

      body.fullscreen-mode #timer .global-controls {
        flex-shrink: 0;
        margin: 8px 0;
      }

      body.fullscreen-mode #timer .settings-section {
        display: block !important; /* Force show the profiles section */
        flex-shrink: 0;
        max-height: none; /* Remove max height restriction */
        overflow-y: visible; /* Don't scroll inside, let the whole page scroll */
        margin-top: 8px;
        margin-bottom: 8px;
        padding: 10px;
        background: var(--panel);
        border-radius: 4px;
        position: relative; /* Normal flow positioning */
        top: auto;
        bottom: auto;
      }

      /* Additional styles for fullscreen profiles */
      body.fullscreen-mode .profile-list {
        max-height: 150px; /* Limit height and make scrollable */
        overflow-y: auto;
      }

      /* Improve profile item visibility in fullscreen */
      body.fullscreen-mode .profile-item {
        padding: 6px 8px;
        font-size: 0.75rem;
      }

      body.fullscreen-mode .profile-actions {
        display: flex;
        gap: 4px;
      }

      body.fullscreen-mode .profile-btn {
        min-width: 50px;
        padding: 3px 6px;
        font-size: 0.7rem;
      }

      /* Mobile adjustments for fullscreen with profiles */
      @media (max-width: 400px) {
        body.fullscreen-mode #timer .timer-grid {
          height: auto; /* Maintain flexible height */
          min-height: 320px; /* ensure space for 2x2 grid */
          display: grid; /* keep 2-column grid in fullscreen on mobile */
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          gap: 6px;
        }

        body.fullscreen-mode #timer .settings-section {
          max-height: none; /* Changed from 30vh */
          margin-bottom: 20px; /* Add some space at the bottom */
        }
      }

      /* Desktop adjustments */
      @media (min-width: 401px) {
        .setting-label .short-text {
          display: none;
        }

        /* Fullscreen mode adjustments for desktop */
        body.fullscreen-mode .timer-grid {
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          height: auto; /* Changed from calc(100vh - 120px) */
        }

        /* Ensure timer tab can scroll and the grid can flex in fullscreen on wider screens */
        body.fullscreen-mode #timer.tab-content.active {
          display: flex;
          flex-direction: column;
          min-height: 0; /* allow flex children to shrink */
          overflow-y: auto; /* enable scrolling if content overflows */
          -webkit-overflow-scrolling: touch;
        }

        body.fullscreen-mode #timer .timer-grid {
          flex: 0 0 auto; /* let grid size by content so the parent tab scrolls */
          min-height: 0; /* allow flex shrink when necessary */
          overflow: visible; /* no internal scrolling; let the tab handle scrolling */
        }

        body.fullscreen-mode .timer-title {
          font-size: 1rem;
        }

        body.fullscreen-mode .time-display {
          font-size: 2.5rem;
        }

        body.fullscreen-mode .timer-btn,
        body.fullscreen-mode .adjust-btn {
          padding: 8px;
          font-size: 0.9rem;
        }

        body.fullscreen-mode #timer .timer-grid {
          height: auto; /* Changed from calc(65vh - 120px) */
        }

        body.fullscreen-mode #timer .settings-section {
          max-height: none; /* Changed from 30vh */
        }
      }

      /* ===== MOBILE STYLES - EXACT MATCH ===== */
      @media (max-width: 400px) {
        /* Timer grid */
        .timer-grid {
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          height: auto;
          min-height: 400px;
          margin-bottom: 8px;
        }

        /* Timer controls */
        .timer-controls-2 {
          width: 100%;
          display: flex;
          flex-direction: column;
          gap: 4px;
          margin-top: 4px;
        }

        .adjust-row {
          display: flex;
          gap: 4px;
          margin-bottom: 3px;
        }

        .action-row {
          display: flex;
          gap: 4px;
        }

        /* Timer buttons */
        .timer-btn,
        .adjust-btn {
          padding: 6px 4px;
          font-size: 0.75rem;
        }

        .time-display {
          font-size: 1.8rem;
          margin: 8px 0;
        }

        .timer-title {
          font-size: 0.85rem;
          margin-bottom: 6px;
        }

        /* Global controls */
        .global-controls {
          display: flex;
          gap: 6px;
          margin: 12px 0;
          flex-direction: row;
        }

        .global-btn {
          padding: 10px;
          font-size: 0.85rem;
        }

        /* Short text for mobile */
        .setting-label .full-text {
          display: none;
        }

        .setting-label .short-text {
          display: block;
        }

        /* Timer Profiles Section */
        #timer .settings-section {
          margin-top: 15px;
          padding: 12px;
          margin-bottom: 8px;
        }

        .settings-title {
          font-size: 0.85rem;
          margin-bottom: 10px;
        }

        .settings-group {
          grid-template-columns: 1fr;
          gap: 8px;
          margin-bottom: 10px;
        }

        .profile-list {
          max-height: 150px;
        }

        .profile-item {
          padding: 8px;
          font-size: 0.75rem;
        }

        .profile-actions {
          flex-direction: row;
          gap: 6px;
        }

        .profile-btn {
          min-width: 45px;
          padding: 4px 8px;
          font-size: 0.7rem;
        }

        /* Adjust timer grid height when profiles are visible */
        #timer .timer-grid {
          height: auto;
          min-height: 320px;
        }

        /* Ensure content doesn't overflow */
        .container {
          padding-bottom: 10px;
        }

        /* Adjust for better scrolling if needed */
        #timer.tab-content.active {
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }

        /* Chart container */
        .chart-container {
          margin-left: -6px;
          margin-right: -6px;
        }

        .time-table {
          min-width: 380px;
        }

        /* Calculator info - 2 columns on mobile */
        .exp-info {
          grid-template-columns: 1fr 1fr;
          gap: 4px;
        }

        /* Settings - 2 columns on mobile */
        .settings-group {
          grid-template-columns: 1fr 1fr;
          gap: 6px;
        }

        .profile-actions {
          flex-direction: row;
        }

        .profile-btn {
          min-width: 40px;
          font-size: 0.65rem;
          padding: 2px 4px;
        }

        /* Global buttons */
        .global-controls {
          flex-direction: column;
        }

        /* Chemical management mobile adjustments */
        .dilution-selector {
          grid-template-columns: repeat(2, 1fr);
        }

        .chemical-results-grid {
          grid-template-columns: 1fr;
        }

        .capacity-controls {
          flex-direction: column;
        }

        /* Fullscreen mode adjustments for mobile */
        body.fullscreen-mode {
          padding: 0;
        }

        body.fullscreen-mode .container {
          padding: 0;
        }

        body.fullscreen-mode .tabs {
          margin-bottom: 0;
          border-bottom: none;
        }

        body.fullscreen-mode .tab-button {
          padding: 10px 3px;
          font-size: 0.9rem;
        }

        body.fullscreen-mode .timer-title {
          font-size: 0.9rem;
        }

        body.fullscreen-mode .time-display {
          font-size: 2rem;
        }

        /* Test strip mobile adjustments */
        .test-timer-display {
          flex-direction: column;
          gap: 5px;
        }

        .test-progress-labels span {
          font-size: 0.5rem;
        }

        .preset-buttons {
          grid-template-columns: 1fr;
        }

        .paper-selector {
          grid-template-columns: 1fr;
        }

        /* Method selector mobile */
        .method-selector {
          grid-template-columns: 1fr 1fr;
          gap: 6px;
        }

        /* Chemical preset mobile adjustments */
        .paper-size-buttons {
          grid-template-columns: 1fr;
        }

        .chemical-preset-actions {
          flex-direction: column;
          gap: 2px;
        }

        .chemical-preset-btn {
          padding: 1px 4px;
          font-size: 0.6rem;
        }
      }

      /* Fine adjustment slider styles */
      .fine-slider {
        height: 16px !important;
        margin-top: 3px !important;
      }

      .fine-slider::-webkit-slider-runnable-track {
        height: 2px !important;
        background: linear-gradient(to right, #300, #600, #900) !important;
      }

      .fine-slider::-webkit-slider-thumb {
        width: 14px !important;
        height: 14px !important;
        margin-top: -6px !important;
        border-width: 1px !important;
      }

      .fine-slider-labels {
        display: flex;
        justify-content: space-between;
        margin-top: 3px;
        padding: 0 5px;
      }

      .fine-slider-label {
        font-size: 0.6rem;
        color: var(--text-secondary);
        transition: all 0.2s;
      }

      .fine-slider-label.active {
        font-weight: bold;
        color: var(--accent);
      }

      /* Adjust info-box height to accommodate both sliders */
      .info-box {
        min-height: 50px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* Collapsible rows in CALC tab */
      .collapsible {
        border-top: 1px solid var(--border);
        margin-top: 10px;
        padding-top: 6px;
      }
      .collapsible-header {
        width: 100%;
        text-align: left;
        background: transparent;
        border: none;
        color: var(--text);
        font-weight: bold;
        padding: 8px 6px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95rem;
      }
      .collapsible-header::after {
        content: "â–¾";
        transition: transform 0.2s ease;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }
      .collapsible-header[aria-expanded="false"]::after {
        transform: rotate(-90deg);
      }
      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.28s ease;
        max-height: 0;
      }
      .collapsible .exp-info {
        margin-top: 6px;
      }
      .collapsible .info-box {
        margin-bottom: 6px;
      }
      .collapsible-header:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      @media (max-width: 400px) {
        .collapsible-header {
          font-size: 1rem;
          padding: 10px 6px;
        }
      }

      /* -------------------------------------------------------------
         Controls: Segmented control (increment selectors)
         - Clear, accessible focus styles using --accent
         - Responsive adjustments for small screens
         - Small wrap behavior so controls remain usable on narrow widths
         ------------------------------------------------------------- */
      .segmented-control {
        display: inline-flex;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
        background: var(--panel);
        align-items: center;
        gap: 0; /* buttons are visually separated by borders */
      }

      .segmented-control .segmented-btn {
        background: transparent;
        border: none;
        padding: 8px 12px;
        cursor: pointer;
        color: var(--text);
        font-size: 0.9rem;
        min-width: 44px;
        text-align: center;
        line-height: 1;
      }

      .segmented-control .segmented-btn:not(:last-child) {
        border-right: 1px solid var(--border);
      }

      .segmented-control .segmented-btn.active,
      .segmented-control .segmented-btn[aria-pressed="true"] {
        background: var(--border-light);
        color: var(--accent);
      }

      /* Prefer the more semantic :focus-visible when available */
      .segmented-control .segmented-btn:focus {
        outline: none;
      }
      .segmented-control .segmented-btn:focus-visible {
        /* Use accent color for the outline if available, with a subtle shadow for depth */
        outline: 2px solid var(--accent);
        box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.12);
        z-index: 1;
      }

      /* Mobile / narrow layout: slightly smaller tappable targets and allow wrapping */
      @media (max-width: 420px) {
        .segmented-control {
          flex-wrap: wrap;
          justify-content: center;
        }
        .segmented-control .segmented-btn {
          padding: 6px 8px;
          min-width: 36px;
          font-size: 0.85rem;
        }
        .segmented-control-container {
          gap: 6px;
        }
      }

      /* Container for segmented controls (centers buttons) */
      .segmented-control-container {
        margin-top: 6px;
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
      }

      /* Accessibility helper: visually-hidden */
      .visually-hidden {
        position: absolute !important;
        height: 1px;
        width: 1px;
        overflow: hidden;
        clip: rect(1px, 1px, 1px, 1px);
        white-space: nowrap;
        border: 0;
        padding: 0;
        margin: -1px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>CYANOWOOD TIMER & TOOLS</h1>
      </header>

      <!-- Accessibility: live status for settings updates -->
      <div
        id="settingsLiveStatus"
        class="visually-hidden"
        aria-live="polite"
        aria-atomic="true"
      ></div>

      <div class="tabs">
        <button class="tab-button active" data-tab="calc">CALC</button>
        <button class="tab-button" data-tab="fstop-test">TEST</button>
        <button class="tab-button" data-tab="timer">TIMER</button>
        <button class="tab-button" data-tab="relay">CONTROL</button>
        <button class="tab-button" data-tab="chemical">CHEMICAL</button>
        <button class="tab-button" data-tab="chart">CHART</button>
        <button class="tab-button" data-tab="settings">SETTINGS</button>
      </div>

      <!-- Calculator Tab with Incremental Exposure Timer -->
      <div id="calc" class="tab-content active">
        <div class="control">
          <div class="control-label">
            <span>BASE TIME</span>
            <span class="value-display" id="baseTimeValue">10.0s</span>
          </div>
          <input
            type="range"
            min="0.4"
            max="50"
            step="0.1"
            value="10"
            class="slider"
            id="baseTimeSlider"
          />
        </div>

        <div class="control">
          <div class="control-label">
            <span>STOP ADJUST</span>
            <span class="value-display" id="stopValue">0.0</span>
          </div>
          <input
            type="range"
            min="-6"
            max="6"
            step="1"
            value="0"
            class="slider"
            id="stopSlider"
          />

          <!-- Dynamic ruler that will be populated based on selected increment denominator -->
          <div
            id="calcStopRuler"
            style="
              display: flex;
              justify-content: space-between;
              margin-top: 5px;
              padding: 0 5px;
            "
          >
            <!-- labels populated by JS -->
          </div>

          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="calcIncrementSeg"
              role="tablist"
              aria-label="Calc stop increment"
            >
              <button
                type="button"
                class="segmented-btn"
                data-denom="1"
                aria-pressed="false"
              >
                1
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="2"
                aria-pressed="false"
              >
                1/2
              </button>
              <button
                type="button"
                class="segmented-btn active"
                data-denom="3"
                aria-pressed="true"
              >
                1/3
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="4"
                aria-pressed="false"
              >
                1/4
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="6"
                aria-pressed="false"
              >
                1/6
              </button>
            </div>
          </div>
        </div>

        <div class="result">
          <div class="result-label">SELECTED EXPOSURE</div>
          <div class="result-value" id="resultTime">10.00</div>
          <div class="result-label" id="resultDetails">BASE (0.0 stops)</div>
        </div>

        <!-- Simplified Incremental Exposure Timer -->
        <div class="incremental-timer">
          <div class="timer-status" id="timerStatus">READY FOR EXPOSURE</div>
          <div class="timer-display" id="calcTimerDisplay">10.00</div>

          <div class="sound-controls">
            <div>
              <div class="sound-label">3s Beeps</div>
              <label class="switch">
                <input type="checkbox" id="calcWarningBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
            <div>
              <div class="sound-label">End Beep</div>
              <label class="switch">
                <input type="checkbox" id="calcEndBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
          </div>

          <div class="timer-controls">
            <button class="exp-btn" id="startExposure">Start Exposure</button>
            <button class="exp-btn" id="stopCalcTimer" disabled>Stop</button>
            <button class="exp-btn" id="resetCalcTimer">Reset</button>
            <button class="repeat-btn" id="repeatExposure" disabled>
              Repeat Last
            </button>
          </div>

          <!-- Simplified Information Display -->
          <div class="exp-info">
            <div class="info-box">
              <div class="info-label">Selected Stop</div>
              <div class="info-value" id="selectedStopDisplay">0.0</div>
            </div>
            <div class="info-box">
              <div class="info-label">Previous Total</div>
              <div class="info-value" id="previousTotalDisplay">0.00</div>
            </div>
            <div class="info-box">
              <div class="info-label">Current Total</div>
              <div class="info-value" id="currentTotalDisplay">10.00</div>
            </div>
            <div class="info-box">
              <div class="info-label">This Exposure</div>
              <div class="info-value" id="thisExposureDisplay">10.00</div>
            </div>
          </div>
        </div>

        <!-- MODIFIED ENLARGER HEIGHT CALCULATOR WITH CONTRAST CONTROL INTEGRATED -->
        <div class="incremental-timer" style="margin-top: 10px">
          <div class="timer-status">ENLARGER & CONTRAST CALCULATOR</div>

          <!-- Original Settings Section -->
          <div class="info-box">
            <div class="info-label">Original Time (s)</div>
            <div class="info-value" id="originalTimeValue">10.00</div>
            <div style="display: flex; gap: 5px; margin-top: 5px">
              <button
                class="adjust-btn"
                id="copyCurrentTime"
                style="flex: 1; font-size: 0.6rem; padding: 2px 4px"
              >
                Use Current
              </button>
            </div>
          </div>

          <!-- Height Adjustments -->
          <section class="collapsible" data-id="head-height">
            <button class="collapsible-header" aria-expanded="false">
              Head Height
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="info-label">Original Height (cm)</div>
                  <div class="info-value" id="originalHeightValue">30.0</div>
                  <div style="margin-top: 5px">
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-bottom: 2px;
                      "
                    >
                      Coarse adjustment
                    </div>
                    <input
                      type="range"
                      min="10"
                      max="60"
                      step="1"
                      value="30"
                      class="slider"
                      id="originalHeightCoarseSlider"
                    />
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-top: 3px;
                        margin-bottom: 2px;
                      "
                    >
                      Fine adjustment (Â±0.5cm)
                    </div>
                    <input
                      type="range"
                      min="-5"
                      max="5"
                      step="1"
                      value="0"
                      class="slider"
                      id="originalHeightFineSlider"
                      style="height: 16px"
                    />
                  </div>
                </div>
                <div class="info-box">
                  <div class="info-label">New Height (cm)</div>
                  <div class="info-value" id="newHeightValue">30.0</div>
                  <div style="margin-top: 5px">
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-bottom: 2px;
                      "
                    >
                      Coarse adjustment
                    </div>
                    <input
                      type="range"
                      min="10"
                      max="60"
                      step="1"
                      value="30"
                      class="slider"
                      id="newHeightCoarseSlider"
                    />
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-top: 3px;
                        margin-bottom: 2px;
                      "
                    >
                      Fine adjustment (Â±0.5cm)
                    </div>
                    <input
                      type="range"
                      min="-5"
                      max="5"
                      step="1"
                      value="0"
                      class="slider"
                      id="newHeightFineSlider"
                      style="height: 16px"
                    />
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- F-Stop Adjustment -->
          <section class="collapsible" data-id="fstop">
            <button class="collapsible-header" aria-expanded="false">
              F-Stop Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="info-label">Original F-Stop</div>
                  <select class="fstop-select" id="originalFStop">
                    <option value="2.8">f/2.8</option>
                    <option value="4">f/4</option>
                    <option value="5.6" selected>f/5.6</option>
                    <option value="8">f/8</option>
                    <option value="11">f/11</option>
                    <option value="16">f/16</option>
                    <option value="22">f/22</option>
                    <option value="32">f/32</option>
                  </select>
                </div>
                <div class="info-box">
                  <div class="info-label">New F-Stop</div>
                  <select class="fstop-select" id="newFStop">
                    <option value="2.8">f/2.8</option>
                    <option value="4">f/4</option>
                    <option value="5.6" selected>f/5.6</option>
                    <option value="8">f/8</option>
                    <option value="11">f/11</option>
                    <option value="16">f/16</option>
                    <option value="22">f/22</option>
                    <option value="32">f/32</option>
                  </select>
                </div>
              </div>
            </div>
          </section>

          <!-- Paper Size Adjustment -->
          <section class="collapsible" data-id="paper-size">
            <button class="collapsible-header" aria-expanded="false">
              Paper Size Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 0"
              >
                <!-- Original Paper Size -->
                <div class="info-box">
                  <div class="info-label">Original Paper Size</div>
                  <select class="fstop-select" id="originalPaperSize">
                    <option value="0.011">3.5Ã—5" (0.011 mÂ²)</option>
                    <option value="0.013">4Ã—5" (0.013 mÂ²)</option>
                    <option value="0.023">5Ã—7" (0.023 mÂ²)</option>
                    <option value="0.052" selected>8Ã—10" (0.052 mÂ²)</option>
                    <option value="0.099">11Ã—14" (0.099 mÂ²)</option>
                    <option value="0.206">16Ã—20" (0.206 mÂ²)</option>
                    <option value="custom">Custom size...</option>
                  </select>
                  <!-- ADD "style" attribute to this div -->
                  <div
                    id="originalCustomPaperSize"
                    style="display: none; margin-top: 5px"
                  >
                    <input
                      type="number"
                      min="0.001"
                      max="1"
                      step="0.001"
                      value="0.052"
                      class="settings-input"
                      id="originalCustomPaperSizeValue"
                      placeholder="mÂ²"
                      style="width: 80px; font-size: 0.7rem"
                    />
                    <button
                      class="adjust-btn"
                      id="setOriginalCustomPaper"
                      style="font-size: 0.6rem; padding: 2px 4px"
                    >
                      Set
                    </button>
                  </div>
                </div>

                <!-- New Paper Size -->
                <div class="info-box">
                  <div class="info-label">New Paper Size</div>
                  <select class="fstop-select" id="newPaperSize">
                    <option value="0.011">3.5Ã—5" (0.011 mÂ²)</option>
                    <option value="0.013">4Ã—5" (0.013 mÂ²)</option>
                    <option value="0.023">5Ã—7" (0.023 mÂ²)</option>
                    <option value="0.052" selected>8Ã—10" (0.052 mÂ²)</option>
                    <option value="0.099">11x14" (0.099 mÂ²)</option>
                    <option value="0.206">16x20" (0.206 mÂ²)</option>
                    <option value="custom">Custom size...</option>
                  </select>
                  <!-- ADD "style" attribute to this div -->
                  <div
                    id="newCustomPaperSize"
                    style="display: none; margin-top: 5px"
                  >
                    <input
                      type="number"
                      min="0.001"
                      max="1"
                      step="0.001"
                      value="0.052"
                      class="settings-input"
                      id="newCustomPaperSizeValue"
                      placeholder="mÂ²"
                      style="width: 80px; font-size: 0.7rem"
                    />
                    <button
                      class="adjust-btn"
                      id="setNewCustomPaper"
                      style="font-size: 0.6rem; padding: 2px 4px"
                    >
                      Set
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- CONTRAST CONTROL INTEGRATED -->
          <section class="collapsible" data-id="contrast-filter">
            <button class="collapsible-header" aria-expanded="false">
              Contrast Filter Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="info-label">Paper Type</div>
                  <div class="paper-selector" style="margin-top: 5px">
                    <button
                      class="paper-btn active"
                      data-paper="fomaspeed"
                      id="btnFomaspeed"
                    >
                      FOMASPEED<br />Variant III
                    </button>
                    <button
                      class="paper-btn"
                      data-paper="fomatonemg"
                      id="btnFomatonemg"
                    >
                      FOMATONE MG<br />Classic
                    </button>
                  </div>
                </div>
                <div class="info-box">
                  <div class="info-label">Contrast Filter</div>
                  <select class="fstop-select" id="contrastFilterSelect">
                    <option value="2xY">2Ã—Y</option>
                    <option value="Y">Y</option>
                    <option value="none" selected>No filter</option>
                    <option value="M1">M1</option>
                    <option value="2xM1">2Ã—M1</option>
                    <option value="M2">M2</option>
                    <option value="2xM2">2Ã—M2</option>
                  </select>
                  <div
                    class="exp-info"
                    style="grid-template-columns: 1fr 1fr; margin-top: 5px"
                  >
                    <div class="info-box" style="padding: 3px">
                      <div class="info-label">ISO R</div>
                      <div class="info-value" id="isoValue">105</div>
                    </div>
                    <div class="info-box" style="padding: 3px">
                      <div class="info-label">Contrast Factor</div>
                      <div class="info-value" id="filterFactorValue">1.0Ã—</div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- Combined Factors Display -->
          <div
            class="timer-status"
            style="font-size: 0.65rem; margin-top: 15px"
          >
            Factors & Time
          </div>
          <div
            class="exp-info"
            style="grid-template-columns: 1fr 1fr 1fr 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="info-label">Height Factor</div>
              <div class="info-value" id="heightFactorDisplay">1.00x</div>
            </div>
            <div class="info-box">
              <div class="info-label">F-Stop Factor</div>
              <div class="info-value" id="fstopFactor">1.00x</div>
            </div>
            <div class="info-box">
              <div class="info-label">Paper Factor</div>
              <div class="info-value" id="paperSizeFactor">1.00x</div>
            </div>
            <div class="info-box">
              <div class="info-label">Contrast Factor</div>
              <div class="info-value" id="filterFactorValueDisplay">1.00x</div>
            </div>
          </div>

          <div
            class="exp-info"
            style="grid-template-columns: 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="info-label">Combined Factor</div>
              <div class="info-value" id="combinedFactor">1.00x</div>
            </div>
          </div>

          <div
            class="exp-info"
            style="grid-template-columns: 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="info-label">New Adjusted Time (s)</div>
              <div class="info-value" id="newAdjustedTime">10.00</div>
              <div
                style="
                  font-size: 0.6rem;
                  color: var(--text-secondary);
                  margin-top: 3px;
                "
              >
                Formula: Original Time Ã— (New Height Ã· Original Height)Â² Ã— (New
                F-Stop Ã· Original F-Stop)Â² Ã— (âˆšNew Paper Area Ã· âˆšOriginal Paper
                Area)Â² Ã— Filter Factor
              </div>
            </div>
          </div>

          <div style="margin-top: 10px; text-align: center">
            <button
              class="exp-btn"
              id="applyHeightTime"
              style="margin-bottom: 5px"
            >
              Apply Adjusted Time as Base Time
            </button>
            <div
              style="
                font-size: 0.6rem;
                color: var(--text-secondary);
                margin-top: 3px;
              "
            >
              Example: 10s at 30cm, f/5.6, No filter â†’ 22.5s at 45cm, f/5.6, No
              filter<br />
              Example with filter: 10s at f/5.6 â†’ 14s with Y filter (1.4Ã—
              factor)
            </div>
          </div>
        </div>
      </div>

      <!-- Chart Tab with Incremental Time Column -->
      <div id="chart" class="tab-content">
        <!-- BASE TIME slider removed per user request -->
        <div
          class="chart-note"
          role="note"
          title="This chart uses the main BASE TIME control in the CALC tab."
          aria-label="Chart uses base time from CALC"
          style="
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
          "
        >
          â“˜ Uses BASE TIME from CALC tab
        </div>

        <div class="chart-container">
          <table class="time-table" id="timeTable">
            <thead>
              <tr>
                <th>STOP</th>
                <th>TOTAL TIME</th>
                <th>+/- FROM BASE</th>
                <th>INCREMENT</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- F-Stop Test Strip Generator Tab -->
      <div id="fstop-test" class="tab-content">
        <div class="control">
          <div class="control-label">
            <span>BASE TIME</span>
            <span class="value-display" id="testBaseValue">10.0s</span>
          </div>
          <input
            type="range"
            min="1"
            max="50"
            step="0.5"
            value="10"
            class="slider"
            id="testBaseSlider"
          />
        </div>

        <div class="control">
          <div class="control-label">
            <span>INCREMENT (in stops)</span>
            <span class="value-display" id="testIncrementValue">â…“ stop</span>
          </div>
          <input
            type="range"
            min="1"
            max="9"
            step="1"
            value="1"
            class="slider"
            id="testIncrementSlider"
          />

          <!-- Dynamic ruler populated by JS based on denominator -->
          <div
            id="testIncrementRuler"
            style="
              display: flex;
              justify-content: space-between;
              margin-top: 5px;
              padding: 0 5px;
            "
          >
            <!-- labels populated by JS -->
          </div>

          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="testIncrementSeg"
              role="tablist"
              aria-label="Test stop increment"
            >
              <button
                type="button"
                class="segmented-btn"
                data-denom="1"
                aria-pressed="false"
              >
                1
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="2"
                aria-pressed="false"
              >
                1/2
              </button>
              <button
                type="button"
                class="segmented-btn active"
                data-denom="3"
                aria-pressed="true"
              >
                1/3
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="4"
                aria-pressed="false"
              >
                1/4
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="6"
                aria-pressed="false"
              >
                1/6
              </button>
            </div>
          </div>
        </div>

        <div class="control">
          <div class="control-label">
            <span>NUMBER OF STEPS</span>
            <span class="value-display" id="testStepsValue">6</span>
          </div>
          <input
            type="range"
            min="3"
            max="12"
            step="1"
            value="6"
            class="slider"
            id="testStepsSlider"
          />
        </div>

        <!-- NEW: Method Selector -->
        <div class="control">
          <div class="control-label">
            <span>METHOD</span>
            <span class="value-display" id="testMethodValue">Cumulative</span>
          </div>
          <div class="method-selector">
            <button class="method-btn active" data-method="cumulative">
              Cumulative
            </button>
            <button class="method-btn" data-method="incremental">
              Incremental
            </button>
          </div>
        </div>

        <!-- NEW: Auto Advance Toggle -->
        <div class="control">
          <div class="control-label">
            <span>AUTO ADVANCE</span>
            <span class="value-display" id="autoAdvanceValue">OFF</span>
          </div>
          <label class="switch">
            <input type="checkbox" id="autoAdvanceToggle" />
            <span class="slider-switch"></span>
          </label>
          <div
            style="
              font-size: 0.6rem;
              color: var(--text-secondary);
              margin-top: 3px;
              text-align: center;
            "
          >
            <span id="autoAdvanceDescription">Pause after each step</span>
          </div>
        </div>

        <div class="result">
          <div class="result-label">TEST STRIP SEQUENCE</div>
          <div class="result-value" id="testSequenceInfo">6 steps Ã— â…“ stop</div>
          <div class="result-label" id="testTimeRange">10.00s to 31.75s</div>
        </div>

        <!-- UPDATED: Instructions Panel with Auto Advance Info -->
        <div class="instructions-panel">
          <div class="timer-status">INSTRUCTIONS</div>
          <div id="methodInstructions">
            <div
              class="cumulative-instructions"
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                line-height: 1.3;
                padding: 5px;
              "
            >
              <strong>CUMULATIVE METHOD:</strong><br />
              â€¢ Expose each strip for its total time<br />
              â€¢
              <span id="cumulativeAdvanceText"
                >Auto-advance: OFF - Press Next Step between exposures</span
              >
            </div>
            <div
              class="incremental-instructions"
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                line-height: 1.3;
                padding: 5px;
                display: none;
              "
            >
              <strong>INCREMENTAL METHOD:</strong><br />
              â€¢ First strip: expose for base time<br />
              â€¢ Slide mask, expose next strip for difference<br />
              â€¢
              <span id="incrementalAdvanceText"
                >Auto-advance: OFF - Press Next Step after sliding mask</span
              >
            </div>
          </div>
          <div
            style="
              margin-top: 5px;
              font-size: 0.6rem;
              color: #600;
              text-align: center;
            "
          >
            <span id="autoAdvanceStatus"
              >Current: Manual Advance (press 'A' to toggle)</span
            >
          </div>
        </div>

        <!-- Visual Test Strip Preview -->
        <div class="test-strip-preview-container">
          <div class="timer-status">TEST STRIP LAYOUT</div>
          <div class="test-strip-preview" id="testStripPreview">
            <!-- Will be populated by JavaScript -->
          </div>
          <div class="preview-controls">
            <div class="preview-legend">
              <div class="legend-item">
                <span class="legend-color" style="background: #300"></span>
                <span class="legend-label">Exposed</span>
              </div>
              <div class="legend-item">
                <span class="legend-color" style="background: #000"></span>
                <span class="legend-label">Masked</span>
              </div>
            </div>
            <div class="preview-options">
              <label class="switch">
                <input type="checkbox" id="previewMode" checked />
                <span class="slider-switch"></span>
              </label>
              <span class="preview-label">Show Times</span>
            </div>
          </div>
        </div>

        <!-- Test Strip Timer Controls -->
        <div class="incremental-timer" style="margin-top: 10px">
          <div class="timer-status" id="testTimerStatus">
            READY FOR TEST STRIP
          </div>
          <div class="test-timer-display">
            <div class="current-step-info">
              <div class="step-label">Current Step</div>
              <div class="step-value" id="currentStepDisplay">1/6</div>
            </div>
            <div class="timer-display" id="testTimerDisplay">10.00</div>
            <div class="current-step-info">
              <div class="step-label">Time</div>
              <div class="step-value" id="currentTimeDisplay">10.00s</div>
            </div>
          </div>

          <div class="test-progress-container">
            <div class="test-progress-bar" id="testProgressBar">
              <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="test-progress-labels">
              <span id="progressStart">10.0s</span>
              <span id="progressMiddle">19.0s</span>
              <span id="progressEnd">31.8s</span>
            </div>
          </div>

          <div class="sound-controls">
            <div>
              <div class="sound-label">3s Beeps</div>
              <label class="switch">
                <input type="checkbox" id="testWarningBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
            <div>
              <div class="sound-label">Step Beeps</div>
              <label class="switch">
                <input type="checkbox" id="testStepBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
            <div>
              <div class="sound-label">End Beep</div>
              <label class="switch">
                <input type="checkbox" id="testEndBeep" checked />
                <span class="slider-switch"></span>
              </label>
            </div>
          </div>

          <div class="timer-controls">
            <button class="exp-btn" id="startTestStrip">
              Start Test Strip
            </button>
            <button class="exp-btn" id="stopTestTimer" disabled>Stop</button>
            <button class="exp-btn" id="resetTestTimer">Reset</button>
          </div>

          <!-- Test Strip Information -->
          <div class="exp-info">
            <div class="info-box">
              <div class="info-label">Step Size</div>
              <div class="info-value" id="stepSizeDisplay">0.0 stops</div>
            </div>
            <div class="info-box">
              <div class="info-label">Current Stop</div>
              <div class="info-value" id="currentStopDisplay">0.0</div>
            </div>
            <div class="info-box">
              <div class="info-label">Time Multiplier</div>
              <div class="info-value" id="timeMultiplierDisplay">1.00Ã—</div>
            </div>
            <div class="info-box">
              <div class="info-label">Total Time</div>
              <div class="info-value" id="totalTestTimeDisplay">68.3s</div>
            </div>
          </div>

          <!-- Test Strip Presets -->
          <div class="test-presets">
            <div class="timer-status" style="margin-bottom: 8px">
              QUICK PRESETS
            </div>
            <div class="preset-buttons">
              <button class="preset-btn" data-preset="standard">
                Standard: 6Ã—â…“ stop
              </button>
              <button class="preset-btn" data-preset="fine">
                Fine: 8Ã—Â¼ stop
              </button>
              <button class="preset-btn" data-preset="coarse">
                Coarse: 5Ã—Â½ stop
              </button>
              <button class="preset-btn" data-preset="full">
                Full Range: 10Ã—1 stop
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- UPDATED: CHEMICAL MANAGEMENT TAB -->
      <div id="chemical" class="tab-content">
        <!-- Mix Calculator -->
        <section class="collapsible" data-id="chemical-mix">
          <button class="collapsible-header" aria-expanded="false">
            CHEMICAL MIX CALCULATOR
          </button>
          <div class="collapsible-content">
            <div class="chemical-calculator">
              <div class="timer-status">CHEMICAL MIX CALCULATOR</div>

              <div class="control">
                <div class="control-label">
                  <span>TOTAL VOLUME</span>
                  <span class="value-display" id="totalVolumeValue"
                    >1000ml</span
                  >
                </div>
                <input
                  type="range"
                  min="100"
                  max="5000"
                  step="50"
                  value="1000"
                  class="slider"
                  id="totalVolumeSlider"
                />
              </div>

              <div
                class="timer-status"
                style="font-size: 0.75rem; margin-bottom: 8px"
              >
                DILUTION RATIO
              </div>
              <div class="dilution-selector">
                <button class="dilution-btn active" data-ratio="1+9">
                  1+9 (1:10)
                </button>
                <button class="dilution-btn" data-ratio="1+14">
                  1+14 (1:15)
                </button>
                <button class="dilution-btn" data-ratio="1+19">
                  1+19 (1:20)
                </button>
                <button class="dilution-btn" data-ratio="1+24">
                  1+24 (1:25)
                </button>
                <button class="dilution-btn" data-ratio="1+29">
                  1+29 (1:30)
                </button>
                <button class="dilution-btn" data-ratio="1+39">
                  1+39 (1:40)
                </button>
              </div>

              <div
                class="timer-status"
                style="font-size: 0.75rem; margin-top: 10px; margin-bottom: 5px"
              >
                OR CUSTOM RATIO
              </div>
              <div class="custom-dilution">
                <input
                  type="number"
                  min="1"
                  max="100"
                  value="1"
                  class="settings-input"
                  id="customStockParts"
                  placeholder="Stock"
                />
                <div style="color: var(--text-secondary); align-self: center">
                  +
                </div>
                <input
                  type="number"
                  min="1"
                  max="100"
                  value="9"
                  class="settings-input"
                  id="customWaterParts"
                  placeholder="Water"
                />
              </div>

              <div class="chemical-results">
                <div class="timer-status" style="font-size: 0.75rem">
                  MIXING INSTRUCTIONS
                </div>
                <div class="chemical-results-grid">
                  <div class="chemical-result-box">
                    <div class="chemical-result-label">STOCK SOLUTION</div>
                    <div class="chemical-result-value" id="stockVolume">
                      100ml
                    </div>
                  </div>
                  <div class="chemical-result-box">
                    <div class="chemical-result-label">WATER</div>
                    <div class="chemical-result-value" id="waterVolume">
                      900ml
                    </div>
                  </div>
                </div>
                <div
                  style="
                    font-size: 0.6rem;
                    color: --text-secondary;
                    text-align: center;
                    margin-top: 8px;
                  "
                >
                  Add stock to water, not water to stock
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Chemical Presets Section - NEW -->
        <section class="collapsible" data-id="chemical-presets">
          <button class="collapsible-header" aria-expanded="false">
            CHEMICAL PRESETS
          </button>
          <div class="collapsible-content">
            <div class="chemical-presets">
              <div class="timer-status">CHEMICAL PRESETS</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Preset Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="chemicalPresetName"
                    placeholder="Enter preset name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn" id="saveChemicalPreset">
                    Save Current as Preset
                  </button>
                </div>
              </div>

              <div
                class="timer-status"
                style="font-size: 0.75rem; margin-top: 10px"
              >
                SAVED PRESETS
              </div>
              <div class="chemical-preset-list" id="chemicalPresetList">
                <!-- Chemical presets will be listed here -->
              </div>

              <div class="settings-btn-group" style="margin-top: 10px">
                <button class="settings-btn danger" id="clearChemicalPresets">
                  Clear All Chemical Presets
                </button>
              </div>
            </div>
          </div>
        </section>

        <!-- UPDATED: Developer Capacity Tracker with Paper Area Calculations -->
        <section class="collapsible" data-id="capacity-tracker">
          <button class="collapsible-header" aria-expanded="false">
            DEVELOPER CAPACITY TRACKER
          </button>
          <div class="collapsible-content">
            <div class="capacity-tracker">
              <div class="timer-status">DEVELOPER CAPACITY TRACKER</div>

              <div class="control">
                <div class="control-label">
                  <span>CAPACITY (mÂ² per liter)</span>
                  <span class="value-display" id="capacityValue">0.5</span>
                </div>
                <input
                  type="range"
                  min="0.1"
                  max="40"
                  step="0.1"
                  value="0.5"
                  class="slider"
                  id="capacitySlider"
                />
              </div>

              <div class="control">
                <div class="control-label">
                  <span>TRAY VOLUME (ml)</span>
                  <span class="value-display" id="trayVolumeValue">1000</span>
                </div>
                <input
                  type="range"
                  min="100"
                  max="5000"
                  step="100"
                  value="1000"
                  class="slider"
                  id="trayVolumeSlider"
                />
              </div>

              <!-- NEW: Paper Size Selector -->
              <div class="paper-size-selector">
                <div class="paper-size-buttons">
                  <button class="paper-size-btn" data-size="0.011">
                    3.5x5" (0.011 mÂ²)
                  </button>
                  <button class="paper-size-btn active" data-size="0.013">
                    4x5" (0.013 mÂ²)
                  </button>
                  <button class="paper-size-btn" data-size="0.023">
                    5x7" (0.023 mÂ²)
                  </button>
                  <button class="paper-size-btn" data-size="0.052">
                    8x10" (0.052 mÂ²)
                  </button>
                  <!-- CHANGED -->
                  <button class="paper-size-btn" data-size="0.099">
                    11x14" (0.099 mÂ²)
                  </button>
                  <!-- CHANGED -->
                  <button class="paper-size-btn" data-size="0.206">
                    16x20" (0.206 mÂ²)
                  </button>
                  <!-- CHANGED -->
                </div>
                <div class="custom-paper-size">
                  <!-- Chemical tab capacity tracker custom paper size -->
                  <input
                    type="number"
                    min="0.001"
                    max="1"
                    step="0.001"
                    value="0.052"
                    class="settings-input"
                    id="customPaperSize"
                    placeholder="Custom mÂ²"
                  />
                  <button class="paper-size-btn" id="useCustomSize">Use</button>
                </div>
              </div>

              <div class="result" style="margin: 10px 0">
                <div class="result-label">MAX PRINTS THIS BATCH</div>
                <div class="result-value" id="maxPrintsValue">6</div>
                <div class="result-label" id="printsRemaining">
                  6 prints remaining (0.48 mÂ²)
                </div>
              </div>

              <div class="progress-container">
                <div
                  class="progress-bar"
                  id="capacityProgressBar"
                  style="width: 0%"
                ></div>
              </div>
              <div class="progress-labels">
                <span>0</span>
                <span id="capacityMiddleLabel">3</span>
                <span id="capacityMaxLabel">6</span>
              </div>

              <div class="capacity-controls">
                <button class="capacity-btn" id="addPrint">+1 Print</button>
                <button class="capacity-btn" id="add5Prints">+5 Prints</button>
                <button class="capacity-btn" id="resetPrints">Reset</button>
              </div>

              <div class="exp-info" style="margin-top: 12px">
                <div class="info-box">
                  <div class="info-label">Prints Done</div>
                  <div class="info-value" id="printsDoneValue">0</div>
                </div>
                <div class="info-box">
                  <div class="info-label">Area Used</div>
                  <div class="info-value" id="areaUsedValue">0.00 mÂ²</div>
                </div>
                <div class="info-box">
                  <div class="info-label">% Used</div>
                  <div class="info-value" id="percentUsedValue">0%</div>
                </div>
                <div class="info-box">
                  <div class="info-label">Status</div>
                  <div class="info-value" id="capacityStatus">Fresh</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- UPDATED: Shelf Life Tracker with Custom Chemical Name -->
        <section class="collapsible" data-id="shelf-life">
          <button class="collapsible-header" aria-expanded="false">
            SHELF LIFE TRACKER
          </button>
          <div class="collapsible-content">
            <div class="shelf-life-tracker">
              <div class="timer-status">SHELF LIFE TRACKER</div>

              <div class="settings-group" style="margin-top: 10px">
                <div class="settings-item">
                  <div class="settings-label">Chemical</div>
                  <select class="settings-input" id="chemicalType">
                    <option value="developer">Developer</option>
                    <option value="stopbath">Stop Bath</option>
                    <option value="fixer">Fixer</option>
                    <option value="hypoclear">Hypo Clear</option>
                    <option value="photof">Photo Wash</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
                <div
                  class="settings-item"
                  id="customChemicalNameContainer"
                  style="display: none"
                >
                  <div class="settings-label">Custom Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="customChemicalName"
                    placeholder="Enter chemical name"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Shelf Life (days)</div>
                  <input
                    type="number"
                    min="1"
                    max="365"
                    value="30"
                    class="settings-input"
                    id="shelfLifeDays"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Date Mixed/Opened</div>
                  <input
                    type="date"
                    class="settings-input"
                    id="chemicalDate"
                    value=""
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button
                    class="settings-btn"
                    id="addChemical"
                    style="margin-top: 0"
                  >
                    Add Chemical
                  </button>
                </div>
              </div>

              <div
                class="timer-status"
                style="font-size: 0.75rem; margin-top: 15px"
              >
                ACTIVE CHEMICALS
              </div>
              <div class="shelf-life-list" id="shelfLifeList">
                <!-- Chemicals will be listed here -->
              </div>

              <div style="margin-top: 10px; text-align: center">
                <button class="exp-btn" id="clearExpired">Clear Expired</button>
                <div
                  style="
                    font-size: 0.6rem;
                    color: var(--text-secondary);
                    margin-top: 5px;
                  "
                >
                  Red items expired, orange expire in 3 days
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Timer Tab with Photo Wash Toggle AND Timer Profiles -->
      <div id="timer" class="tab-content">
        <div class="timer-settings">
          <div class="setting-item">
            <div class="setting-label">
              <span class="full-text">Auto</span>
              <span class="short-text">Auto</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="autoStart" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span class="full-text">End Beep</span>
              <span class="short-text">End</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="endBeep" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span class="full-text">10s Beep</span>
              <span class="short-text">10s</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="warningBeep" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
          <div class="setting-item">
            <div class="setting-label">
              <span class="full-text">Photo Wash</span>
              <span class="short-text">Flo</span>
            </div>
            <label class="switch">
              <input type="checkbox" id="photoFloToggle" checked />
              <span class="slider-switch"></span>
            </label>
          </div>
        </div>

        <div class="timer-grid">
          <!-- Developer Timer -->
          <div class="timer-box" id="timerDev">
            <div class="timer-title">Developer</div>
            <div class="time-display" id="displayDev">01:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="adjust-btn" data-timer="Dev" data-action="minus">
                  -5s
                </button>
                <button class="adjust-btn" data-timer="Dev" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="action-row">
                <button class="timer-btn" id="btnDev">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Dev"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Stop Bath Timer -->
          <div class="timer-box" id="timerStop">
            <div class="timer-title">Stop Bath</div>
            <div class="time-display" id="displayStop">00:30</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button
                  class="adjust-btn"
                  data-timer="Stop"
                  data-action="minus"
                >
                  -5s
                </button>
                <button class="adjust-btn" data-timer="Stop" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="action-row">
                <button class="timer-btn" id="btnStop">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Stop"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Fixer Timer -->
          <div class="timer-box" id="timerFix">
            <div class="timer-title">Fixer</div>
            <div class="time-display" id="displayFix">05:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="adjust-btn" data-timer="Fix" data-action="minus">
                  -5s
                </button>
                <button class="adjust-btn" data-timer="Fix" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="action-row">
                <button class="timer-btn" id="btnFix">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Fix"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Photo Wash Timer -->
          <div class="timer-box" id="timerFlo">
            <div class="timer-title">Photo Wash</div>
            <div class="time-display" id="displayFlo">01:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="adjust-btn" data-timer="Flo" data-action="minus">
                  -5s
                </button>
                <button class="adjust-btn" data-timer="Flo" data-action="plus">
                  +5s
                </button>
              </div>
              <div class="action-row">
                <button class="timer-btn" id="btnFlo">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Flo"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="global-controls">
          <button class="global-btn" id="startAll">Start All</button>
          <button class="global-btn" id="resetAll">Reset All</button>
        </div>

        <!-- Timer Profiles Section MOVED from SETTINGS tab -->
        <section class="collapsible" data-id="timer-profiles">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">TIMER PROFILES</div>
          </button>
          <div class="collapsible-content">
            <div class="settings-section" style="margin-top: 15px">
              <div class="settings-title">Timer Profiles</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Profile Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="timerProfileName"
                    placeholder="Enter profile name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn" id="saveTimerProfile">
                    Save Current as Profile
                  </button>
                </div>
              </div>

              <div class="settings-title">Saved Timer Profiles</div>
              <div class="profile-list" id="timerProfileList">
                <!-- Timer profiles will be listed here -->
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn danger" id="clearTimerProfiles">
                  Clear All Timer Profiles
                </button>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Add this new tab content section after the SETTINGS tab content -->
      <div id="relay" class="tab-content">
        <div class="settings-panel">
          <div class="settings-section">
            <div class="settings-title">Relay Control (Manual)</div>
            <div class="relay-controls">
              <div class="relay-item">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 1 (GPIO 25)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay1Name"
                      value="Enlarger Timer"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn relay-toggle-btn"
                      data-relay="1"
                      data-gpio="25"
                      id="toggleRelay1"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="relay-item">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 2 (GPIO 17)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay2Name"
                      value="Safelight"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn relay-toggle-btn"
                      data-relay="2"
                      data-gpio="17"
                      id="toggleRelay2"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="relay-item">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 3 (GPIO 27)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay3Name"
                      value="Ventilation"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn relay-toggle-btn"
                      data-relay="3"
                      data-gpio="27"
                      id="toggleRelay3"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="relay-item">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 4 (GPIO 22)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay4Name"
                      value="White Light"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn relay-toggle-btn"
                      data-relay="4"
                      data-gpio="22"
                      id="toggleRelay4"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>
            </div>

            <div class="settings-group">
              <div class="settings-item">
                <button class="settings-btn" id="allRelaysOn">All ON</button>
              </div>
              <div class="settings-item">
                <button class="settings-btn" id="allRelaysOff">All OFF</button>
              </div>
            </div>
          </div>

          <div class="settings-section">
            <div class="settings-title">Controller Manager</div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Server IP</div>
                <input
                  type="text"
                  class="settings-input"
                  id="relayServerIP"
                  placeholder="192.168.1.xxx"
                  value="192.168.1.100"
                />
              </div>
              <div class="settings-item">
                <div class="settings-label">Server Port</div>
                <input
                  type="number"
                  class="settings-input"
                  id="relayServerPort"
                  value="5000"
                />
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Test Connection</div>
                <button class="settings-btn" id="testRelayConnection">
                  Test
                </button>
              </div>
              <div class="settings-item">
                <div class="settings-label">Status</div>
                <div
                  id="relayStatus"
                  style="color: var(--text-secondary); font-size: 0.8rem"
                >
                  Not connected
                </div>
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <button class="settings-btn warning" id="rebootPi">
                  Reboot Raspberry Pi
                </button>
              </div>
              <div class="settings-item">
                <button class="settings-btn danger" id="shutdownPi">
                  Shutdown Raspberry Pi
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- UPDATED: Settings Tab WITH Countdown Settings AND Auto Advance -->
      <div id="settings" class="tab-content">
        <div class="settings-panel">
          <!-- Fullscreen Section -->
          <div class="settings-section">
            <div class="settings-title">Display</div>
            <button class="fullscreen-btn" id="toggleFullscreen">
              Toggle Fullscreen
            </button>
            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                text-align: center;
                margin-top: 5px;
              "
            >
              Press F11 for desktop fullscreen
            </div>
            <div class="settings-title">Color Scheme</div>
            <div class="color-scheme-selector">
              <button class="color-scheme-btn active" data-scheme="dark">
                Darkroom (Default)
              </button>
              <button class="color-scheme-btn" data-scheme="light">Day</button>
              <button class="color-scheme-btn" data-scheme="day">Night</button>
            </div>
          </div>

          <!-- GLOBAL SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="global-settings">
            <button class="collapsible-header" aria-expanded="false">
              GLOBAL SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Base Time (s)</div>
                  <input
                    type="number"
                    min="1"
                    max="50"
                    step="0.5"
                    class="settings-input"
                    id="settingBaseTime"
                    value="10"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Stop Increment</div>
                  <select id="settingStopIncrement" class="settings-input">
                    <option value="1">1 stop</option>
                    <option value="2">1/2 stop</option>
                    <option value="3">1/3 stop</option>
                    <option value="4">1/4 stop</option>
                    <option value="6">1/6 stop</option>
                  </select>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Countdown Delay (s)</div>
                  <input
                    type="number"
                    min="0"
                    max="30"
                    step="1"
                    class="settings-input"
                    id="settingCountdownDelay"
                    value="5"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Countdown Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingCountdownBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Beep Pattern</div>
                  <select class="settings-input" id="settingCountdownPattern">
                    <option value="every-second">Beep every second</option>
                    <option value="last3">Beep last 3 seconds only</option>
                    <option value="last5">Beep last 5 seconds only</option>
                    <option value="none">No beeps</option>
                  </select>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Test Pattern</div>
                  <button
                    class="settings-btn"
                    id="testCountdownBeep"
                    style="font-size: 0.7rem; padding: 4px 8px"
                  >
                    Test Beep
                  </button>
                </div>
              </div>
            </div>
          </section>

          <!-- CALC SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="calc-settings">
            <button class="collapsible-header" aria-expanded="false">
              CALC SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Base Time Min (s)</div>
                  <input
                    type="number"
                    id="baseTimeMin"
                    class="settings-input"
                    min="0.1"
                    max="10"
                    step="0.1"
                    value="0.4"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Base Time Max (s)</div>
                  <input
                    type="number"
                    id="baseTimeMax"
                    class="settings-input"
                    min="10"
                    max="300"
                    step="1"
                    value="50"
                  />
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Calc 3s Beep</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingCalcWarningBeep"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Calc End Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingCalcEndBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>
            </div>
          </section>

          <!-- TEST STRIP SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="test-strip-settings">
            <button class="collapsible-header" aria-expanded="false">
              TEST STRIP SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Auto Advance</div>
                  <label class="switch">
                    <input type="checkbox" id="settingAutoAdvance" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Auto Advance Delay (s)</div>
                  <input
                    type="number"
                    min="0"
                    max="30"
                    step="1"
                    class="settings-input"
                    id="settingAutoAdvanceDelay"
                    value="1"
                  />
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Test Base Time Min (s)</div>
                  <input
                    type="number"
                    id="testBaseTimeMin"
                    class="settings-input"
                    min="0.5"
                    max="10"
                    step="0.5"
                    value="1"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Test Base Time Max (s)</div>
                  <input
                    type="number"
                    id="testBaseTimeMax"
                    class="settings-input"
                    min="10"
                    max="300"
                    step="1"
                    value="50"
                  />
                </div>
              </div>
            </div>
          </section>

          <!-- TIMER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="timer-settings">
            <button class="collapsible-header" aria-expanded="false">
              TIMER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Developer (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="600"
                    step="5"
                    class="settings-input time-input"
                    id="settingDevTime"
                    value="60"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Stop Bath (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="300"
                    step="5"
                    class="settings-input time-input"
                    id="settingStopTime"
                    value="30"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Fixer (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="600"
                    step="5"
                    class="settings-input time-input"
                    id="settingFixTime"
                    value="300"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Photo Wash (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="300"
                    step="5"
                    class="settings-input time-input"
                    id="settingFloTime"
                    value="60"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Timer Auto Start</div>
                  <label class="switch">
                    <input type="checkbox" id="settingAutoStart" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Timer 10s Beep</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingTimerWarningBeep"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Timer End Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingTimerEndBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Photo Wash</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingDefaultPhotoFlo"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>
            </div>
          </section>

          <!-- CONTROLLER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="controller-settings">
            <button class="collapsible-header" aria-expanded="false">
              CONTROLLER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div
                    id="safelightAutoOffStatus"
                    style="color: var(--text-secondary); font-size: 0.8rem"
                  >
                    Loading...
                  </div>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Safelight Auto-Off</div>
                  <label class="switch">
                    <input type="checkbox" id="safelightAutoOff" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <div
                    style="
                      font-size: 0.7rem;
                      color: var(--text-secondary);
                      text-align: center;
                    "
                  >
                    Turn off safelight when enlarger is on
                  </div>
                </div>
              </div>

              <div class="settings-title" style="margin-top: 12px">
                Auto - Manual Enlarger Control
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Auto-trigger Enlarger</div>
                  <label class="switch">
                    <input type="checkbox" id="autoTriggerRelay" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Test Timer Relay</div>
                  <div style="display: flex; gap: 5px">
                    <input
                      type="number"
                      class="settings-input"
                      id="testTimerSeconds"
                      value="5"
                      min="0.1"
                      max="60"
                      step="0.1"
                      style="flex: 1"
                    />
                    <button class="settings-btn" id="testTimerRelay">
                      Test
                    </button>
                  </div>
                </div>
              </div>

              <div
                style="
                  font-size: 0.7rem;
                  color: var(--text-secondary);
                  margin-top: 10px;
                "
              >
                Note: When enabled, the timer relay (GPIO 25) will automatically
                trigger during countdown timers in CALC and F-STOP TEST tabs.
                Time is sent as a single request with delay parameter for
                maximum accuracy.
              </div>
            </div>
          </section>

          <div class="settings-section">
            <button class="settings-btn primary" id="saveGlobalSettings">
              Save All Settings
            </button>
          </div>

          <!-- UPDATED: Profile & Chemical Presets Sharing Section -->
          <div class="settings-section">
            <div class="settings-title">Profile & Chemical Presets Sharing</div>
            <div class="json-buttons">
              <button class="json-btn" id="exportAllProfiles">
                Export All Data
              </button>
              <button class="json-btn" id="importAllProfiles">
                Import All Data
              </button>
            </div>
            <input
              type="file"
              id="allProfilesFileInput"
              accept=".json"
              style="display: none"
            />
            <div id="allProfilesFeedback" class="json-feedback"></div>

            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                margin-top: 8px;
              "
            >
              Exports Timer Profiles, Chemical Presets, Capacity Tracker, and
              Shelf Life Data in one file
            </div>
          </div>

          <!-- Reset Section -->
          <div class="settings-section">
            <div class="settings-title">Reset</div>
            <button class="settings-btn danger" id="resetAllSettings">
              Reset All Settings
            </button>
            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                text-align: center;
                margin-top: 5px;
              "
            >
              This will reset all settings to defaults and clear all data
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div>DARKROOM TIMER v2.9.1</div>
        <div>
          Height & Aperture & Paper Size & Contrast Calculator: New Time =
          Original Time Ã— (New Height Ã· Original Height)Â² Ã— (New F-Stop Ã·
          Original F-Stop)Â² Ã— (âˆšNew Paper Area Ã· âˆšOriginal Paper Area)Â² Ã— Filter
          Factor
        </div>
        <div>
          Chemical Mix Calculator: Stock = Total Volume Ã· (Stock Parts + Water
          Parts)
        </div>
        <div>
          Capacity Calculator: Max Prints = (Capacity Ã— Tray Volume / 1000) Ã·
          Paper Area
        </div>
        <div>
          Countdown Feature: Configurable 0-30 second delay with audible beeps
          before all timers start
        </div>
        <div>
          Test Strip Auto Advance: Toggle automatic progression between test
          strip steps
        </div>
        <div>
          Data Export: Includes Timer Profiles, Chemical Presets, Capacity
          Tracker, and Shelf Life Data
        </div>
      </footer>
    </div>

    <script>
      // Storage keys - UPDATED
      const STORAGE_KEYS = {
        SETTINGS: "darkroom_timer_settings",
        PROFILES: "darkroom_timer_profiles",
        CURRENT_PROFILE: "darkroom_timer_current_profile",
        COLOR_SCHEME: "darkroom_timer_color_scheme",
        CHEMICAL_PRESETS: "darkroom_timer_chemical_presets",
        CAPACITY_TRACKER: "darkroom_timer_capacity_tracker",
        SHELF_LIFE: "darkroom_timer_shelf_life",
      };

      // Default settings - UPDATED with countdown settings AND auto advance
      const DEFAULT_SETTINGS = {
        baseTime: 10.0,
        devTime: 60,
        stopTime: 30,
        fixTime: 300,
        floTime: 60,
        calcWarningBeep: true,
        calcEndBeep: true,
        autoStart: true,
        timerWarningBeep: true,
        timerEndBeep: true,
        defaultPhotoFlo: true,
        currentProfile: null,
        colorScheme: "dark",
        // Countdown settings
        countdownDelay: 5, // Countdown delay in seconds
        countdownBeep: true, // Countdown beep enabled
        countdownPattern: "every-second", // Countdown beep pattern: 'every-second'|'last3'|'last5'|'none'
        // Test strip auto-advance
        autoAdvance: false,
        autoAdvanceDelay: 1,
        safelightAutoOff: true, // Turn off safelight when enlarger is on
        stopDenominator: 3, // Denominator for f-stop fractions (2, 3, or 4)
        // Base time slider limits
        baseTimeMin: 0.4,
        baseTimeMax: 50,
        // Test base time slider limits
        testBaseTimeMin: 1,
        testBaseTimeMax: 50,
      };

      // Default timer times (seconds)
      const DEFAULT_TIMER_TIMES = {
        Dev: 60,
        Stop: 30,
        Fix: 300,
        Flo: 60,
      };

      // Global variables for timer management
      let settingsManager;
      let timerManager;
      let globalAudioContext = null;

      // Tab management
      const tabButtons = document.querySelectorAll(".tab-button");
      const tabContents = document.querySelectorAll(".tab-content");

      function switchTab(tabId) {
        tabButtons.forEach((btn) => btn.classList.remove("active"));
        tabContents.forEach((content) => content.classList.remove("active"));

        tabButtons.forEach((btn) => {
          if (btn.getAttribute("data-tab") === tabId) {
            btn.classList.add("active");
          }
        });

        document.getElementById(tabId).classList.add("active");

        if (tabId === "chart") {
          updateChart();
        } else if (tabId === "fstop-test") {
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.updateDisplay();
            window.fstopTestGenerator.updateInstructions();
          }
        } else if (tabId === "chemical") {
          if (window.chemicalManager) {
            window.chemicalManager.updateDisplay();
            // Specifically update shelf life list
            window.chemicalManager.updateShelfLifeList();
          }
        } else if (tabId === "timer") {
          if (settingsManager) {
            settingsManager.updateTimerProfileListUI();
          }
        } else if (tabId === "relay") {
          if (window.relayManager) {
            window.relayManager.updateRelayButtons();
          }
        }
      }

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          switchTab(button.getAttribute("data-tab"));
        });
      });

      // Add event listeners for base time limit inputs
      document.addEventListener("DOMContentLoaded", () => {
        const baseTimeMinInput = document.getElementById("baseTimeMin");
        const baseTimeMaxInput = document.getElementById("baseTimeMax");

        if (baseTimeMinInput && baseTimeMaxInput) {
          baseTimeMinInput.addEventListener("change", () => {
            const minVal = parseFloat(baseTimeMinInput.value);
            const maxVal = parseFloat(baseTimeMaxInput.value);
            if (minVal >= maxVal) {
              baseTimeMinInput.value = (maxVal - 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });

          baseTimeMaxInput.addEventListener("change", () => {
            const minVal = parseFloat(baseTimeMinInput.value);
            const maxVal = parseFloat(baseTimeMaxInput.value);
            if (maxVal <= minVal) {
              baseTimeMaxInput.value = (minVal + 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });
        }

        // Add event listeners for test base time limit inputs
        const testBaseTimeMinInput = document.getElementById("testBaseTimeMin");
        const testBaseTimeMaxInput = document.getElementById("testBaseTimeMax");

        if (testBaseTimeMinInput && testBaseTimeMaxInput) {
          testBaseTimeMinInput.addEventListener("change", () => {
            const minVal = parseFloat(testBaseTimeMinInput.value);
            const maxVal = parseFloat(testBaseTimeMaxInput.value);
            if (minVal >= maxVal) {
              testBaseTimeMinInput.value = (maxVal - 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });

          testBaseTimeMaxInput.addEventListener("change", () => {
            const minVal = parseFloat(testBaseTimeMinInput.value);
            const maxVal = parseFloat(testBaseTimeMaxInput.value);
            if (maxVal <= minVal) {
              testBaseTimeMaxInput.value = (minVal + 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });
        }
      });

      // Audio context initialization
      function initAudioContext() {
        if (!globalAudioContext) {
          try {
            globalAudioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
          } catch (e) {
            console.warn("Web Audio API not supported:", e);
          }
        }
        return globalAudioContext;
      }

      // Play beep function - SIMPLIFIED (no settings)
      function playBeep(frequency = 800, duration = 0.1, volume = 0.3) {
        const audioContext = initAudioContext();
        if (!audioContext) return;

        try {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.value = frequency;
          oscillator.type = "sine";

          gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + duration
          );

          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + duration);
        } catch (e) {
          console.warn("Could not play beep:", e);
        }
      }

      // Storage Manager - UPDATED
      class StorageManager {
        // Generic helpers to avoid duplicated try/catch
        static saveJSON(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
          } catch (e) {
            console.error(`Failed to save ${key}:`, e);
            return false;
          }
        }

        static loadJSON(key, fallback) {
          try {
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : fallback;
          } catch (e) {
            console.error(`Failed to load ${key}:`, e);
            return fallback;
          }
        }

        static removeKeys(keys) {
          try {
            keys.forEach((k) => localStorage.removeItem(k));
            return true;
          } catch (e) {
            console.error("Failed to clear storage:", e);
            return false;
          }
        }

        static saveSettings(settings) {
          return this.saveJSON(STORAGE_KEYS.SETTINGS, settings);
        }

        static loadSettings() {
          return this.loadJSON(STORAGE_KEYS.SETTINGS, { ...DEFAULT_SETTINGS });
        }

        static saveProfiles(profiles) {
          return this.saveJSON(STORAGE_KEYS.PROFILES, profiles);
        }

        static loadProfiles() {
          return this.loadJSON(STORAGE_KEYS.PROFILES, []);
        }

        static saveCurrentProfile(profileName) {
          return this.saveJSON(STORAGE_KEYS.CURRENT_PROFILE, profileName);
        }

        static loadCurrentProfile() {
          return this.loadJSON(STORAGE_KEYS.CURRENT_PROFILE, null);
        }

        static saveColorScheme(scheme) {
          return this.saveJSON(STORAGE_KEYS.COLOR_SCHEME, scheme);
        }

        static loadColorScheme() {
          return this.loadJSON(STORAGE_KEYS.COLOR_SCHEME, "dark");
        }

        // Chemical presets storage
        static saveChemicalPresets(presets) {
          return this.saveJSON(STORAGE_KEYS.CHEMICAL_PRESETS, presets);
        }

        static loadChemicalPresets() {
          return this.loadJSON(STORAGE_KEYS.CHEMICAL_PRESETS, []);
        }

        // Capacity tracker storage - UPDATED with area calculations
        static saveCapacityTracker(data) {
          return this.saveJSON(STORAGE_KEYS.CAPACITY_TRACKER, data);
        }

        static loadCapacityTracker() {
          return this.loadJSON(STORAGE_KEYS.CAPACITY_TRACKER, {
            printsDone: 0,
            areaUsed: 0,
            paperSize: 0.052,
            lastReset: new Date().toISOString(),
          });
        }

        // Shelf life storage
        static saveShelfLife(chemicals) {
          return this.saveJSON(STORAGE_KEYS.SHELF_LIFE, chemicals);
        }

        static loadShelfLife() {
          return this.loadJSON(STORAGE_KEYS.SHELF_LIFE, []);
        }

        static clearAll() {
          return this.removeKeys([
            STORAGE_KEYS.SETTINGS,
            STORAGE_KEYS.PROFILES,
            STORAGE_KEYS.CURRENT_PROFILE,
            STORAGE_KEYS.COLOR_SCHEME,
            STORAGE_KEYS.CHEMICAL_PRESETS,
            STORAGE_KEYS.CAPACITY_TRACKER,
            STORAGE_KEYS.SHELF_LIFE,
          ]);
        }
      }

      // Timer Class
      class Timer {
        constructor(name) {
          this.name = name;
          this.isRunning = false;
          this.interval = null;
          this.warningPlayed = false;
          this.isEnabled = true;

          // Initialize with default time
          this.totalTime = DEFAULT_TIMER_TIMES[name] || 60;
          this.timeLeft = this.totalTime;

          // Initialize display immediately
          this.updateDisplay();
          this.setupEventListeners();
        }

        setupEventListeners() {
          const button = document.getElementById(`btn${this.name}`);
          const resetButton = document.querySelector(
            `button[data-timer="${this.name}"][data-action="reset"]`
          );
          const plusButton = document.querySelector(
            `button[data-timer="${this.name}"][data-action="plus"]`
          );
          const minusButton = document.querySelector(
            `button[data-timer="${this.name}"][data-action="minus"]`
          );

          if (button) button.addEventListener("click", () => this.toggle());
          if (resetButton)
            resetButton.addEventListener("click", () => this.reset());
          if (plusButton)
            plusButton.addEventListener("click", () => this.adjustTime(5));
          if (minusButton)
            minusButton.addEventListener("click", () => this.adjustTime(-5));
        }

        updateDisplay() {
          const display = document.getElementById(`display${this.name}`);
          if (display) {
            const minutes = Math.floor(this.timeLeft / 60);
            const seconds = this.timeLeft % 60;
            display.textContent = `${minutes
              .toString()
              .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
          }
        }

        updateButtonStates() {
          const button = document.getElementById(`btn${this.name}`);
          const resetButton = document.querySelector(
            `button[data-timer="${this.name}"][data-action="reset"]`
          );
          const plusButton = document.querySelector(
            `button[data-timer="${this.name}"][data-action="plus"]`
          );
          const minusButton = document.querySelector(
            `button[data-timer="${this.name}"][data-action="minus"]`
          );

          if (!this.isEnabled) {
            if (button) button.disabled = true;
            if (resetButton) resetButton.disabled = true;
            if (plusButton) plusButton.disabled = true;
            if (minusButton) minusButton.disabled = true;
            return;
          }

          if (button) {
            button.disabled = false;
            button.textContent = this.isRunning ? "Pause" : "Start";
            button.classList.toggle("active", this.isRunning);
          }

          if (resetButton) resetButton.disabled = this.isRunning;
          if (plusButton) plusButton.disabled = this.isRunning;
          if (minusButton) minusButton.disabled = this.isRunning;

          // Update box state
          const box = document.getElementById(`timer${this.name}`);
          if (box) {
            box.classList.remove("running", "warning", "complete");
            if (this.isRunning) box.classList.add("running");
            if (this.timeLeft === 0) box.classList.add("complete");
          }
        }

        setTime(seconds) {
          // Stop if running
          if (this.isRunning) {
            clearInterval(this.interval);
            this.isRunning = false;
          }

          // Set new time
          this.totalTime = seconds;
          this.timeLeft = seconds;
          this.warningPlayed = false;

          // Update display and buttons
          this.updateDisplay();
          this.updateButtonStates();

          // Update box state
          const box = document.getElementById(`timer${this.name}`);
          if (box) {
            box.classList.remove("running", "warning", "complete");
          }
        }

        adjustTime(seconds) {
          if (this.isRunning || !this.isEnabled) return;

          const newTime = this.totalTime + seconds;
          if (newTime >= 5 && newTime <= 600) {
            this.totalTime = newTime;
            this.timeLeft = newTime;
            this.updateDisplay();
          }
        }

        start() {
          if (this.isRunning || !this.isEnabled || this.timeLeft <= 0) return;

          this.isRunning = true;
          this.warningPlayed = false;
          this.updateButtonStates();

          this.interval = setInterval(() => {
            this.timeLeft--;
            this.updateDisplay();

            // 10-second warning
            if (
              this.timeLeft === 10 &&
              document.getElementById("warningBeep").checked &&
              this.isEnabled
            ) {
              const box = document.getElementById(`timer${this.name}`);
              if (box) box.classList.add("warning");
              playBeep(400, 0.3, 0.3);
              this.warningPlayed = true;
            }

            // Timer ended
            if (this.timeLeft <= 0) {
              this.complete();
            }
          }, 1000);
        }

        stop() {
          if (!this.isRunning) return;

          clearInterval(this.interval);
          this.isRunning = false;
          this.updateButtonStates();
        }

        reset() {
          if (this.isRunning || !this.isEnabled) return;

          this.stop();
          this.timeLeft = this.totalTime;
          this.warningPlayed = false;
          this.updateDisplay();
          this.updateButtonStates();
        }

        complete() {
          this.isRunning = false;
          clearInterval(this.interval);
          this.timeLeft = 0;
          this.updateDisplay();
          this.updateButtonStates();

          if (document.getElementById("endBeep").checked && this.isEnabled) {
            playBeep(800, 0.1, 0.5);
          }

          // Auto-start next timer
          if (document.getElementById("autoStart").checked) {
            this.startNextTimer();
          }
        }

        toggle() {
          if (!this.isEnabled) return;

          if (this.isRunning) {
            this.stop();
          } else {
            if (this.timeLeft <= 0) {
              this.reset();
            }
            this.start();
          }
        }

        updateEnabledState(enabled) {
          this.isEnabled = enabled;
          const box = document.getElementById(`timer${this.name}`);
          if (box) {
            if (enabled) {
              box.classList.remove("disabled");
            } else {
              box.classList.add("disabled");
              this.stop();
            }
          }
          this.updateButtonStates();
        }

        startNextTimer() {
          const timerOrder = ["Dev", "Stop", "Fix", "Flo"];
          const currentIndex = timerOrder.indexOf(this.name);

          for (let i = currentIndex + 1; i < timerOrder.length; i++) {
            const nextTimerName = timerOrder[i];
            const nextTimer = timerManager.timers.find(
              (t) => t.name === nextTimerName
            );

            if (nextTimer && nextTimer.isEnabled) {
              setTimeout(() => {
                nextTimer.reset();
                nextTimer.start();
              }, 1000);
              break;
            }
          }
        }

        getCurrentTime() {
          return this.totalTime;
        }
      }

      // NEW: Countdown Manager
      class CountdownManager {
        constructor() {
          this.isActive = false;
          this.countdownValue = 5;
          this.countdownInterval = null;
          this.onCompleteCallback = null;
          this.displayElement = null;
          this.beepEnabled = true;
        }

        startCountdown(displayElement, onComplete) {
          if (this.isActive) return;

          this.isActive = true;
          this.displayElement = displayElement;
          this.onCompleteCallback = onComplete;

          // Get settings
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
            this.beepEnabled = settingsManager.settings.countdownBeep !== false;
            this.beepPattern =
              settingsManager.settings.countdownPattern || "every-second";
          }

          // Save original display value
          this.originalDisplay = displayElement.textContent;
          this.originalBackground = displayElement.style.backgroundColor;
          this.originalColor = displayElement.style.color;

          // Start countdown with initial beep (if pattern allows)
          if (this.beepEnabled && this.beepPattern !== "none") {
            // Check if pattern allows initial beep
            const pattern = this.beepPattern || "every-second";
            const shouldBeep =
              pattern === "every-second" ||
              (pattern === "last3" && this.countdownValue <= 3) ||
              (pattern === "last5" && this.countdownValue <= 5);

            if (shouldBeep) {
              playBeep(400, 0.2, 0.2); // Initial beep
            }
          }

          this.updateCountdown();
        }

        updateCountdown() {
          if (this.countdownValue <= 0) {
            this.complete();
            return;
          }

          // Update display
          if (this.displayElement) {
            this.displayElement.textContent = this.countdownValue;
            this.displayElement.style.fontWeight = "bold";

            // Flash effect for last 3 seconds
            if (this.countdownValue <= 3) {
              this.displayElement.style.backgroundColor = "#400";
              this.displayElement.style.color = "#fff";

              if (this.countdownValue <= 1) {
                this.displayElement.style.backgroundColor = "#f00";
              }
            } else {
              this.displayElement.style.backgroundColor = "#300";
              this.displayElement.style.color = "#f00";
            }

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              if (this.countdownValue <= 3) {
                this.displayElement.style.backgroundColor = "#0066cc";
                this.displayElement.style.color = "#fff";
              } else {
                this.displayElement.style.backgroundColor = "#cce5ff";
                this.displayElement.style.color = "#0066cc";
              }
            } else if (document.body.classList.contains("day-scheme")) {
              if (this.countdownValue <= 3) {
                this.displayElement.style.backgroundColor = "#ffcc00";
                this.displayElement.style.color = "#000";
              } else {
                this.displayElement.style.backgroundColor = "#ffdd66";
                this.displayElement.style.color = "#ffcc00";
              }
            }
          }

          // Play beep based on pattern
          if (this.beepEnabled) {
            const pattern = this.beepPattern || "every-second";
            let shouldBeep = false;

            switch (pattern) {
              case "every-second":
                shouldBeep = true;
                break;
              case "last3":
                shouldBeep = this.countdownValue <= 3;
                break;
              case "last5":
                shouldBeep = this.countdownValue <= 5;
                break;
              case "none":
                shouldBeep = false;
                break;
              default:
                shouldBeep = true;
            }

            if (shouldBeep) {
              // Different beep patterns based on remaining time
              if (this.countdownValue <= 3) {
                // Last 3 seconds: higher frequency, shorter duration
                playBeep(800, 0.2, 0.4);
              } else if (this.countdownValue <= 5) {
                // Middle seconds: medium frequency
                playBeep(600, 0.3, 0.3);
              } else {
                // Early seconds: lower frequency, softer
                playBeep(400, 0.2, 0.2);
              }
            }
          }

          this.countdownValue--;

          // Schedule next update
          this.countdownInterval = setTimeout(
            () => this.updateCountdown(),
            1000
          );
        }

        complete() {
          this.isActive = false;
          clearTimeout(this.countdownInterval);

          // Final beep
          if (this.beepEnabled) {
            playBeep(1600, 0.5, 0.5); // Final, longer beep
          }

          // Restore display
          if (this.displayElement) {
            this.displayElement.textContent = this.originalDisplay;
            this.displayElement.style.backgroundColor =
              this.originalBackground || "";
            this.displayElement.style.color = this.originalColor || "";
            this.displayElement.style.fontWeight = "";
          }

          // Reset countdown value for next use
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
          } else {
            this.countdownValue = 5;
          }

          // Call completion callback
          if (this.onCompleteCallback) {
            this.onCompleteCallback();
          }
        }

        cancel() {
          this.isActive = false;
          clearTimeout(this.countdownInterval);

          // Restore display
          if (this.displayElement) {
            this.displayElement.textContent = this.originalDisplay;
            this.displayElement.style.backgroundColor =
              this.originalBackground || "";
            this.displayElement.style.color = this.originalColor || "";
            this.displayElement.style.fontWeight = "";
          }

          // Reset countdown value
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
          } else {
            this.countdownValue = 5;
          }
        }
      }

      // Settings Manager
      class SettingsManager {
        constructor() {
          this.settings = StorageManager.loadSettings();
          this.profiles = StorageManager.loadProfiles();
          this.currentProfile = StorageManager.loadCurrentProfile();
          this.colorScheme = StorageManager.loadColorScheme();
          this.applyColorScheme();
          this.applySoundSettings();

          // Apply auto advance setting to F-Stop Test generator
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.setAutoAdvance(
              this.settings.autoAdvance || false
            );
          }

          // Ensure chemical manager is available
          if (window.chemicalManager) {
            // Load any existing chemical data
            window.chemicalManager.chemicalPresets =
              StorageManager.loadChemicalPresets();
            window.chemicalManager.capacityData =
              StorageManager.loadCapacityTracker();
            window.chemicalManager.shelfLifeData =
              StorageManager.loadShelfLife();
          }
        }

        applySoundSettings() {
          // Apply sound settings from saved settings
          if (this.settings.calcWarningBeep !== undefined) {
            document.getElementById("calcWarningBeep").checked =
              this.settings.calcWarningBeep;
          }
          if (this.settings.calcEndBeep !== undefined) {
            document.getElementById("calcEndBeep").checked =
              this.settings.calcEndBeep;
          }
          if (this.settings.autoStart !== undefined) {
            document.getElementById("autoStart").checked =
              this.settings.autoStart;
          }
          if (this.settings.timerWarningBeep !== undefined) {
            document.getElementById("warningBeep").checked =
              this.settings.timerWarningBeep;
          }
          if (this.settings.timerEndBeep !== undefined) {
            document.getElementById("endBeep").checked =
              this.settings.timerEndBeep;
          }
        }

        applyColorScheme() {
          document.body.classList.remove(
            "dark-scheme",
            "light-scheme",
            "day-scheme"
          );
          document.body.classList.add(`${this.colorScheme}-scheme`);

          document.querySelectorAll(".color-scheme-btn").forEach((btn) => {
            btn.classList.remove("active");
            if (btn.getAttribute("data-scheme") === this.colorScheme) {
              btn.classList.add("active");
            }
          });

          this.settings.colorScheme = this.colorScheme;
          StorageManager.saveSettings(this.settings);
        }

        setColorScheme(scheme) {
          if (["dark", "light", "day"].includes(scheme)) {
            this.colorScheme = scheme;
            StorageManager.saveColorScheme(scheme);
            this.applyColorScheme();
          }
        }

        // Read current UI settings into this.settings
        readSettingsFromUI() {
          this.settings = {
            baseTime: parseFloat(
              document.getElementById("settingBaseTime").value
            ),
            devTime: parseInt(document.getElementById("settingDevTime").value),
            stopTime: parseInt(
              document.getElementById("settingStopTime").value
            ),
            fixTime: parseInt(document.getElementById("settingFixTime").value),
            floTime: parseInt(document.getElementById("settingFloTime").value),
            calcWarningBeep: document.getElementById("settingCalcWarningBeep")
              .checked,
            calcEndBeep: document.getElementById("settingCalcEndBeep").checked,
            autoStart: document.getElementById("settingAutoStart").checked,
            timerWarningBeep: document.getElementById("settingTimerWarningBeep")
              .checked,
            timerEndBeep: document.getElementById("settingTimerEndBeep")
              .checked,
            defaultPhotoFlo: document.getElementById("settingDefaultPhotoFlo")
              .checked,
            currentProfile: this.currentProfile,
            colorScheme: this.colorScheme,
            countdownDelay: parseInt(
              document.getElementById("settingCountdownDelay").value
            ),
            countdownBeep: document.getElementById("settingCountdownBeep")
              .checked,
            countdownPattern: document.getElementById("settingCountdownPattern")
              .value,
            autoAdvance: document.getElementById("settingAutoAdvance").checked,
            autoAdvanceDelay: parseInt(
              document.getElementById("settingAutoAdvanceDelay").value
            ),
            safelightAutoOff:
              document.getElementById("safelightAutoOff").checked, // NEW
            // Base time slider limits
            baseTimeMin: parseFloat(
              document.getElementById("baseTimeMin")?.value || 0.4
            ),
            baseTimeMax: parseFloat(
              document.getElementById("baseTimeMax")?.value || 50
            ),
            // Test base time slider limits
            testBaseTimeMin: parseFloat(
              document.getElementById("testBaseTimeMin")?.value || 1
            ),
            testBaseTimeMax: parseFloat(
              document.getElementById("testBaseTimeMax")?.value || 50
            ),
            // F-stop denominator setting (2, 3, or 4) - Settings select takes precedence, then segmented controls, then legacy selects
            stopDenominator: (function () {
              const settingsSel = document.getElementById(
                "settingStopIncrement"
              );
              if (settingsSel && settingsSel.value)
                return parseInt(settingsSel.value, 10) || 3;
              function fromSeg(id) {
                const s = document.getElementById(id);
                if (!s) return null;
                const active =
                  s.querySelector(".segmented-btn.active") ||
                  s.querySelector('.segmented-btn[aria-pressed="true"]');
                if (active) return parseInt(active.dataset.denom, 10);
                return null;
              }
              const cs = fromSeg("calcIncrementSeg");
              if (cs) return cs;
              const ts = fromSeg("testIncrementSeg");
              if (ts) return ts;
              // backward compatibility with legacy <select>
              const c = document.getElementById("calcIncrementDenom");
              const t = document.getElementById("testIncrementDenom");
              if (c) return parseInt(c.value, 10) || 3;
              if (t) return parseInt(t.value, 10) || 3;
              return 3;
            })(),
          };
        }

        // Apply the current this.settings values to the UI and runtime objects
        applySettingsToRuntime() {
          // Apply to UI
          this.applySoundSettings();

          // Apply Photo Wash
          const photoFloToggle = document.getElementById("photoFloToggle");
          if (photoFloToggle) {
            photoFloToggle.checked = this.settings.defaultPhotoFlo;
          }
          if (timerManager && timerManager.timers) {
            const floTimer = timerManager.timers.find((t) => t.name === "Flo");
            if (floTimer) {
              floTimer.updateEnabledState(this.settings.defaultPhotoFlo);
            }
          }

          // Apply auto advance to F-Stop Test generator
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.setAutoAdvance(this.settings.autoAdvance);
            window.fstopTestGenerator.setAutoAdvanceDelay(
              this.settings.autoAdvanceDelay * 1000
            ); // Convert to ms
          }

          // Apply base time slider limits
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            const newMin = parseFloat(this.settings.baseTimeMin) || 0.4;
            const newMax = parseFloat(this.settings.baseTimeMax) || 50;
            baseSlider.min = newMin;
            baseSlider.max = newMax;
            // Ensure current value is within new range
            const currentValue = parseFloat(baseSlider.value);
            if (currentValue < newMin) baseSlider.value = newMin;
            if (currentValue > newMax) baseSlider.value = newMax;
          }

          // Apply test base time slider limits
          const testBaseSlider = document.getElementById("testBaseSlider");
          if (testBaseSlider) {
            const newMin = parseFloat(this.settings.testBaseTimeMin) || 1;
            const newMax = parseFloat(this.settings.testBaseTimeMax) || 50;
            testBaseSlider.min = newMin;
            testBaseSlider.max = newMax;
            // Ensure current value is within new range
            const currentValue = parseFloat(testBaseSlider.value);
            if (currentValue < newMin) testBaseSlider.value = newMin;
            if (currentValue > newMax) testBaseSlider.value = newMax;
          }

          // Apply base time to calculators and test generator so UI updates immediately
          const newBase = parseFloat(this.settings.baseTime);
          const baseSliderEl = document.getElementById("baseTimeSlider");
          if (baseSliderEl) {
            baseSliderEl.value = newBase;
            baseSliderEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
          const testBaseEl = document.getElementById("testBaseSlider");
          if (testBaseEl) {
            testBaseEl.value = newBase;
            testBaseEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = newBase;
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.baseTime = newBase;
            if (window.fstopTestGenerator.testBaseSlider) {
              window.fstopTestGenerator.testBaseSlider.value = newBase;
            }
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }

          // Apply saved timer default times to Timer instances and DEFAULT_TIMER_TIMES
          if (
            typeof DEFAULT_TIMER_TIMES !== "undefined" &&
            timerManager &&
            timerManager.timers
          ) {
            const mapping = {
              Dev: parseInt(this.settings.devTime, 10),
              Stop: parseInt(this.settings.stopTime, 10),
              Fix: parseInt(this.settings.fixTime, 10),
              Flo: parseInt(this.settings.floTime, 10),
            };

            // Update DEFAULT_TIMER_TIMES so newly created timers use the saved defaults
            Object.keys(mapping).forEach((k) => {
              if (typeof mapping[k] === "number" && !isNaN(mapping[k])) {
                DEFAULT_TIMER_TIMES[k] = mapping[k];
              }
            });

            // Update existing timer instances
            timerManager.timers.forEach((timer) => {
              const newTime = mapping[timer.name];
              if (typeof newTime === "number" && !isNaN(newTime)) {
                if (!timer.isRunning) {
                  // Reset to new default
                  timer.setTime(newTime);
                } else {
                  // If running, update total and remaining time without interrupting display logic
                  timer.totalTime = newTime;
                  timer.timeLeft = newTime;
                  timer.warningPlayed = false;
                  timer.updateDisplay();
                  timer.updateButtonStates();
                }
              }
            });
          }

          // Apply f-stop denominator setting (2, 3, 4)
          (function applyDenominator() {
            const denom = parseInt(this.settings.stopDenominator, 10) || 3;
            window.stopDenominator = denom;
            // Apply to segmented controls if present
            function setSeg(containerId, d) {
              const cont = document.getElementById(containerId);
              if (!cont) return;
              Array.from(cont.querySelectorAll(".segmented-btn")).forEach(
                (b) => {
                  if (parseInt(b.dataset.denom, 10) === d) {
                    b.classList.add("active");
                    b.setAttribute("aria-pressed", "true");
                  } else {
                    b.classList.remove("active");
                    b.setAttribute("aria-pressed", "false");
                  }
                }
              );
            }
            setSeg("calcIncrementSeg", denom);
            setSeg("testIncrementSeg", denom);
            // Legacy selects (back-compat)
            const c = document.getElementById("calcIncrementDenom");
            const t = document.getElementById("testIncrementDenom");
            if (c) c.value = denom;
            if (t) t.value = denom;
            const settingsSel = document.getElementById("settingStopIncrement");
            if (settingsSel) settingsSel.value = denom;
            if (window.incrementalTimer) {
              window.incrementalTimer.updateCalculations();
              window.incrementalTimer.updateAllDisplays();
            }
            if (window.fstopTestGenerator) {
              window.fstopTestGenerator.generateSteps();
              window.fstopTestGenerator.updateDisplay();
            }
            try {
              updateAllRulers();
            } catch (e) {
              /* ignore if not yet defined */
            }
            try {
              updateChart();
            } catch (e) {}
          }).call(this);
        }

        // Called when user clicks "Save"
        saveGlobalSettings() {
          this.readSettingsFromUI();
          if (StorageManager.saveSettings(this.settings)) {
            this.applySettingsToRuntime();
            this.showAllProfilesFeedback("Global settings saved!", "success");
          }
        }

        // Apply settings live without showing feedback
        applyLiveSettings() {
          this.readSettingsFromUI();
          // Save immediately for persistence but don't show the save feedback
          StorageManager.saveSettings(this.settings);
          this.applySettingsToRuntime();
          // Announce setting change to assistive tech
          try {
            const live = document.getElementById("settingsLiveStatus");
            if (live) {
              const denom = this.settings.stopDenominator || 3;
              live.textContent = `Default stop increment set to ${denomLabel(
                denom
              )}`;
            }
          } catch (e) {}
        }

        saveCurrentProfile(name) {
          if (!name || name.trim() === "") {
            this.showAllProfilesFeedback(
              "Please enter a profile name",
              "error"
            );
            return false;
          }

          // Get current timer times from timer objects
          const currentTimes = {};
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              currentTimes[timer.name] = timer.getCurrentTime();
            });
          }

          const existingIndex = this.profiles.findIndex((p) => p.name === name);
          const profile = {
            name: name.trim(),
            times: currentTimes,
            date: new Date().toISOString(),
          };

          if (existingIndex >= 0) {
            this.profiles[existingIndex] = profile;
          } else {
            this.profiles.push(profile);
          }

          if (StorageManager.saveProfiles(this.profiles)) {
            this.currentProfile = profile.name;
            StorageManager.saveCurrentProfile(profile.name);
            this.updateTimerProfileListUI(); // Update both lists
            this.showAllProfilesFeedback(
              `Profile "${profile.name}" saved!`,
              "success"
            );
            return true;
          }
          return false;
        }

        loadProfile(profile) {
          if (!profile || !profile.times) {
            this.showAllProfilesFeedback("Invalid profile format", "error");
            return false;
          }

          // Stop all running timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              if (timer.isRunning) {
                timer.stop();
              }
            });
          }

          // Apply profile times to timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              if (profile.times[timer.name] !== undefined) {
                timer.setTime(profile.times[timer.name]);
              }
            });
          }

          this.currentProfile = profile.name;
          StorageManager.saveCurrentProfile(profile.name);
          this.updateTimerProfileListUI();

          // Note: Shelf life data is loaded separately via importAllData
          this.showAllProfilesFeedback(
            `Profile "${profile.name}" loaded!`,
            "success"
          );
          return true;
        }

        deleteProfile(profileName) {
          if (confirm(`Delete profile "${profileName}"?`)) {
            this.profiles = this.profiles.filter((p) => p.name !== profileName);

            if (this.currentProfile === profileName) {
              this.currentProfile = null;
              StorageManager.saveCurrentProfile(null);
            }

            if (StorageManager.saveProfiles(this.profiles)) {
              this.updateTimerProfileListUI(); // Update both lists
              this.showAllProfilesFeedback(
                `Profile "${profileName}" deleted!`,
                "success"
              );
              return true;
            }
          }
          return false;
        }

        clearAllProfiles() {
          if (confirm("Delete ALL timer profiles? This cannot be undone!")) {
            this.profiles = [];
            this.currentProfile = null;
            StorageManager.saveProfiles([]);
            StorageManager.saveCurrentProfile(null);
            this.updateTimerProfileListUI(); // Update timer tab UI
            this.showAllProfilesFeedback(
              "All timer profiles deleted!",
              "success"
            );
            return true;
          }
        }

        resetAllSettings() {
          if (
            confirm(
              "Reset all settings to defaults? This will delete all profiles and settings!"
            )
          ) {
            StorageManager.clearAll();
            this.settings = { ...DEFAULT_SETTINGS };
            this.profiles = [];
            this.currentProfile = null;
            this.colorScheme = "dark";
            this.applyColorScheme();
            this.applySoundSettings();
            loadSettingsToUI();
            this.updateTimerProfileListUI();
            this.showAllProfilesFeedback(
              "All settings reset to defaults!",
              "success"
            );
            location.reload();
          }
        }

        exportAllData() {
          // Ensure we export the latest UI state
          this.readSettingsFromUI();

          // Normalize settings to guarantee stop increment is present and numeric
          const settingsToExport = {
            ...DEFAULT_SETTINGS,
            ...this.settings,
            stopDenominator:
              parseInt(this.settings.stopDenominator, 10) ||
              DEFAULT_SETTINGS.stopDenominator,
          };

          const exportData = {
            app: "Darkroom Timer",
            version: "2.9.1",
            exportDate: new Date().toISOString(),
            settings: settingsToExport,
            timerProfiles: this.profiles,
            chemicalPresets: window.chemicalManager
              ? window.chemicalManager.chemicalPresets
              : [],
            capacityTracker: StorageManager.loadCapacityTracker(),
            shelfLifeData: StorageManager.loadShelfLife(),
          };

          const jsonStr = JSON.stringify(exportData, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `darkroom-timer-data-${new Date()
            .toISOString()
            .slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          this.showAllProfilesFeedback(
            "All data exported successfully!",
            "success"
          );
        }

        importAllData(jsonData) {
          try {
            const data = JSON.parse(jsonData);
            let importedCount = 0;

            // Import global settings
            if (data.settings && typeof data.settings === "object") {
              this.settings = { ...DEFAULT_SETTINGS, ...data.settings };
              this.colorScheme = this.settings.colorScheme || "dark";
              StorageManager.saveSettings(this.settings);
              StorageManager.saveColorScheme(this.colorScheme);
              this.applyColorScheme();
              this.applySoundSettings();
              this.applySettingsToRuntime();
              if (typeof loadSettingsToUI === "function") {
                loadSettingsToUI();
              }
              importedCount++;
            }

            // Import timer profiles
            if (data.timerProfiles && Array.isArray(data.timerProfiles)) {
              const validProfiles = data.timerProfiles.filter((profile) => {
                return (
                  profile &&
                  typeof profile.name === "string" &&
                  profile.name.trim() !== "" &&
                  profile.times &&
                  typeof profile.times === "object"
                );
              });

              if (validProfiles.length > 0) {
                const existingNames = this.profiles.map((p) => p.name);
                const newNames = validProfiles.map((p) => p.name);
                const duplicates = newNames.filter((name) =>
                  existingNames.includes(name)
                );

                let mergeStrategy = "skip";
                if (duplicates.length > 0) {
                  mergeStrategy =
                    prompt(
                      `Found ${
                        duplicates.length
                      } duplicate timer profile(s): ${duplicates.join(
                        ", "
                      )}\n\n` +
                        `Enter 'overwrite' to replace duplicates, or 'skip' to keep existing:`,
                      "skip"
                    )?.toLowerCase() || "skip";

                  if (!["overwrite", "skip"].includes(mergeStrategy)) {
                    mergeStrategy = "skip";
                  }
                }

                validProfiles.forEach((newProfile) => {
                  const existingIndex = this.profiles.findIndex(
                    (p) => p.name === newProfile.name
                  );

                  if (existingIndex >= 0) {
                    if (mergeStrategy === "overwrite") {
                      this.profiles[existingIndex] = {
                        ...newProfile,
                        date: newProfile.date || new Date().toISOString(),
                      };
                    }
                  } else {
                    this.profiles.push({
                      ...newProfile,
                      date: newProfile.date || new Date().toISOString(),
                    });
                  }
                });

                StorageManager.saveProfiles(this.profiles);
                importedCount += validProfiles.length;
              }
            }

            // Import chemical presets
            if (
              data.chemicalPresets &&
              Array.isArray(data.chemicalPresets) &&
              window.chemicalManager
            ) {
              const validChemicalPresets = data.chemicalPresets.filter(
                (preset) => {
                  return (
                    preset &&
                    typeof preset.name === "string" &&
                    preset.name.trim() !== "" &&
                    preset.totalVolume &&
                    preset.dilutionRatio
                  );
                }
              );

              if (validChemicalPresets.length > 0) {
                validChemicalPresets.forEach((newPreset) => {
                  const existingIndex =
                    window.chemicalManager.chemicalPresets.findIndex(
                      (p) => p.name === newPreset.name
                    );
                  if (existingIndex >= 0) {
                    window.chemicalManager.chemicalPresets[existingIndex] =
                      newPreset;
                  } else {
                    window.chemicalManager.chemicalPresets.push(newPreset);
                  }
                });

                StorageManager.saveChemicalPresets(
                  window.chemicalManager.chemicalPresets
                );
                window.chemicalManager.updateChemicalPresetList();
                importedCount += validChemicalPresets.length;
              }
            }

            // Import capacity tracker
            if (data.capacityTracker && window.chemicalManager) {
              window.chemicalManager.capacityData = {
                ...window.chemicalManager.capacityData,
                ...data.capacityTracker,
              };
              StorageManager.saveCapacityTracker(
                window.chemicalManager.capacityData
              );
              window.chemicalManager.updateCapacityDisplay();
              importedCount++;
            }

            // Import shelf life data (ACTIVE CHEMICALS)
            if (
              data.shelfLifeData &&
              Array.isArray(data.shelfLifeData) &&
              window.chemicalManager
            ) {
              // First, clear existing shelf life data
              window.chemicalManager.shelfLifeData = [];

              // Validate and import each chemical
              data.shelfLifeData.forEach((chemical) => {
                // Validate required fields
                if (
                  chemical &&
                  chemical.name &&
                  chemical.dateMixed &&
                  chemical.shelfLifeDays
                ) {
                  // Add the chemical to shelf life data
                  window.chemicalManager.shelfLifeData.push({
                    id: chemical.id || Date.now() + Math.random(),
                    type: chemical.type || "custom",
                    name: chemical.name,
                    dateMixed: chemical.dateMixed,
                    shelfLifeDays: chemical.shelfLifeDays,
                    dateAdded: chemical.dateAdded || new Date().toISOString(),
                  });
                }
              });

              // Save to storage
              StorageManager.saveShelfLife(
                window.chemicalManager.shelfLifeData
              );

              // Update the shelf life list in the UI
              if (window.chemicalManager.shelfLifeList) {
                window.chemicalManager.updateShelfLifeList();
              }

              importedCount += window.chemicalManager.shelfLifeData.length;

              // Show notification if we're currently on the chemical tab
              const currentTab = document
                .querySelector(".tab-button.active")
                .getAttribute("data-tab");
              if (currentTab === "chemical") {
                this.showAllProfilesFeedback(
                  `Loaded ${window.chemicalManager.shelfLifeData.length} active chemicals`,
                  "success"
                );
              }
            }

            // Update all UIs
            this.updateTimerProfileListUI();

            // Refresh the chemical tab if it's currently active
            const currentTab = document
              .querySelector(".tab-button.active")
              .getAttribute("data-tab");
            if (currentTab === "chemical" && window.chemicalManager) {
              window.chemicalManager.updateDisplay();
            }

            // Visual feedback for chemical data
            if (window.chemicalManager) {
              // Briefly highlight the chemical tab if we imported chemical data
              const chemicalTabBtn = document.querySelector(
                '.tab-button[data-tab="chemical"]'
              );
              if (chemicalTabBtn) {
                chemicalTabBtn.style.backgroundColor = "#400";
                setTimeout(() => {
                  chemicalTabBtn.style.backgroundColor = "";
                }, 1000);
              }
            }

            this.showAllProfilesFeedback(
              `Successfully imported ${importedCount} items!`,
              "success"
            );

            return true;
          } catch (error) {
            this.showAllProfilesFeedback(
              `Import failed: ${error.message}`,
              "error"
            );
            return false;
          }
        }

        showAllProfilesFeedback(message, type) {
          const feedback = document.getElementById("allProfilesFeedback");
          feedback.textContent = message;
          feedback.className = `json-feedback json-${type}`;
          feedback.style.display = "block";

          setTimeout(() => {
            feedback.style.display = "none";
          }, 3000);
        }

        updateTimerProfileListUI() {
          const profileList = document.getElementById("timerProfileList");
          if (!profileList) return;

          profileList.innerHTML = "";

          this.profiles.forEach((profile) => {
            const item = document.createElement("div");
            item.className = `profile-item ${
              this.currentProfile === profile.name ? "active" : ""
            }`;

            let timeStr = "";
            if (profile.times) {
              const devTime = profile.times.Dev || DEFAULT_TIMER_TIMES.Dev;
              const stopTime = profile.times.Stop || DEFAULT_TIMER_TIMES.Stop;
              const fixTime = profile.times.Fix || DEFAULT_TIMER_TIMES.Fix;

              const devMin = Math.floor(devTime / 60);
              const devSec = devTime % 60;
              const fixMin = Math.floor(fixTime / 60);
              const fixSec = fixTime % 60;

              timeStr = `Dev:${devMin}:${devSec
                .toString()
                .padStart(2, "0")} Stop:${stopTime}s Fix:${fixMin}:${fixSec
                .toString()
                .padStart(2, "0")}`;
            } else {
              timeStr = "No times saved";
            }

            item.innerHTML = `
                        <div>
                            <strong>${profile.name}</strong>
                            <div style="font-size: 0.65rem; color: var(--text-secondary);">${new Date(
                              profile.date
                            ).toLocaleDateString()}</div>
                            <div style="font-size: 0.6rem; color: #600;">${timeStr}</div>
                        </div>
                        <div class="profile-actions">
                            <button class="profile-btn load-timer-profile" data-name="${
                              profile.name
                            }">Load</button>
                            <button class="profile-btn delete delete-timer-profile" data-name="${
                              profile.name
                            }">Delete</button>
                        </div>
                    `;

            profileList.appendChild(item);
          });

          // Add event listeners for timer tab
          document.querySelectorAll(".load-timer-profile").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const profileName = e.target.getAttribute("data-name");
              const profile = this.profiles.find((p) => p.name === profileName);
              if (profile) {
                this.loadProfile(profile);
              }
            });
          });

          document.querySelectorAll(".delete-timer-profile").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const profileName = e.target.getAttribute("data-name");
              this.deleteProfile(profileName);
            });
          });
        }
      }

      // UPDATED: Chemical Management Class with all requested features
      class ChemicalManager {
        constructor() {
          this.totalVolume = 1000;
          this.dilutionRatio = "1+9";
          this.customStockParts = 1;
          this.customWaterParts = 9;
          this.capacityData = StorageManager.loadCapacityTracker();
          this.shelfLifeData = StorageManager.loadShelfLife();
          this.chemicalPresets = StorageManager.loadChemicalPresets();
          this.currentPaperSize = this.capacityData.paperSize || 0.08;

          this.init();
          this.updateMixCalculator();
          this.updateCapacityDisplay();
          this.updateShelfLifeList();
          this.updateChemicalPresetList();

          // Set up custom chemical name visibility
          this.chemicalTypeSelect.addEventListener("change", () => {
            if (this.chemicalTypeSelect.value === "custom") {
              this.customChemicalNameContainer.style.display = "block";
            } else {
              this.customChemicalNameContainer.style.display = "none";
            }
          });
        }

        init() {
          // Get elements
          this.totalVolumeSlider = document.getElementById("totalVolumeSlider");
          this.totalVolumeValue = document.getElementById("totalVolumeValue");
          this.dilutionBtns = document.querySelectorAll(".dilution-btn");
          this.customStockPartsInput =
            document.getElementById("customStockParts");
          this.customWaterPartsInput =
            document.getElementById("customWaterParts");
          this.stockVolumeElement = document.getElementById("stockVolume");
          this.waterVolumeElement = document.getElementById("waterVolume");

          // Chemical preset elements
          this.chemicalPresetNameInput =
            document.getElementById("chemicalPresetName");
          this.saveChemicalPresetBtn =
            document.getElementById("saveChemicalPreset");
          this.chemicalPresetList =
            document.getElementById("chemicalPresetList");
          this.clearChemicalPresetsBtn = document.getElementById(
            "clearChemicalPresets"
          );

          // Capacity tracker elements - UPDATED
          this.capacitySlider = document.getElementById("capacitySlider");
          this.capacityValue = document.getElementById("capacityValue");
          this.trayVolumeSlider = document.getElementById("trayVolumeSlider");
          this.trayVolumeValue = document.getElementById("trayVolumeValue");
          this.maxPrintsValue = document.getElementById("maxPrintsValue");
          this.printsRemaining = document.getElementById("printsRemaining");
          this.capacityProgressBar = document.getElementById(
            "capacityProgressBar"
          );
          this.capacityMiddleLabel = document.getElementById(
            "capacityMiddleLabel"
          );
          this.capacityMaxLabel = document.getElementById("capacityMaxLabel");
          this.addPrintBtn = document.getElementById("addPrint");
          this.add5PrintsBtn = document.getElementById("add5Prints");
          this.resetPrintsBtn = document.getElementById("resetPrints");
          this.printsDoneValue = document.getElementById("printsDoneValue");
          this.areaUsedValue = document.getElementById("areaUsedValue");
          this.percentUsedValue = document.getElementById("percentUsedValue");
          this.capacityStatus = document.getElementById("capacityStatus");

          // Paper size elements - NEW
          this.paperSizeBtns = document.querySelectorAll(".paper-size-btn");
          this.customPaperSizeInput =
            document.getElementById("customPaperSize");
          this.useCustomSizeBtn = document.getElementById("useCustomSize");

          // Shelf life elements - UPDATED
          this.chemicalTypeSelect = document.getElementById("chemicalType");
          this.customChemicalNameContainer = document.getElementById(
            "customChemicalNameContainer"
          );
          this.customChemicalNameInput =
            document.getElementById("customChemicalName");
          this.shelfLifeDaysInput = document.getElementById("shelfLifeDays");
          this.chemicalDateInput = document.getElementById("chemicalDate");
          this.addChemicalBtn = document.getElementById("addChemical");
          this.shelfLifeList = document.getElementById("shelfLifeList");
          this.clearExpiredBtn = document.getElementById("clearExpired");

          // Set current date as default
          const today = new Date().toISOString().split("T")[0];
          this.chemicalDateInput.value = today;

          // Add event listeners
          this.totalVolumeSlider.addEventListener("input", () =>
            this.updateMixCalculator()
          );

          this.dilutionBtns.forEach((btn) => {
            btn.addEventListener("click", (e) => {
              this.dilutionBtns.forEach((b) => b.classList.remove("active"));
              btn.classList.add("active");
              this.dilutionRatio = btn.getAttribute("data-ratio");
              this.updateMixCalculator();
            });
          });

          // FIX: Allow typing in custom inputs
          this.customStockPartsInput.addEventListener("input", () => {
            this.customStockParts =
              parseInt(this.customStockPartsInput.value) || 1;
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.updateMixCalculator();
          });

          this.customWaterPartsInput.addEventListener("input", () => {
            this.customWaterParts =
              parseInt(this.customWaterPartsInput.value) || 1;
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.updateMixCalculator();
          });

          // Chemical preset events
          this.saveChemicalPresetBtn.addEventListener("click", () =>
            this.saveChemicalPreset()
          );
          this.clearChemicalPresetsBtn.addEventListener("click", () =>
            this.clearChemicalPresets()
          );

          // Capacity tracker events - UPDATED
          this.capacitySlider.addEventListener("input", () =>
            this.updateCapacityDisplay()
          );
          this.trayVolumeSlider.addEventListener("input", () =>
            this.updateCapacityDisplay()
          );
          this.addPrintBtn.addEventListener("click", () => this.addPrints(1));
          this.add5PrintsBtn.addEventListener("click", () => this.addPrints(5));
          this.resetPrintsBtn.addEventListener("click", () =>
            this.resetPrints()
          );

          // Paper size events - FIXED
          this.paperSizeBtns.forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const size = parseFloat(e.target.getAttribute("data-size"));
              if (size) {
                this.setPaperSize(size);
                // Update custom input to match selected size
                this.customPaperSizeInput.value = size.toFixed(3);
              }
            });
          });

          // Custom paper size button - FIXED
          this.useCustomSizeBtn.addEventListener("click", () => {
            const customSize = parseFloat(this.customPaperSizeInput.value);
            if (customSize && customSize > 0) {
              this.setPaperSize(customSize);
              // Show visual feedback
              this.useCustomSizeBtn.textContent = "âœ“ Used";
              this.useCustomSizeBtn.classList.add("active");
              setTimeout(() => {
                this.useCustomSizeBtn.textContent = "Use";
                this.useCustomSizeBtn.classList.remove("active");
              }, 1000);
            }
          });

          // Shelf life events
          this.addChemicalBtn.addEventListener("click", () =>
            this.addChemical()
          );
          this.clearExpiredBtn.addEventListener("click", () =>
            this.clearExpired()
          );
        }

        updateMixCalculator() {
          this.totalVolume = parseInt(this.totalVolumeSlider.value);
          this.totalVolumeValue.textContent = `${this.totalVolume}ml`;

          let stockParts, waterParts;

          // Check if a preset button is active
          const activeBtn = document.querySelector(".dilution-btn.active");
          if (activeBtn) {
            const parts = activeBtn.getAttribute("data-ratio").split("+");
            stockParts = parseInt(parts[0]);
            waterParts = parseInt(parts[1]);
          } else {
            // Use custom values
            stockParts = this.customStockParts;
            waterParts = this.customWaterParts;
          }

          const totalParts = stockParts + waterParts;
          const stockVolume = Math.round(
            (this.totalVolume / totalParts) * stockParts
          );
          const waterVolume = Math.round(
            (this.totalVolume / totalParts) * waterParts
          );

          // Adjust for rounding errors
          const adjustedStockVolume = Math.min(stockVolume, this.totalVolume);
          const adjustedWaterVolume = this.totalVolume - adjustedStockVolume;

          this.stockVolumeElement.textContent = `${adjustedStockVolume}ml`;
          this.waterVolumeElement.textContent = `${adjustedWaterVolume}ml`;
        }

        saveChemicalPreset() {
          const name = this.chemicalPresetNameInput.value.trim();
          if (!name) {
            alert("Please enter a preset name");
            return;
          }

          const preset = {
            name: name,
            totalVolume: this.totalVolume,
            dilutionRatio: this.dilutionRatio,
            customStockParts: this.customStockParts,
            customWaterParts: this.customWaterParts,
            date: new Date().toISOString(),
          };

          // Check if preset already exists
          const existingIndex = this.chemicalPresets.findIndex(
            (p) => p.name === name
          );
          if (existingIndex >= 0) {
            this.chemicalPresets[existingIndex] = preset;
          } else {
            this.chemicalPresets.push(preset);
          }

          StorageManager.saveChemicalPresets(this.chemicalPresets);
          this.updateChemicalPresetList();

          // Clear input and show feedback
          this.chemicalPresetNameInput.value = "";
          playBeep(800, 0.3, 0.3);

          const btn = this.saveChemicalPresetBtn;
          const originalText = btn.textContent;
          btn.textContent = "Saved!";
          btn.classList.add("active");

          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove("active");
          }, 1000);
        }

        loadChemicalPreset(preset) {
          this.totalVolumeSlider.value = preset.totalVolume;
          this.totalVolume = preset.totalVolume;

          // Try to find matching dilution button
          const matchingBtn = Array.from(this.dilutionBtns).find(
            (btn) => btn.getAttribute("data-ratio") === preset.dilutionRatio
          );

          if (matchingBtn) {
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            matchingBtn.classList.add("active");
            this.dilutionRatio = preset.dilutionRatio;
          } else {
            // Use custom values
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.customStockParts = preset.customStockParts;
            this.customWaterParts = preset.customWaterParts;
            this.customStockPartsInput.value = preset.customStockParts;
            this.customWaterPartsInput.value = preset.customWaterParts;
          }

          this.updateMixCalculator();
          playBeep(600, 0.3, 0.3);
        }

        deleteChemicalPreset(presetName) {
          if (confirm(`Delete chemical preset "${presetName}"?`)) {
            this.chemicalPresets = this.chemicalPresets.filter(
              (p) => p.name !== presetName
            );
            StorageManager.saveChemicalPresets(this.chemicalPresets);
            this.updateChemicalPresetList();
            playBeep(400, 0.3, 0.3);
          }
        }

        updateChemicalPresetList() {
          this.chemicalPresetList.innerHTML = "";

          this.chemicalPresets.forEach((preset) => {
            const item = document.createElement("div");
            item.className = "chemical-preset-item";

            const ratio = preset.dilutionRatio
              ? `Ratio: ${preset.dilutionRatio}`
              : `Custom: ${preset.customStockParts}+${preset.customWaterParts}`;

            item.innerHTML = `
                        <div>
                            <strong>${preset.name}</strong>
                            <div style="font-size: 0.65rem; color: var(--text-secondary);">
                                ${ratio} â€¢ ${preset.totalVolume}ml
                            </div>
                        </div>
                        <div class="chemical-preset-actions">
                            <button class="chemical-preset-btn load-chemical-preset" data-name="${preset.name}">Load</button>
                            <button class="chemical-preset-btn delete-chemical-preset" data-name="${preset.name}">Del</button>
                        </div>
                    `;

            this.chemicalPresetList.appendChild(item);
          });

          // Add event listeners
          document.querySelectorAll(".load-chemical-preset").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const presetName = e.target.getAttribute("data-name");
              const preset = this.chemicalPresets.find(
                (p) => p.name === presetName
              );
              if (preset) {
                this.loadChemicalPreset(preset);
              }
            });
          });

          document
            .querySelectorAll(".delete-chemical-preset")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                const presetName = e.target.getAttribute("data-name");
                this.deleteChemicalPreset(presetName);
              });
            });
        }

        clearChemicalPresets() {
          if (confirm("Delete ALL chemical presets?")) {
            this.chemicalPresets = [];
            StorageManager.saveChemicalPresets(this.chemicalPresets);
            this.updateChemicalPresetList();
            playBeep(600, 0.5, 0.3);
          }
        }

        // UPDATED: Paper area based capacity calculations
        setPaperSize(size) {
          this.currentPaperSize = size;
          this.capacityData.paperSize = size;

          // Update button states
          this.paperSizeBtns.forEach((btn) => {
            btn.classList.remove("active");
            const btnSize = parseFloat(btn.getAttribute("data-size"));
            if (Math.abs(btnSize - size) < 0.001) {
              btn.classList.add("active");
            }
          });

          this.updateCapacityDisplay();
          StorageManager.saveCapacityTracker(this.capacityData);
        }

        updateCapacityDisplay() {
          const capacityPerLiter = parseFloat(this.capacitySlider.value); // mÂ² per liter
          const trayVolume = parseInt(this.trayVolumeSlider.value); // ml
          const trayVolumeLiters = trayVolume / 1000;

          this.capacityValue.textContent = capacityPerLiter.toFixed(1);
          this.trayVolumeValue.textContent = trayVolume;

          // Calculate maximum area and prints
          const maxArea = capacityPerLiter * trayVolumeLiters; // mÂ²
          const areaUsed = this.capacityData.areaUsed || 0;
          const printsDone = this.capacityData.printsDone || 0;

          const maxPrints = Math.floor(maxArea / this.currentPaperSize);
          const remainingArea = Math.max(0, maxArea - areaUsed);
          const remainingPrints = Math.floor(
            remainingArea / this.currentPaperSize
          );

          this.maxPrintsValue.textContent = maxPrints;
          this.printsRemaining.textContent = `${remainingPrints} prints remaining (${remainingArea.toFixed(
            3
          )} mÂ²)`;

          const percentUsed =
            maxArea > 0 ? Math.min(100, (areaUsed / maxArea) * 100) : 0;

          this.printsDoneValue.textContent = printsDone;
          this.areaUsedValue.textContent = `${areaUsed.toFixed(3)} mÂ²`;
          this.percentUsedValue.textContent = `${percentUsed.toFixed(0)}%`;

          // Update progress bar
          this.capacityProgressBar.style.width = `${percentUsed}%`;
          const middlePrints = Math.round(maxPrints / 2);
          this.capacityMiddleLabel.textContent = middlePrints;
          this.capacityMaxLabel.textContent = maxPrints;

          // Update status based on area usage
          if (percentUsed >= 100) {
            this.capacityStatus.textContent = "Exhausted";
            this.capacityStatus.style.color = "#f00";
          } else if (percentUsed >= 85) {
            this.capacityStatus.textContent = "Nearly Used";
            this.capacityStatus.style.color = "#ff5500";
          } else if (percentUsed >= 60) {
            this.capacityStatus.textContent = "Well Used";
            this.capacityStatus.style.color = "#ffaa00";
          } else if (percentUsed >= 30) {
            this.capacityStatus.textContent = "Partially Used";
            this.capacityStatus.style.color = "#ffff00";
          } else {
            this.capacityStatus.textContent = "Fresh";
            this.capacityStatus.style.color = "#0a0";
          }

          // Update theme colors
          if (document.body.classList.contains("light-scheme")) {
            const colors = {
              Exhausted: "#cc0000",
              "Nearly Used": "#ff6600",
              "Well Used": "#ff9900",
              "Partially Used": "#ffcc00",
              Fresh: "#006600",
            };
            this.capacityStatus.style.color =
              colors[this.capacityStatus.textContent] || "#006600";
          } else if (document.body.classList.contains("day-scheme")) {
            const colors = {
              Exhausted: "#ff3333",
              "Nearly Used": "#ff9900",
              "Well Used": "#ffcc00",
              "Partially Used": "#ffff33",
              Fresh: "#33cc33",
            };
            this.capacityStatus.style.color =
              colors[this.capacityStatus.textContent] || "#33cc33";
          }
        }

        addPrints(count) {
          const areaToAdd = count * this.currentPaperSize;
          this.capacityData.printsDone =
            (this.capacityData.printsDone || 0) + count;
          this.capacityData.areaUsed =
            (this.capacityData.areaUsed || 0) + areaToAdd;
          StorageManager.saveCapacityTracker(this.capacityData);
          this.updateCapacityDisplay();
          playBeep(600, 0.2, 0.3);
        }

        resetPrints() {
          if (confirm("Reset print counter? This will start a fresh batch.")) {
            this.capacityData = {
              printsDone: 0,
              areaUsed: 0,
              paperSize: this.currentPaperSize,
              lastReset: new Date().toISOString(),
            };
            StorageManager.saveCapacityTracker(this.capacityData);
            this.updateCapacityDisplay();
            playBeep(800, 0.5, 0.3);
          }
        }

        // UPDATED: Add chemical with custom name support
        addChemical() {
          const type = this.chemicalTypeSelect.value;
          const shelfLifeDays = parseInt(this.shelfLifeDaysInput.value);
          const date = this.chemicalDateInput.value;

          if (!date) {
            alert("Please select a date");
            return;
          }

          let chemicalName;
          if (type === "custom") {
            chemicalName = this.customChemicalNameInput.value.trim();
            if (!chemicalName) {
              alert("Please enter a custom chemical name");
              return;
            }
          } else {
            chemicalName = this.getChemicalName(type);
          }

          const chemical = {
            id: Date.now(),
            type: type,
            name: chemicalName,
            dateMixed: date,
            shelfLifeDays: shelfLifeDays,
            dateAdded: new Date().toISOString(),
          };

          this.shelfLifeData.push(chemical);
          StorageManager.saveShelfLife(this.shelfLifeData);
          this.updateShelfLifeList();

          // Reset form
          this.chemicalDateInput.value = new Date().toISOString().split("T")[0];
          this.customChemicalNameInput.value = "";

          playBeep(800, 0.3, 0.3);
        }

        getChemicalName(type) {
          const names = {
            developer: "Developer",
            stopbath: "Stop Bath",
            fixer: "Fixer",
            hypoclear: "Hypo Clear",
            photof: "Photo Wash",
            custom: "Custom Chemical",
          };
          return names[type] || type;
        }

        loadShelfLifeData(data) {
          if (!data || !Array.isArray(data)) return;

          // Clear existing data
          this.shelfLifeData = [];

          // Load new data with validation
          data.forEach((chemical) => {
            if (
              chemical &&
              chemical.name &&
              chemical.dateMixed &&
              chemical.shelfLifeDays
            ) {
              this.shelfLifeData.push({
                id: chemical.id || Date.now() + Math.random(),
                type: chemical.type || "custom",
                name: chemical.name,
                dateMixed: chemical.dateMixed,
                shelfLifeDays: chemical.shelfLifeDays,
                dateAdded: chemical.dateAdded || new Date().toISOString(),
              });
            }
          });

          // Save to storage
          StorageManager.saveShelfLife(this.shelfLifeData);
          this.updateShelfLifeList();
        }

        updateShelfLifeList() {
          this.shelfLifeList.innerHTML = "";

          const today = new Date();
          this.shelfLifeData.forEach((chemical, index) => {
            const mixedDate = new Date(chemical.dateMixed);
            const expiryDate = new Date(mixedDate);
            expiryDate.setDate(expiryDate.getDate() + chemical.shelfLifeDays);

            const daysLeft = Math.ceil(
              (expiryDate - today) / (1000 * 60 * 60 * 24)
            );

            const item = document.createElement("div");
            item.className = "shelf-life-item";

            if (daysLeft < 0) {
              item.classList.add("expired");
            } else if (daysLeft <= 3) {
              item.classList.add("expiring");
            }

            let statusClass = "";
            let statusText = "";
            if (daysLeft < 0) {
              statusClass = "expired";
              statusText = "EXPIRED";
            } else if (daysLeft <= 3) {
              statusClass = "expiring";
              statusText = "EXPIRING";
            } else {
              statusText = `${daysLeft} days`;
            }

            item.innerHTML = `
                        <div>
                            <strong>${chemical.name}</strong>
                            <div style="font-size: 0.6rem; color: #600;">
                                Mixed: ${new Date(
                                  chemical.dateMixed
                                ).toLocaleDateString()}
                            </div>
                            <div style="font-size: 0.6rem; color: #600;">
                                Expires: ${expiryDate.toLocaleDateString()}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div class="shelf-life-days ${statusClass}">${statusText}</div>
                            <div class="shelf-life-actions">
                                <button class="shelf-life-btn renew-chemical" data-id="${
                                  chemical.id
                                }">Renew</button>
                                <button class="shelf-life-btn delete-chemical" data-id="${
                                  chemical.id
                                }">Delete</button>
                            </div>
                        </div>
                    `;

            this.shelfLifeList.appendChild(item);
          });

          // Add event listeners
          document.querySelectorAll(".renew-chemical").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const id = parseInt(e.target.getAttribute("data-id"));
              this.renewChemical(id);
            });
          });

          document.querySelectorAll(".delete-chemical").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const id = parseInt(e.target.getAttribute("data-id"));
              this.deleteChemical(id);
            });
          });
        }

        renewChemical(id) {
          if (
            confirm(
              "Renew this chemical? This will reset its shelf life from today."
            )
          ) {
            const index = this.shelfLifeData.findIndex((c) => c.id === id);
            if (index !== -1) {
              this.shelfLifeData[index].dateMixed = new Date()
                .toISOString()
                .split("T")[0];
              StorageManager.saveShelfLife(this.shelfLifeData);
              this.updateShelfLifeList();
              playBeep(600, 0.3, 0.3);
            }
          }
        }

        deleteChemical(id) {
          if (confirm("Delete this chemical from tracking?")) {
            this.shelfLifeData = this.shelfLifeData.filter((c) => c.id !== id);
            StorageManager.saveShelfLife(this.shelfLifeData);
            this.updateShelfLifeList();
            playBeep(400, 0.3, 0.3);
          }
        }

        clearExpired() {
          if (confirm("Remove all expired chemicals?")) {
            const today = new Date();
            this.shelfLifeData = this.shelfLifeData.filter((chemical) => {
              const mixedDate = new Date(chemical.dateMixed);
              const expiryDate = new Date(mixedDate);
              expiryDate.setDate(expiryDate.getDate() + chemical.shelfLifeDays);
              const daysLeft = Math.ceil(
                (expiryDate - today) / (1000 * 60 * 60 * 24)
              );
              return daysLeft > 0;
            });

            StorageManager.saveShelfLife(this.shelfLifeData);
            this.updateShelfLifeList();
            playBeep(800, 0.5, 0.3);
          }
        }

        updateDisplay() {
          this.updateMixCalculator();
          this.updateCapacityDisplay();
          this.updateChemicalPresetList();
          this.updateShelfLifeList();
        }
      }

      // Relay Manager Class (complete version)
      // Relay Manager Class - FIXED VERSION
      class RelayManager {
        constructor() {
          this.serverIP = "192.168.1.100";
          this.serverPort = 5000;
          this.autoTrigger = true;
          this.safelightAutoOff = true; // NEW: Default to enabled
          this.safelightWasOn = false; // NEW: Track if safelight was on before enlarger

          this.relayStates = {
            1: false, // GPIO 25 - Enlarger Timer
            2: false, // GPIO 17 - Safelight
            3: false, // GPIO 27 - Ventilation
            4: false, // GPIO 22 - White Light
          };

          this.init();
        }

        // In the init() method, load the setting:
        init() {
          // Load saved settings
          this.loadSettings();

          // Get elements
          this.relayServerIP = document.getElementById("relayServerIP");
          this.relayServerPort = document.getElementById("relayServerPort");
          this.testRelayConnectionBtn = document.getElementById(
            "testRelayConnection"
          );
          this.relayStatus = document.getElementById("relayStatus");
          this.autoTriggerRelay = document.getElementById("autoTriggerRelay");
          this.testTimerRelayBtn = document.getElementById("testTimerRelay");
          this.testTimerSeconds = document.getElementById("testTimerSeconds");
          this.allRelaysOnBtn = document.getElementById("allRelaysOn");
          this.allRelaysOffBtn = document.getElementById("allRelaysOff");

          // Set initial values
          if (this.relayServerIP) this.relayServerIP.value = this.serverIP;
          if (this.relayServerPort)
            this.relayServerPort.value = this.serverPort;
          if (this.autoTriggerRelay)
            this.autoTriggerRelay.checked = this.autoTrigger;

          // Add event listeners
          // In the init() method, add:
          const shutdownBtn = document.getElementById("shutdownPi");
          if (shutdownBtn) {
            shutdownBtn.addEventListener("click", () => this.shutdownPi());
          }
          const rebootBtn = document.getElementById("rebootPi");
          if (rebootBtn) {
            rebootBtn.addEventListener("click", () => this.rebootPi());
          }

          if (this.relayServerIP)
            this.relayServerIP.addEventListener("change", () =>
              this.saveSettings()
            );
          if (this.relayServerPort)
            this.relayServerPort.addEventListener("change", () =>
              this.saveSettings()
            );
          if (this.autoTriggerRelay)
            this.autoTriggerRelay.addEventListener("change", () =>
              this.saveSettings()
            );
          if (this.testRelayConnectionBtn)
            this.testRelayConnectionBtn.addEventListener("click", () =>
              this.testConnection()
            );
          if (this.testTimerRelayBtn)
            this.testTimerRelayBtn.addEventListener("click", () =>
              this.testTimerRelay()
            );
          if (this.allRelaysOnBtn)
            this.allRelaysOnBtn.addEventListener("click", () =>
              this.allRelaysOn()
            );
          if (this.allRelaysOffBtn)
            this.allRelaysOffBtn.addEventListener("click", () =>
              this.allRelaysOff()
            );

          // Initialize relay toggle buttons
          this.initRelayToggleButtons();

          // Update UI
          this.updateRelayButtons();
          // Load safelight auto-off setting from settingsManager
          if (settingsManager) {
            this.safelightAutoOff =
              settingsManager.settings.safelightAutoOff !== false;
          }
          // Update safelight auto-off status display
          this.updateSafelightAutoOffStatus();

          // Add event listener for the toggle in settings
          document
            .getElementById("safelightAutoOff")
            ?.addEventListener("change", () => {
              this.safelightAutoOff =
                document.getElementById("safelightAutoOff").checked;
              this.saveSettings();
              this.updateSafelightAutoOffStatus();
            });
        }

        // Add to the RelayManager class
        async shutdownPi() {
          if (
            !confirm(
              "Are you sure you want to shutdown the Raspberry Pi?\n\nThe server will stop and the Pi will power off."
            )
          ) {
            return;
          }

          try {
            const response = await this.sendRequest("shutdown");

            if (response) {
              this.updateStatus(
                "Shutdown command sent. Raspberry Pi will power off in 3 seconds...",
                "success"
              );

              // Visual feedback
              const btn = document.getElementById("shutdownPi");
              if (btn) {
                const originalText = btn.textContent;
                btn.textContent = "Shutting down...";
                btn.disabled = true;

                // Update status message after a delay
                setTimeout(() => {
                  this.updateStatus(
                    "Raspberry Pi is shutting down. Server connection will be lost.",
                    "info"
                  );
                }, 2000);

                setTimeout(() => {
                  btn.textContent = originalText;
                  btn.disabled = false;
                }, 5000);
              }
            }
          } catch (error) {
            this.updateStatus("Failed to send shutdown command", "error");
            console.error("Shutdown error:", error);
          }
        }

        // Add to the RelayManager class
        async rebootPi() {
          if (
            !confirm(
              "Are you sure you want to reboot the Raspberry Pi?\n\nThe server will stop and the Pi will power off."
            )
          ) {
            return;
          }

          try {
            const response = await this.sendRequest("reboot");

            if (response) {
              this.updateStatus(
                "Reboot command sent. Raspberry Pi will reboot in 3 seconds...",
                "success"
              );

              // Visual feedback
              const btn = document.getElementById("rebootPi");
              if (btn) {
                const originalText = btn.textContent;
                btn.textContent = "Reboot...";
                btn.disabled = true;

                // Update status message after a delay
                setTimeout(() => {
                  this.updateStatus(
                    "Raspberry Pi is rebooting. Server connection will be lost.",
                    "info"
                  );
                }, 2000);

                setTimeout(() => {
                  btn.textContent = originalText;
                  btn.disabled = false;
                }, 5000);
              }
            }
          } catch (error) {
            this.updateStatus("Failed to send reboot command", "error");
            console.error("Shutdown error:", error);
          }
        }

        // In the RelayManager class, add a method to update the status display:
        updateSafelightAutoOffStatus() {
          const statusElement = document.getElementById(
            "safelightAutoOffStatus"
          );
          if (!statusElement) return;

          if (this.safelightAutoOff) {
            statusElement.textContent = "ENABLED";
            statusElement.style.color = "#f00";

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              statusElement.style.color = "#0066cc";
            } else if (document.body.classList.contains("day-scheme")) {
              statusElement.style.color = "#ffcc00";
            }
          } else {
            statusElement.textContent = "DISABLED";
            statusElement.style.color = "#900";

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              statusElement.style.color = "#666";
            } else if (document.body.classList.contains("day-scheme")) {
              statusElement.style.color = "#ccc";
            }
          }
        }

        initRelayToggleButtons() {
          document.querySelectorAll(".relay-toggle-btn").forEach((btn) => {
            const relayNum = parseInt(btn.getAttribute("data-relay"));
            btn.addEventListener("click", () => this.toggleRelay(relayNum));
          });
        }

        // In the saveSettings() method, add safelightAutoOff:
        saveSettings() {
          this.serverIP = this.relayServerIP
            ? this.relayServerIP.value
            : "192.168.1.100";
          this.serverPort = this.relayServerPort
            ? parseInt(this.relayServerPort.value)
            : 5000;
          this.autoTrigger = this.autoTriggerRelay
            ? this.autoTriggerRelay.checked
            : true;

          // NEW: Get safelight auto-off setting
          this.safelightAutoOff = document.getElementById("safelightAutoOff")
            ? document.getElementById("safelightAutoOff").checked
            : true;

          try {
            localStorage.setItem(
              "relaySettings",
              JSON.stringify({
                serverIP: this.serverIP,
                serverPort: this.serverPort,
                autoTrigger: this.autoTrigger,
                safelightAutoOff: this.safelightAutoOff, // NEW
              })
            );
          } catch (e) {
            console.error("Failed to save relay settings:", e);
          }
        }

        // In the loadSettings() method, load safelightAutoOff:
        loadSettings() {
          try {
            const saved = localStorage.getItem("relaySettings");
            if (saved) {
              const settings = JSON.parse(saved);
              this.serverIP = settings.serverIP || "192.168.1.100";
              this.serverPort = settings.serverPort || 5000;
              this.autoTrigger = settings.autoTrigger !== false;
              this.safelightAutoOff = settings.safelightAutoOff !== false; // NEW: Default to true

              // Load relay states
              const savedStates = localStorage.getItem("relayStates");
              if (savedStates) {
                this.relayStates = JSON.parse(savedStates);
              }
            }
          } catch (e) {
            console.error("Failed to load relay settings:", e);
          }
        }

        async sendRequest(endpoint, params = {}) {
          const url = `http://${this.serverIP}:${this.serverPort}/${endpoint}`;
          const queryString = Object.keys(params)
            .map(
              (key) =>
                `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`
            )
            .join("&");

          const fullUrl = queryString ? `${url}?${queryString}` : url;

          try {
            // Try with CORS first (for Chrome/Safari)
            const response = await fetch(fullUrl, {
              method: "GET",
              mode: "cors",
              cache: "no-cache",
              headers: {
                Accept: "application/json",
              },
            });

            if (response.ok) {
              return true;
            } else {
              throw new Error(`HTTP ${response.status}`);
            }
          } catch (error) {
            console.warn(
              "CORS fetch failed, trying alternative methods:",
              error
            );

            // Fallback 1: Try with no-cors mode
            try {
              await fetch(fullUrl, {
                method: "GET",
                mode: "no-cors",
                cache: "no-cache",
              });
              return true; // Assume success (we can't read response in no-cors mode)
            } catch (noCorsError) {
              console.warn("No-cors fetch failed:", noCorsError);

              // Fallback 2: Use Image object (works for GET requests, no CORS)
              return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);

                // Add cache-busting parameter
                const cacheBuster = `&_=${Date.now()}`;
                img.src =
                  fullUrl +
                  (fullUrl.includes("?") ? cacheBuster : "?" + cacheBuster);

                // Timeout after 3 seconds
                setTimeout(() => resolve(false), 3000);
              });
            }
          }
        }
        // Add this method to the RelayManager class:
        async handleSafelightAutoOff(relayNum, newState) {
          // If safelight auto-off is disabled, do nothing
          if (!this.safelightAutoOff) return;

          // If enlarger (relay 1) is being turned ON
          if (relayNum === 1 && newState === true) {
            // Check if safelight (relay 2) is currently on
            if (this.relayStates[2]) {
              // Remember that safelight was on
              this.safelightWasOn = true;
              console.log(
                "Safelight was on, turning it off because enlarger is on"
              );

              // Turn off safelight
              await this.setRelay(2, false);
            } else {
              this.safelightWasOn = false;
            }
          }
          // If enlarger (relay 1) is being turned OFF
          else if (relayNum === 1 && newState === false) {
            // Check if we previously turned off the safelight
            if (this.safelightWasOn) {
              console.log("Enlarger turned off, restoring safelight");

              // Wait a moment before restoring safelight (optional)
              setTimeout(async () => {
                // Only restore if user hasn't manually turned it back on
                if (!this.relayStates[2]) {
                  await this.setRelay(2, true);
                }
                this.safelightWasOn = false;
              }, 500); // 0.5 second delay
            }
          }
        }

        // Update the toggleRelay method to call handleSafelightAutoOff:
        async toggleRelay(relayNum) {
          const newState = !this.relayStates[relayNum];
          const gpioPin = this.getGPIOPin(relayNum);

          // Handle safelight auto-off logic BEFORE toggling
          await this.handleSafelightAutoOff(relayNum, newState);

          const success = await this.sendRequest("relay", {
            gpio: gpioPin,
            state: newState ? "on" : "off",
          });

          if (success) {
            this.relayStates[relayNum] = newState;
            localStorage.setItem(
              "relayStates",
              JSON.stringify(this.relayStates)
            );
            this.updateRelayButtons();
            this.updateStatus(
              `Relay ${relayNum} ${newState ? "ON" : "OFF"}`,
              "success"
            );
            playBeep(newState ? 800 : 400, 0.1, 0.3);
          }
        }

        // Update the setRelay method to also handle safelight auto-off:
        async setRelay(relayNum, state) {
          const gpioPin = this.getGPIOPin(relayNum);
          const stateStr = state ? "on" : "off";

          // Handle safelight auto-off logic
          await this.handleSafelightAutoOff(relayNum, state);

          const success = await this.sendRequest("relay", {
            gpio: gpioPin,
            state: stateStr,
          });

          if (success) {
            this.relayStates[relayNum] = state;
            localStorage.setItem(
              "relayStates",
              JSON.stringify(this.relayStates)
            );
            this.updateRelayButtons();
          }
        }

        getGPIOPin(relayNum) {
          const pinMap = {
            1: 25, // Enlarger Timer
            2: 17, // Safelight
            3: 27, // Ventilation
            4: 22, // White Light
          };
          return pinMap[relayNum] || 14;
        }

        // Update the triggerTimerRelay method:
        async triggerTimerRelay(durationSeconds) {
          if (!this.autoTrigger) {
            console.log("Auto-trigger disabled");
            return;
          }

          // NEW: Handle safelight auto-off when timer starts
          if (this.safelightAutoOff && this.relayStates[2]) {
            console.log("Timer starting - turning off safelight");
            this.safelightWasOn = true;
            await this.setRelay(2, false);
          }

          // Send single request with duration parameter
          const success = await this.sendRequest("timer", {
            gpio: 25,
            duration: durationSeconds.toFixed(3),
          });

          if (success) {
            this.updateStatus(
              `Timer relay triggered for ${durationSeconds}s`,
              "success"
            );

            // NEW: Restore safelight after timer completes
            if (this.safelightAutoOff && this.safelightWasOn) {
              setTimeout(async () => {
                console.log("Timer completed - restoring safelight");
                if (!this.relayStates[2]) {
                  await this.setRelay(2, true);
                }
                this.safelightWasOn = false;
              }, durationSeconds * 1000 + 500); // Add 0.5s buffer
            }
          } else {
            this.updateStatus("Timer relay failed", "error");
          }
        }

        async testConnection() {
          this.updateStatus("Testing connection...", "info");

          // Try to ping the server
          const success = await this.sendRequest("ping");

          if (success) {
            this.updateStatus("Connected successfully!", "success");
            playBeep(600, 0.3, 0.3);
          } else {
            this.updateStatus("Connection failed", "error");
          }
        }

        async testTimerRelay() {
          const seconds = parseFloat(
            this.testTimerSeconds ? this.testTimerSeconds.value : 5
          );
          if (seconds > 0) {
            await this.triggerTimerRelay(seconds);
          }
        }

        async allRelaysOn() {
          // If safelight auto-off is enabled and we're turning on enlarger,
          // we should handle safelight appropriately
          if (this.safelightAutoOff) {
            // Turn on all relays except safelight if enlarger is being turned on
            for (let i = 1; i <= 4; i++) {
              if (i === 2 && this.relayStates[1]) {
                // Skip turning on safelight if enlarger is already on or about to be on
                continue;
              }
              await this.setRelay(i, true);
            }
          } else {
            // Original behavior
            for (let i = 1; i <= 4; i++) {
              await this.setRelay(i, true);
            }
          }

          this.updateStatus("All relays ON", "success");
          playBeep(800, 0.5, 0.3);
        }

        async allRelaysOff() {
          for (let i = 1; i <= 4; i++) {
            await this.setRelay(i, false);
          }
          this.safelightWasOn = false; // Reset the flag
          this.updateStatus("All relays OFF", "success");
          playBeep(400, 0.5, 0.3);
        }

        updateRelayButtons() {
          document.querySelectorAll(".relay-toggle-btn").forEach((btn) => {
            const relayNum = parseInt(btn.getAttribute("data-relay"));
            const state = this.relayStates[relayNum];

            btn.textContent = state ? "ON" : "OFF";
            btn.classList.toggle("on", state);
          });
        }

        updateStatus(message, type = "info") {
          if (!this.relayStatus) return;

          this.relayStatus.textContent = message;

          // Set color based on type and theme
          if (document.body.classList.contains("light-scheme")) {
            this.relayStatus.style.color =
              type === "success"
                ? "#006600"
                : type === "error"
                ? "#cc0000"
                : "#666";
          } else if (document.body.classList.contains("day-scheme")) {
            this.relayStatus.style.color =
              type === "success"
                ? "#33cc33"
                : type === "error"
                ? "#ff3333"
                : "#ccc";
          } else {
            const colors = {
              success: "#0a0",
              error: "#f00",
              info: "#900",
            };
            this.relayStatus.style.color = colors[type] || "#900";
          }
        }
      }

      // Load settings to UI - UPDATED with countdown settings AND auto advance
      function loadSettingsToUI() {
        if (!settingsManager) return;

        document.getElementById("settingBaseTime").value =
          settingsManager.settings.baseTime;
        document.getElementById("settingDevTime").value =
          settingsManager.settings.devTime;
        document.getElementById("settingStopTime").value =
          settingsManager.settings.stopTime;
        document.getElementById("settingFixTime").value =
          settingsManager.settings.fixTime;
        document.getElementById("settingFloTime").value =
          settingsManager.settings.floTime;
        document.getElementById("settingCalcWarningBeep").checked =
          settingsManager.settings.calcWarningBeep;
        document.getElementById("settingCalcEndBeep").checked =
          settingsManager.settings.calcEndBeep;
        document.getElementById("settingAutoStart").checked =
          settingsManager.settings.autoStart;
        document.getElementById("settingTimerWarningBeep").checked =
          settingsManager.settings.timerWarningBeep;
        document.getElementById("settingTimerEndBeep").checked =
          settingsManager.settings.timerEndBeep;
        document.getElementById("settingDefaultPhotoFlo").checked =
          settingsManager.settings.defaultPhotoFlo;

        // Countdown settings
        document.getElementById("settingCountdownDelay").value =
          settingsManager.settings.countdownDelay;
        document.getElementById("settingCountdownBeep").checked =
          settingsManager.settings.countdownBeep;
        document.getElementById("settingCountdownPattern").value =
          settingsManager.settings.countdownPattern || "every-second"; // NEW

        // NEW: Auto advance setting
        document.getElementById("settingAutoAdvance").checked =
          settingsManager.settings.autoAdvance;

        // Apply auto advance to F-Stop Test generator
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.setAutoAdvance(
            settingsManager.settings.autoAdvance
          );
        }
        document.getElementById("settingAutoAdvanceDelay").value =
          settingsManager.settings.autoAdvanceDelay || 1;

        // Apply auto advance to F-Stop Test generator
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.setAutoAdvance(
            settingsManager.settings.autoAdvance
          );
          window.fstopTestGenerator.setAutoAdvanceDelay(
            (settingsManager.settings.autoAdvanceDelay || 1) * 1000
          );
        }

        // Load base time slider limits
        const baseTimeMinInput = document.getElementById("baseTimeMin");
        const baseTimeMaxInput = document.getElementById("baseTimeMax");
        if (baseTimeMinInput) {
          baseTimeMinInput.value = settingsManager.settings.baseTimeMin || 0.4;
        }
        if (baseTimeMaxInput) {
          baseTimeMaxInput.value = settingsManager.settings.baseTimeMax || 50;
        }

        // Apply limits to BASE TIME slider
        const baseTimeSlider = document.getElementById("baseTimeSlider");
        if (baseTimeSlider) {
          baseTimeSlider.min = settingsManager.settings.baseTimeMin || 0.4;
          baseTimeSlider.max = settingsManager.settings.baseTimeMax || 50;
        }

        // Load test base time slider limits
        const testBaseTimeMinInput = document.getElementById("testBaseTimeMin");
        const testBaseTimeMaxInput = document.getElementById("testBaseTimeMax");
        if (testBaseTimeMinInput) {
          testBaseTimeMinInput.value =
            settingsManager.settings.testBaseTimeMin || 1;
        }
        if (testBaseTimeMaxInput) {
          testBaseTimeMaxInput.value =
            settingsManager.settings.testBaseTimeMax || 50;
        }

        // Apply limits to TEST BASE TIME slider
        const testBaseSlider = document.getElementById("testBaseSlider");
        if (testBaseSlider) {
          testBaseSlider.min = settingsManager.settings.testBaseTimeMin || 1;
          testBaseSlider.max = settingsManager.settings.testBaseTimeMax || 50;
        }

        // F-stop increment denominator (persisted setting)
        const savedDenom = settingsManager.settings.stopDenominator || 3;
        const cSeg = document.getElementById("calcIncrementSeg");
        const tSeg = document.getElementById("testIncrementSeg");
        if (cSeg) {
          Array.from(cSeg.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === savedDenom;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        if (tSeg) {
          Array.from(tSeg.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === savedDenom;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        const oldC = document.getElementById("calcIncrementDenom");
        if (oldC) oldC.value = savedDenom;
        const oldT = document.getElementById("testIncrementDenom");
        if (oldT) oldT.value = savedDenom;
        const settingsSel = document.getElementById("settingStopIncrement");
        if (settingsSel) settingsSel.value = savedDenom;
        window.stopDenominator = savedDenom;

        // Apply base time to calculator and test generator (on load)
        (function applyLoadedBaseAndTimerDefaults() {
          const newBase = parseFloat(
            settingsManager.settings.baseTime || DEFAULT_SETTINGS.baseTime
          );
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            baseSlider.value = newBase;
            baseSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }
          const testBase = document.getElementById("testBaseSlider");
          if (testBase) {
            testBase.value = newBase;
            testBase.dispatchEvent(new Event("input", { bubbles: true }));
          }

          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = newBase;
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }

          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.baseTime = newBase;
            if (window.fstopTestGenerator.testBaseSlider) {
              window.fstopTestGenerator.testBaseSlider.value = newBase;
            }
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }

          // Apply saved default timer values
          const mapping = {
            Dev: parseInt(settingsManager.settings.devTime, 10),
            Stop: parseInt(settingsManager.settings.stopTime, 10),
            Fix: parseInt(settingsManager.settings.fixTime, 10),
            Flo: parseInt(settingsManager.settings.floTime, 10),
          };

          // Update DEFAULT_TIMER_TIMES so future timers use these defaults
          Object.keys(mapping).forEach((k) => {
            if (typeof mapping[k] === "number" && !isNaN(mapping[k])) {
              DEFAULT_TIMER_TIMES[k] = mapping[k];
            }
          });

          // Update any existing timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              const newTime = mapping[timer.name];
              if (typeof newTime === "number" && !isNaN(newTime)) {
                if (!timer.isRunning) {
                  timer.setTime(newTime);
                } else {
                  timer.totalTime = newTime;
                  timer.timeLeft = newTime;
                  timer.warningPlayed = false;
                  timer.updateDisplay();
                  timer.updateButtonStates();
                }
              }
            });
          }
        })();

        // NEW: Safelight auto-off setting
        document.getElementById("safelightAutoOff").checked =
          settingsManager.settings.safelightAutoOff !== false; // Default to true
      }

      // Timer Manager
      timerManager = {
        timers: [],
        init: function () {
          // Create timers
          this.timers = [
            new Timer("Dev"),
            new Timer("Stop"),
            new Timer("Fix"),
            new Timer("Flo"),
          ];

          // Apply settings if available
          if (settingsManager) {
            // Apply saved profile if exists
            if (settingsManager.currentProfile) {
              const profile = settingsManager.profiles.find(
                (p) => p.name === settingsManager.currentProfile
              );
              if (profile && profile.times) {
                this.timers.forEach((timer) => {
                  if (profile.times[timer.name] !== undefined) {
                    timer.setTime(profile.times[timer.name]);
                  }
                });
              }
            }

            // Apply Photo Wash toggle
            const photoFloToggle = document.getElementById("photoFloToggle");
            photoFloToggle.checked = settingsManager.settings.defaultPhotoFlo;
            const floTimer = this.timers.find((t) => t.name === "Flo");
            if (floTimer) {
              floTimer.updateEnabledState(
                settingsManager.settings.defaultPhotoFlo
              );
            }

            // Add change listener
            photoFloToggle.addEventListener("change", () => {
              const floTimer = this.timers.find((t) => t.name === "Flo");
              if (floTimer) {
                floTimer.updateEnabledState(photoFloToggle.checked);
              }
            });
          }

          // Start All button - UPDATED with countdown
          document
            .getElementById("startAll")
            .addEventListener("click", async () => {
              const firstEnabledTimer = this.timers.find((t) => t.isEnabled);
              if (!firstEnabledTimer) return;

              // Disable buttons during countdown
              document.getElementById("startAll").disabled = true;
              document.getElementById("resetAll").disabled = true;

              // Start countdown on first timer's display
              const display = document.getElementById(
                `display${firstEnabledTimer.name}`
              );
              const originalText = display.textContent;

              await new Promise((resolve) => {
                window.countdownManager.startCountdown(display, () => {
                  resolve();
                });
              });

              // Restore display and enable buttons
              display.textContent = originalText;
              document.getElementById("startAll").disabled = false;
              document.getElementById("resetAll").disabled = false;

              // Start the timer
              firstEnabledTimer.reset();
              firstEnabledTimer.start();
            });

          // Reset All button
          document.getElementById("resetAll").addEventListener("click", () => {
            this.timers.forEach((timer) => {
              if (!timer.isRunning && timer.isEnabled) {
                timer.reset();
              }
            });
          });

          // Initialize audio context on any click
          document.addEventListener("click", initAudioContext);
        },
      };

      // Calculator functions
      const baseTimeSlider = document.getElementById("baseTimeSlider");
      const stopSlider = document.getElementById("stopSlider");
      const chartBaseSlider = document.getElementById("chartBaseSlider");

      function formatStop(value) {
        const denom = window.stopDenominator || 3;
        const val = value / denom; // actual stops
        const sign = val < 0 ? "-" : "";
        const absVal = Math.abs(val);
        const whole = Math.floor(absVal);
        const frac = absVal - whole;
        const tol = 1e-6;

        if (Math.abs(frac) < tol) return `${sign}${whole}.0`;

        if (denom === 2) {
          if (Math.abs(frac - 0.5) < tol) return `${sign}${whole}Â½`;
        } else if (denom === 3) {
          if (Math.abs(frac - 1 / 3) < tol) return `${sign}${whole}â…“`;
          if (Math.abs(frac - 2 / 3) < tol) return `${sign}${whole}â…”`;
        } else if (denom === 4) {
          if (Math.abs(frac - 0.25) < tol) return `${sign}${whole}Â¹â„â‚„`;
          if (Math.abs(frac - 0.5) < tol) return `${sign}${whole}Â²â„â‚„`;
          if (Math.abs(frac - 0.75) < tol) return `${sign}${whole}Â³â„â‚„`;
        } else if (denom === 6) {
          if (Math.abs(frac - 1 / 6) < tol) return `${sign}${whole}Â¹â„â‚†`;
          if (Math.abs(frac - 2 / 6) < tol) return `${sign}${whole}Â²â„â‚†`;
          if (Math.abs(frac - 3 / 6) < tol) return `${sign}${whole}Â³â„â‚†`;
          if (Math.abs(frac - 4 / 6) < tol) return `${sign}${whole}â´â„â‚†`;
          if (Math.abs(frac - 5 / 6) < tol) return `${sign}${whole}âµâ„â‚†`;
        }

        return `${sign}${absVal.toFixed(1)}`;
      }

      function calculateTime(base, stop) {
        const denom = window.stopDenominator || 3;
        return base * Math.pow(2, stop / denom);
      }

      // FIXED: Enhanced IncrementalTimer with proper button states
      class IncrementalTimer {
        constructor() {
          this.baseTime = 10.0;
          this.currentStop = 0;
          this.previousTotalTime = 0;
          this.currentTotalTime = 10.0;
          this.thisExposureTime = 10.0;
          this.accumulatedTime = 0;

          this.currentTime = 10.0;
          this.isRunning = false;
          this.isPaused = false;
          this.interval = null;
          this.lastBeepSecond = null;

          // Track last exposure time for repeat
          this.lastExposureTime = 10.0;

          this.init();
          this.updateAllDisplays();
        }

        init() {
          document
            .getElementById("startExposure")
            .addEventListener("click", () => this.toggle());
          document
            .getElementById("stopCalcTimer")
            .addEventListener("click", () => this.stopCurrentExposure());
          document
            .getElementById("resetCalcTimer")
            .addEventListener("click", () => this.reset());

          // Add repeat button event listener
          document
            .getElementById("repeatExposure")
            .addEventListener("click", () => this.repeatLast());

          baseTimeSlider.addEventListener("input", () =>
            this.updateFromSliders()
          );
          stopSlider.addEventListener("input", () => this.updateFromSliders());

          // Initialize audio on first click
          document
            .getElementById("startExposure")
            .addEventListener("click", initAudioContext);
        }

        // Stop current exposure (resets current exposure time)
        stopCurrentExposure() {
          if (!this.isRunning && !this.isPaused) return;

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Reset current time to current exposure time
          this.currentTime = this.thisExposureTime;

          // Update displays
          document.getElementById("timerStatus").textContent =
            "EXPOSURE STOPPED";
          document.getElementById("calcTimerDisplay").textContent =
            this.currentTime.toFixed(2);
          document.getElementById("startExposure").textContent =
            "Start Exposure";
          document.getElementById("startExposure").disabled = false; // FIX: Enable start button
          document.getElementById("stopCalcTimer").disabled = true;
          document.getElementById("resetCalcTimer").disabled = false; // FIX: Enable reset button
          document
            .getElementById("calcTimerDisplay")
            .classList.remove("warning");

          playBeep(600, 0.3, 0.2);
        }

        // Repeat last exposure method
        repeatLast() {
          if (this.lastExposureTime <= 0) return;

          // Set current exposure to last exposure time
          this.thisExposureTime = this.lastExposureTime;
          this.currentTime = this.lastExposureTime;

          // Reset timer state
          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Update displays
          document.getElementById("timerStatus").textContent =
            "READY TO REPEAT";
          document.getElementById("calcTimerDisplay").textContent =
            this.currentTime.toFixed(2);
          document.getElementById("thisExposureDisplay").textContent =
            this.thisExposureTime.toFixed(2);

          // Enable start button, disable stop button
          document.getElementById("startExposure").disabled = false;
          document.getElementById("startExposure").textContent =
            "Start Exposure";
          document.getElementById("stopCalcTimer").disabled = true;
          document.getElementById("repeatExposure").disabled = false; // Keep repeat enabled

          playBeep(600, 0.3, 0.2);
        }

        updateFromSliders() {
          this.baseTime = parseFloat(baseTimeSlider.value);
          this.currentStop = parseInt(stopSlider.value);
          this.updateCalculations();
          this.updateAllDisplays();
        }

        updateCalculations() {
          this.currentTotalTime = calculateTime(
            this.baseTime,
            this.currentStop
          );
          this.thisExposureTime = this.currentTotalTime - this.accumulatedTime;

          if (this.thisExposureTime < 0) {
            this.thisExposureTime = 0;
          }

          if (!this.isRunning && !this.isPaused) {
            this.currentTime = this.thisExposureTime;
          }
        }

        updateAllDisplays() {
          document.getElementById(
            "baseTimeValue"
          ).textContent = `${this.baseTime.toFixed(1)}s`;
          document.getElementById("stopValue").textContent = formatStop(
            this.currentStop
          );
          document.getElementById("resultTime").textContent =
            this.currentTotalTime.toFixed(2);
          document.getElementById("resultDetails").textContent = `${formatStop(
            this.currentStop
          )} STOPS`;

          document.getElementById("selectedStopDisplay").textContent =
            formatStop(this.currentStop);
          document.getElementById("previousTotalDisplay").textContent =
            this.accumulatedTime.toFixed(2);
          document.getElementById("currentTotalDisplay").textContent =
            this.currentTotalTime.toFixed(2);
          document.getElementById("thisExposureDisplay").textContent =
            this.thisExposureTime.toFixed(2);

          document.getElementById("calcTimerDisplay").textContent =
            this.currentTime.toFixed(2);

          if (typeof chartBaseSlider !== "undefined" && chartBaseSlider) {
            if (typeof chartBaseSlider !== "undefined" && chartBaseSlider)
              chartBaseSlider.value = this.baseTime;
          } else {
            const cbVal = document.getElementById("chartBaseValue");
            if (cbVal) cbVal.textContent = `${this.baseTime.toFixed(1)}s`;
          }
          updateChart();
        }

        // Add to IncrementalTimer class (around line 1500)
        async triggerRelayForTimer() {
          if (window.relayManager && window.relayManager.autoTrigger) {
            // Use the current exposure time
            const exposureTime = this.thisExposureTime;

            // Send relay trigger with the exposure time
            await window.relayManager.triggerTimerRelay(exposureTime);
          }
        }

        // In the IncrementalTimer.start() method (around line 1500), update to async:
        async start() {
          if (this.isRunning || this.thisExposureTime <= 0) return;

          // Disable buttons during countdown
          document.getElementById("startExposure").disabled = true;
          document.getElementById("stopCalcTimer").disabled = true;
          document.getElementById("resetCalcTimer").disabled = true;
          document.getElementById("repeatExposure").disabled = true;

          // Start countdown
          const display = document.getElementById("calcTimerDisplay");
          const originalText = display.textContent;
          document.getElementById("timerStatus").textContent =
            "COUNTDOWN STARTING...";

          await new Promise((resolve) => {
            window.countdownManager.startCountdown(display, () => {
              resolve();
            });
          });

          // Restore display and enable buttons
          display.textContent = originalText;
          document.getElementById("timerStatus").textContent =
            "EXPOSURE IN PROGRESS";

          // TRIGGER RELAY HERE
          if (window.relayManager && window.relayManager.autoTrigger) {
            try {
              await window.relayManager.triggerTimerRelay(
                this.thisExposureTime
              );
            } catch (error) {
              console.error("Failed to trigger relay:", error);
            }
          }

          // Now start the actual exposure timer
          this.isRunning = true;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Enable and set proper button states
          document.getElementById("startExposure").disabled = false;
          document.getElementById("startExposure").textContent = "Pause";
          document.getElementById("stopCalcTimer").disabled = false;
          document.getElementById("resetCalcTimer").disabled = true;
          document.getElementById("repeatExposure").disabled = true;

          this.startInterval();
        }

        startInterval() {
          this.interval = setInterval(() => {
            this.currentTime -= 0.1;

            if (this.currentTime <= 0) {
              this.currentTime = 0;
              this.complete();
            } else {
              document.getElementById("calcTimerDisplay").textContent =
                this.currentTime.toFixed(2);

              if (
                this.currentTime <= 3 &&
                document.getElementById("calcWarningBeep").checked
              ) {
                const currentSecond = Math.ceil(this.currentTime);

                if (
                  currentSecond !== this.lastBeepSecond &&
                  currentSecond <= 3 &&
                  currentSecond > 0
                ) {
                  this.lastBeepSecond = currentSecond;
                  playBeep(600, 0.3, 0.3);
                  document
                    .getElementById("calcTimerDisplay")
                    .classList.add("warning");

                  setTimeout(() => {
                    document
                      .getElementById("calcTimerDisplay")
                      .classList.remove("warning");
                  }, 500);
                }
              }
            }
          }, 100);
        }

        pause() {
          if (!this.isRunning) return;

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = true;

          document.getElementById("timerStatus").textContent =
            "EXPOSURE PAUSED";
          document.getElementById("startExposure").textContent = "Resume";
          document.getElementById("startExposure").disabled = false; // FIX: Ensure button is enabled
          document
            .getElementById("calcTimerDisplay")
            .classList.remove("warning");

          playBeep(400, 0.3, 0.2);
        }

        resume() {
          if (!this.isPaused) return;

          this.isRunning = true;
          this.isPaused = false;
          this.lastBeepSecond = null;

          document.getElementById("timerStatus").textContent =
            "EXPOSURE IN PROGRESS";
          document.getElementById("startExposure").textContent = "Pause";
          document.getElementById("startExposure").disabled = false; // FIX: Ensure button is enabled

          this.startInterval();
        }

        complete() {
          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Save the exposure time that just completed
          this.lastExposureTime = this.thisExposureTime;

          this.accumulatedTime = this.currentTotalTime;

          if (document.getElementById("calcEndBeep").checked) {
            playBeep(1600, 0.1, 0.5);
          }

          document.getElementById("timerStatus").textContent =
            "EXPOSURE COMPLETE";
          document.getElementById("startExposure").textContent = "Start Next";
          document.getElementById("startExposure").disabled = false; // FIX: Enable for next exposure
          document.getElementById("stopCalcTimer").disabled = true;
          document.getElementById("resetCalcTimer").disabled = false; // FIX: Enable reset button

          // Enable repeat button
          document.getElementById("repeatExposure").disabled = false;

          document
            .getElementById("calcTimerDisplay")
            .classList.remove("warning");

          this.updateCalculations();
          this.updateAllDisplays();

          this.currentTime = this.thisExposureTime;
          document.getElementById("calcTimerDisplay").textContent =
            this.currentTime.toFixed(2);
        }

        reset() {
          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          this.accumulatedTime = 0;
          this.updateCalculations();
          this.currentTime = this.thisExposureTime;

          // FIX: Properly set button states on reset
          document.getElementById("timerStatus").textContent =
            "READY FOR EXPOSURE";
          document.getElementById("startExposure").textContent =
            "Start Exposure";
          document.getElementById("startExposure").disabled = false; // FIX: Enable start button
          document.getElementById("stopCalcTimer").disabled = true;
          document.getElementById("resetCalcTimer").disabled = false; // FIX: Enable reset button
          document.getElementById("repeatExposure").disabled = true; // Disable repeat until an exposure completes
          document
            .getElementById("calcTimerDisplay")
            .classList.remove("warning");

          this.updateAllDisplays();
        }

        toggle() {
          if (this.isRunning) {
            this.pause();
          } else if (this.isPaused) {
            this.resume();
          } else {
            this.start();
          }
        }
      }

      // ===== MODIFIED EnlargerHeightCalculator CLASS with integrated Contrast Control =====
      class EnlargerHeightCalculator {
        constructor(incrementalTimer) {
          this.incrementalTimer = incrementalTimer;
          this.originalTime = 10.0;
          this.originalHeight = 30.0;
          this.newHeight = 30.0;
          this.originalFStop = 5.6;
          this.newFStop = 5.6;
          this.originalPaperSize = 0.052; // Changed from 0.080
          this.newPaperSize = 0.052; // Changed from 0.080
          this.originalPaperSizeCustom = 0.052; // Changed from 0.080
          this.newPaperSizeCustom = 0.052; // Changed from 0.080

          // NEW: Contrast control variables
          this.currentPaper = "fomaspeed";
          this.currentFilter = "none";
          this.filterFactor = 1.0;

          // Paper types data from contrast calculator
          this.paperTypes = {
            fomaspeed: {
              name: "FOMASPEED Variant III / FOMABROM Variant III",
              filters: {
                "2xY": { iso: 135, factor: 1.6 },
                Y: { iso: 120, factor: 1.4 },
                none: { iso: 105, factor: 1.0 },
                M1: { iso: 90, factor: 1.4 },
                "2xM1": { iso: 80, factor: 2.1 },
                M2: { iso: 65, factor: 2.6 },
                "2xM2": { iso: 55, factor: 4.6 },
              },
            },
            fomatonemg: {
              name: "FOMATONE MG / FOMATONE MG Classic",
              filters: {
                "2xY": { iso: 120, factor: 2.0 },
                Y: { iso: 105, factor: 1.5 },
                none: { iso: 90, factor: 1.0 },
                M1: { iso: 80, factor: 1.5 },
                "2xM1": { iso: 75, factor: 1.8 },
                M2: { iso: 65, factor: 2.0 },
                "2xM2": { iso: 55, factor: 3.0 },
              },
            },
          };

          this.heightFactor = 1.0;
          this.fstopFactor = 1.0;
          this.paperSizeFactor = 1.0;
          this.combinedFactor = 1.0;
          this.newAdjustedTime = 10.0;

          this.init();
          this.updateCalculations();
          this.updateDisplay();
        }

        init() {
          // Get existing elements
          this.originalHeightCoarseSlider = document.getElementById(
            "originalHeightCoarseSlider"
          );
          this.originalHeightFineSlider = document.getElementById(
            "originalHeightFineSlider"
          );
          this.newHeightCoarseSlider = document.getElementById(
            "newHeightCoarseSlider"
          );
          this.newHeightFineSlider = document.getElementById(
            "newHeightFineSlider"
          );
          this.originalHeightValue = document.getElementById(
            "originalHeightValue"
          );
          this.newHeightValue = document.getElementById("newHeightValue");
          this.originalTimeValue = document.getElementById("originalTimeValue");
          this.heightFactorElement = document.getElementById(
            "heightFactorDisplay"
          );
          this.fstopFactorElement = document.getElementById("fstopFactor");
          this.combinedFactorElement =
            document.getElementById("combinedFactor");
          this.newAdjustedTimeElement =
            document.getElementById("newAdjustedTime");
          this.copyCurrentTimeBtn = document.getElementById("copyCurrentTime");
          this.applyHeightTimeBtn = document.getElementById("applyHeightTime");
          this.originalFStopElement = document.getElementById("originalFStop");
          this.newFStopElement = document.getElementById("newFStop");
          this.originalPaperSizeElement =
            document.getElementById("originalPaperSize");
          this.newPaperSizeElement = document.getElementById("newPaperSize");
          this.originalCustomPaperSizeDiv = document.getElementById(
            "originalCustomPaperSize"
          );
          this.newCustomPaperSizeDiv =
            document.getElementById("newCustomPaperSize");
          this.originalCustomPaperSizeValue = document.getElementById(
            "originalCustomPaperSizeValue"
          );
          this.newCustomPaperSizeValue = document.getElementById(
            "newCustomPaperSizeValue"
          );
          this.setOriginalCustomPaperBtn = document.getElementById(
            "setOriginalCustomPaper"
          );
          this.setNewCustomPaperBtn =
            document.getElementById("setNewCustomPaper");

          // NEW: Get contrast control elements
          this.btnFomaspeed = document.getElementById("btnFomaspeed");
          this.btnFomatonemg = document.getElementById("btnFomatonemg");
          this.contrastFilterSelect = document.getElementById(
            "contrastFilterSelect"
          );
          this.isoValueElement = document.getElementById("isoValue");
          this.filterFactorValueElement =
            document.getElementById("filterFactorValue");
          this.filterFactorValueDisplay = document.getElementById(
            "filterFactorValueDisplay"
          );

          // Set initial values
          this.originalCoarseHeight = 30;
          this.originalFineHeight = 0;
          this.newCoarseHeight = 30;
          this.newFineHeight = 0;

          // Add event listeners for existing controls
          this.originalHeightCoarseSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.originalHeightFineSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.newHeightCoarseSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.newHeightFineSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.originalFStopElement.addEventListener("change", () =>
            this.updateFromControls()
          );
          this.newFStopElement.addEventListener("change", () =>
            this.updateFromControls()
          );
          this.copyCurrentTimeBtn.addEventListener("click", () =>
            this.copyCurrentTime()
          );
          this.applyHeightTimeBtn.addEventListener("click", () =>
            this.applyNewTime()
          );
          this.originalPaperSizeElement.addEventListener("change", (e) => {
            const value = e.target.value;
            if (value === "custom") {
              this.originalCustomPaperSizeDiv.style.display = "block";
            } else {
              this.originalCustomPaperSizeDiv.style.display = "none";
              this.originalPaperSize = parseFloat(value);
              this.updateCalculations();
              this.updateDisplay();
            }
          });

          // New paper size change handler
          this.newPaperSizeElement.addEventListener("change", (e) => {
            const value = e.target.value;
            if (value === "custom") {
              this.newCustomPaperSizeDiv.style.display = "block";
            } else {
              this.newCustomPaperSizeDiv.style.display = "none";
              this.newPaperSize = parseFloat(value);
              this.updateCalculations();
              this.updateDisplay();
            }
          });
          this.setNewCustomPaperBtn.addEventListener("click", () => {
            const customValue = parseFloat(this.newCustomPaperSizeValue.value);
            if (customValue && customValue > 0) {
              this.newPaperSizeCustom = customValue;
              if (this.newPaperSizeElement.value === "custom") {
                this.newPaperSize = customValue;
                this.updateCalculations();
                this.updateDisplay();
                // Show visual feedback
                this.setNewCustomPaperBtn.textContent = "âœ“ Set";
                this.setNewCustomPaperBtn.classList.add("active");
                setTimeout(() => {
                  this.setNewCustomPaperBtn.textContent = "Set";
                  this.setNewCustomPaperBtn.classList.remove("active");
                }, 1000);
              }
            }
          });

          // Set original custom paper size button
          this.setOriginalCustomPaperBtn.addEventListener("click", () => {
            const customValue = parseFloat(
              this.originalCustomPaperSizeValue.value
            );
            if (customValue && customValue > 0) {
              this.originalPaperSizeCustom = customValue;
              if (this.originalPaperSizeElement.value === "custom") {
                this.originalPaperSize = customValue;
                this.updateCalculations();
                this.updateDisplay();
                // Show visual feedback
                this.setOriginalCustomPaperBtn.textContent = "âœ“ Set";
                this.setOriginalCustomPaperBtn.classList.add("active");
                setTimeout(() => {
                  this.setOriginalCustomPaperBtn.textContent = "Set";
                  this.setOriginalCustomPaperBtn.classList.remove("active");
                }, 1000);
              }
            }
          });

          // NEW: Add event listeners for contrast controls
          this.btnFomaspeed.addEventListener("click", () =>
            this.selectPaper("fomaspeed")
          );
          this.btnFomatonemg.addEventListener("click", () =>
            this.selectPaper("fomatonemg")
          );
          this.contrastFilterSelect.addEventListener("change", () => {
            this.currentFilter = this.contrastFilterSelect.value;
            this.updateCalculations();
            this.updateDisplay();
          });

          this.applyHeightTimeBtn.addEventListener("click", initAudioContext);
        }

        // NEW: Paper selection method
        selectPaper(paperType) {
          this.currentPaper = paperType;

          // Update button states
          this.btnFomaspeed.classList.remove("active");
          this.btnFomatonemg.classList.remove("active");
          if (paperType === "fomaspeed") {
            this.btnFomaspeed.classList.add("active");
          } else {
            this.btnFomatonemg.classList.add("active");
          }

          // Update calculations
          this.updateCalculations();
          this.updateDisplay();
        }

        // Helper method to update custom paper size displays
        updateCustomPaperSizeDisplays() {
          // Update custom input fields with current values
          this.originalCustomPaperSizeValue.value =
            this.originalPaperSizeCustom.toFixed(3);
          this.newCustomPaperSizeValue.value =
            this.newPaperSizeCustom.toFixed(3);

          // Show/hide custom inputs based on selection
          if (this.originalPaperSizeElement.value === "custom") {
            this.originalCustomPaperSizeDiv.style.display = "block";
          } else {
            this.originalCustomPaperSizeDiv.style.display = "none";
          }

          if (this.newPaperSizeElement.value === "custom") {
            this.newCustomPaperSizeDiv.style.display = "block";
          } else {
            this.newCustomPaperSizeDiv.style.display = "none";
          }
        }

        copyCurrentTime() {
          this.originalTime = this.incrementalTimer.currentTotalTime;

          // Reset fine adjustments to zero
          this.originalFineHeight = 0;
          this.newFineHeight = 0;

          // Update sliders
          this.originalHeightFineSlider.value = 0;
          this.newHeightFineSlider.value = 0;

          this.updateCalculations();
          this.updateDisplay();
          playBeep(600, 0.3, 0.2);
        }

        updateFromControls() {
          // Get coarse and fine values
          this.originalCoarseHeight = parseInt(
            this.originalHeightCoarseSlider.value
          );
          this.originalFineHeight =
            parseInt(this.originalHeightFineSlider.value) / 10; // Convert to decimal
          this.newCoarseHeight = parseInt(this.newHeightCoarseSlider.value);
          this.newFineHeight = parseInt(this.newHeightFineSlider.value) / 10;

          // Calculate total heights
          this.originalHeight =
            this.originalCoarseHeight + this.originalFineHeight;
          this.newHeight = this.newCoarseHeight + this.newFineHeight;

          // Get f-stop values
          this.originalFStop = parseFloat(this.originalFStopElement.value);
          this.newFStop = parseFloat(this.newFStopElement.value);

          // Get paper size values
          const originalPaperSizeSelect = this.originalPaperSizeElement.value;
          const newPaperSizeSelect = this.newPaperSizeElement.value;

          // Handle original paper size
          if (originalPaperSizeSelect === "custom") {
            // Show custom input and set current value
            this.originalCustomPaperSizeDiv.style.display = "block";
            this.originalCustomPaperSizeValue.value =
              this.originalPaperSizeCustom.toFixed(3);
            this.originalPaperSize = this.originalPaperSizeCustom;
          } else {
            // Hide custom input and use preset value
            this.originalCustomPaperSizeDiv.style.display = "none";
            this.originalPaperSize = parseFloat(originalPaperSizeSelect);
          }

          // Handle new paper size
          if (newPaperSizeSelect === "custom") {
            // Show custom input and set current value
            this.newCustomPaperSizeDiv.style.display = "block";
            this.newCustomPaperSizeValue.value =
              this.newPaperSizeCustom.toFixed(3);
            this.newPaperSize = this.newPaperSizeCustom;
          } else {
            // Hide custom input and use preset value
            this.newCustomPaperSizeDiv.style.display = "none";
            this.newPaperSize = parseFloat(newPaperSizeSelect);
          }

          this.updateCalculations();
          this.updateDisplay();
          this.updateCustomPaperSizeDisplays();
        }

        updateCalculations() {
          // Height factor: (newHeight Ã· originalHeight)Â²
          if (this.originalHeight > 0) {
            this.heightFactor = Math.pow(
              this.newHeight / this.originalHeight,
              2
            );
          } else {
            this.heightFactor = 1.0;
          }

          // F-stop factor: (New F-Stop Ã· Original F-Stop)Â²
          if (this.newFStop > 0) {
            this.fstopFactor = Math.pow(this.newFStop / this.originalFStop, 2);
          } else {
            this.fstopFactor = 1.0;
          }

          // Paper size factor: New Paper Area Ã· Original Paper Area
          if (this.originalPaperSize > 0) {
            // CORRECT: (âˆšNew Paper Area Ã· âˆšOriginal Paper Area)Â² = New Paper Area Ã· Original Paper Area
            // This is actually mathematically the same as newPaperSize / originalPaperSize
            // The issue was with the VALUES, not the formula!
            this.paperSizeFactor = this.newPaperSize / this.originalPaperSize;
          } else {
            this.paperSizeFactor = 1.0;
          }

          // NEW: Filter factor from contrast control
          const paper = this.paperTypes[this.currentPaper];
          const filter = paper.filters[this.currentFilter];
          if (filter) {
            this.filterFactor = filter.factor;
          } else {
            this.filterFactor = 1.0;
          }

          // Combined factor includes ALL factors
          this.combinedFactor =
            this.heightFactor *
            this.fstopFactor *
            this.paperSizeFactor *
            this.filterFactor;
          this.newAdjustedTime = this.originalTime * this.combinedFactor;
        }

        updateDisplay() {
          // Update height displays with one decimal
          this.originalHeightValue.textContent = `${this.originalHeight.toFixed(
            1
          )}`;
          this.newHeightValue.textContent = `${this.newHeight.toFixed(1)}`;
          this.originalTimeValue.textContent = this.originalTime.toFixed(2);
          this.heightFactorElement.textContent = `${this.heightFactor.toFixed(
            2
          )}x`;
          this.fstopFactorElement.textContent = `${this.fstopFactor.toFixed(
            2
          )}x`;
          document.getElementById(
            "paperSizeFactor"
          ).textContent = `${this.paperSizeFactor.toFixed(2)}x`;
          this.filterFactorValueDisplay.textContent = `${this.filterFactor.toFixed(
            2
          )}x`;
          this.combinedFactorElement.textContent = `${this.combinedFactor.toFixed(
            2
          )}x`;
          this.newAdjustedTimeElement.textContent =
            this.newAdjustedTime.toFixed(2);

          // NEW: Update contrast control displays
          const paper = this.paperTypes[this.currentPaper];
          const filter = paper.filters[this.currentFilter];
          if (filter) {
            this.isoValueElement.textContent = filter.iso;
            this.filterFactorValueElement.textContent = `${filter.factor.toFixed(
              1
            )}Ã—`;
          }

          // Update button text to show calculation
          const timeDiff = ((this.combinedFactor - 1) * 100).toFixed(0);
          const direction = this.combinedFactor > 1 ? "increase" : "decrease";

          if (this.combinedFactor !== 1.0) {
            this.applyHeightTimeBtn.textContent = `Apply ${this.newAdjustedTime.toFixed(
              1
            )}s (${direction} ${Math.abs(timeDiff)}%)`;
          } else {
            this.applyHeightTimeBtn.textContent =
              "Apply Adjusted Time as Base Time";
          }
        }

        applyNewTime() {
          const newBaseTime = this.newAdjustedTime;
          const baseTimeSlider = document.getElementById("baseTimeSlider");
          const clampedTime = Math.max(1, Math.min(50, newBaseTime));
          baseTimeSlider.value = clampedTime.toFixed(1);

          this.incrementalTimer.updateFromSliders();
          playBeep(800, 0.1, 0.3);

          const btn = this.applyHeightTimeBtn;
          const originalText = btn.textContent;
          btn.textContent = "Applied!";
          btn.classList.add("active");

          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove("active");
          }, 1000);
        }
      }

      // F-Stop Test Strip Generator Class with both Cumulative and Incremental methods and countdown AND AUTO ADVANCE
      class FStopTestStripGenerator {
        constructor() {
          this.baseTime = 10.0;
          this.stepIncrement = 1; // 1 = one fractional step (denominator controlled by stopDenominator)
          // Denominator applied in calculations; default to 3 (1/3 stop)
          window.stopDenominator = window.stopDenominator || 3;
          this.numSteps = 6;
          this.method = "cumulative"; // 'cumulative' or 'incremental'
          this.autoAdvance = false; // NEW: Auto advance mode
          this.autoAdvanceDelay = 1000; // Delay between steps in ms

          if (settingsManager) {
            this.autoAdvance = settingsManager.settings.autoAdvance || false;
            this.autoAdvanceDelay =
              (settingsManager.settings.autoAdvanceDelay || 1) * 1000; // Convert to ms
          } else {
            this.autoAdvance = false;
            this.autoAdvanceDelay = 1000; // Default 1 second
          }

          this.currentStep = 0;
          this.steps = [];
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.interval = null;
          this.lastBeepSecond = null;
          this.currentStepTime = 0;

          this.init();
          this.generateSteps();
          this.updateDisplay();
          this.updateInstructions();

          // Initialize countdown cleanup properties
          this.countdownCleanup = null;
          this.countdownCleanupTimeout = null;
        }

        init() {
          // Get elements
          this.testBaseSlider = document.getElementById("testBaseSlider");
          this.testIncrementSlider = document.getElementById(
            "testIncrementSlider"
          );
          this.testStepsSlider = document.getElementById("testStepsSlider");
          this.testBaseValue = document.getElementById("testBaseValue");
          this.testIncrementValue =
            document.getElementById("testIncrementValue");
          this.testStepsValue = document.getElementById("testStepsValue");
          this.testSequenceInfo = document.getElementById("testSequenceInfo");
          this.testTimeRange = document.getElementById("testTimeRange");
          this.testStripPreview = document.getElementById("testStripPreview");

          // NEW: Auto advance toggle elements
          this.autoAdvanceToggle = document.getElementById("autoAdvanceToggle");
          this.autoAdvanceValue = document.getElementById("autoAdvanceValue");
          this.autoAdvanceDescription = document.getElementById(
            "autoAdvanceDescription"
          );

          // Timer elements
          this.testTimerStatus = document.getElementById("testTimerStatus");
          this.testTimerDisplay = document.getElementById("testTimerDisplay");
          this.currentStepDisplay =
            document.getElementById("currentStepDisplay");
          this.currentTimeDisplay =
            document.getElementById("currentTimeDisplay");
          this.currentStopDisplay =
            document.getElementById("currentStopDisplay");
          this.stepSizeDisplay = document.getElementById("stepSizeDisplay");
          this.timeMultiplierDisplay = document.getElementById(
            "timeMultiplierDisplay"
          );
          this.totalTestTimeDisplay = document.getElementById(
            "totalTestTimeDisplay"
          );
          this.testProgressBar = document.getElementById("testProgressBar");
          this.progressStart = document.getElementById("progressStart");
          this.progressMiddle = document.getElementById("progressMiddle");
          this.progressEnd = document.getElementById("progressEnd");

          // Control buttons
          this.startTestStripBtn = document.getElementById("startTestStrip");
          this.stopTestTimerBtn = document.getElementById("stopTestTimer");
          this.resetTestTimerBtn = document.getElementById("resetTestTimer");

          // Sound controls
          this.testWarningBeep = document.getElementById("testWarningBeep");
          this.testStepBeep = document.getElementById("testStepBeep");
          this.testEndBeep = document.getElementById("testEndBeep");

          // Preview controls
          this.previewMode = document.getElementById("previewMode");

          // Add event listeners
          this.testBaseSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.testIncrementSlider.addEventListener("input", () =>
            this.updateFromControls()
          );
          this.testStepsSlider.addEventListener("input", () =>
            this.updateFromControls()
          );

          // NEW: Auto advance toggle event
          this.autoAdvanceToggle.addEventListener("change", () => {
            this.setAutoAdvance(this.autoAdvanceToggle.checked);
          });

          // In the init() method of FStopTestStripGenerator (around line 2300), update the startTestStripBtn event listener:
          this.startTestStripBtn.addEventListener("click", async () => {
            await this.toggle();
          });
          this.stopTestTimerBtn.addEventListener("click", () =>
            this.stopCurrentTest()
          );
          this.resetTestTimerBtn.addEventListener("click", () => this.reset());

          this.previewMode.addEventListener("change", () =>
            this.updatePreview()
          );

          // Method selector event listeners
          document.querySelectorAll(".method-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const method = e.target.getAttribute("data-method");
              this.setMethod(method);
            });
          });

          // Preset buttons
          document.querySelectorAll(".preset-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              const preset = e.target.getAttribute("data-preset");
              this.applyPreset(preset);
            });
          });

          // Audio context initialization
          this.startTestStripBtn.addEventListener("click", initAudioContext);
        }

        // NEW: Set auto advance mode
        setAutoAdvance(enabled) {
          this.autoAdvance = enabled;
          this.updateAutoAdvanceDisplay();
          this.updateInstructions();

          // If test is running and auto advance is enabled, check if we should proceed
          if (this.isRunning && !this.isPaused && this.autoAdvance) {
            // If we're currently paused between steps, start next step
            if (
              this.currentStepTime <= 0 &&
              this.currentStep < this.steps.length - 1
            ) {
              this.nextStep();
            }
          }
        }

        setAutoAdvanceDelay(delayMs) {
          this.autoAdvanceDelay = delayMs;
          this.updateAutoAdvanceDisplay();
          this.updateInstructions();
        }

        // NEW: Update auto advance display
        updateAutoAdvanceDisplay() {
          if (this.autoAdvanceValue) {
            this.autoAdvanceValue.textContent = this.autoAdvance ? "ON" : "OFF";
          }
          if (this.autoAdvanceDescription) {
            const delaySec = this.autoAdvanceDelay / 1000;
            this.autoAdvanceDescription.textContent = this.autoAdvance
              ? `Automatically advance to next step (${delaySec}s delay)`
              : "Pause after each step";
          }
          if (this.autoAdvanceToggle) {
            this.autoAdvanceToggle.checked = this.autoAdvance;
          }
        }

        // NEW: Update instructions with auto advance info
        updateInstructions() {
          const cumulativeText = document.getElementById(
            "cumulativeAdvanceText"
          );
          const incrementalText = document.getElementById(
            "incrementalAdvanceText"
          );
          const statusText = document.getElementById("autoAdvanceStatus");

          const delaySec = this.autoAdvanceDelay / 1000;

          if (this.autoAdvance) {
            cumulativeText.textContent = `Auto-advance: ON - Next step starts in ${delaySec}s`;
            incrementalText.textContent = `Auto-advance: ON - Slide mask, next step in ${delaySec}s`;
            statusText.textContent = `Current: Auto Advance (${delaySec}s delay) - press 'A' to toggle`;
          } else {
            cumulativeText.textContent =
              "Auto-advance: OFF - Press Next Step between exposures";
            incrementalText.textContent =
              "Auto-advance: OFF - Press Next Step after sliding mask";
            statusText.textContent =
              'Current: Manual Advance - press "A" to toggle or use Next Step button';
          }

          // Update status text color based on theme
          if (document.body.classList.contains("light-scheme")) {
            statusText.style.color = this.autoAdvance ? "#0066cc" : "#666";
          } else if (document.body.classList.contains("day-scheme")) {
            statusText.style.color = this.autoAdvance ? "#ffcc00" : "#ccc";
          } else {
            statusText.style.color = this.autoAdvance ? "#f00" : "#900";
          }
        }

        setMethod(method) {
          if (this.method === method) return;

          this.method = method;

          // Update UI
          document.querySelectorAll(".method-btn").forEach((btn) => {
            btn.classList.remove("active");
            if (btn.getAttribute("data-method") === method) {
              btn.classList.add("active");
            }
          });

          document.getElementById("testMethodValue").textContent =
            method === "cumulative" ? "Cumulative" : "Incremental";

          // Show appropriate instructions
          if (method === "cumulative") {
            document.querySelector(".cumulative-instructions").style.display =
              "block";
            document.querySelector(".incremental-instructions").style.display =
              "none";
          } else {
            document.querySelector(".cumulative-instructions").style.display =
              "none";
            document.querySelector(".incremental-instructions").style.display =
              "block";
          }

          // Regenerate steps with new method
          this.generateSteps();
          this.updateDisplay();
          this.updateInstructions();

          // If running, stop and reset
          if (this.isRunning || this.isPaused) {
            this.stopCurrentTest();
            this.reset();
          }
        }

        updateFromControls() {
          this.baseTime = parseFloat(this.testBaseSlider.value);
          this.stepIncrement = parseInt(this.testIncrementSlider.value);
          this.numSteps = parseInt(this.testStepsSlider.value);

          this.generateSteps();
          this.updateDisplay();
        }

        generateSteps() {
          this.steps = [];

          if (this.method === "cumulative") {
            // Existing cumulative method
            let totalTime = 0;
            for (let i = 0; i < this.numSteps; i++) {
              const denom = window.stopDenominator || 3;
              const stopValue = (i * this.stepIncrement) / denom; // Convert to stop value
              const time = this.baseTime * Math.pow(2, stopValue);
              totalTime += time;

              this.steps.push({
                step: i + 1,
                stop: stopValue,
                time: time,
                cumulativeTime: totalTime,
                incrementalTime: time, // Same as time for cumulative
                totalExposure: time, // Total exposure for this step
              });
            }
          } else {
            // New incremental method
            let previousTotalTime = this.baseTime;

            for (let i = 0; i < this.numSteps; i++) {
              const denom = window.stopDenominator || 3;
              const stopValue = (i * this.stepIncrement) / denom;
              const totalExposure = this.baseTime * Math.pow(2, stopValue);

              // For first step: incremental time = base time
              // For subsequent steps: incremental time = difference between current and previous total
              let incrementalTime;
              if (i === 0) {
                incrementalTime = this.baseTime;
              } else {
                const previousStop = ((i - 1) * this.stepIncrement) / denom;
                const previousTotal = this.baseTime * Math.pow(2, previousStop);
                incrementalTime = totalExposure - previousTotal;
              }

              this.steps.push({
                step: i + 1,
                stop: stopValue,
                time: incrementalTime, // Time to expose THIS step
                cumulativeTime: 0, // Not used in incremental method
                incrementalTime: incrementalTime,
                totalExposure: totalExposure, // Total exposure on paper for this strip
              });

              previousTotalTime = totalExposure;
            }
          }
        }

        getIncrementLabel(increment) {
          const denom = window.stopDenominator || 3;
          const stopValue = increment / denom;
          const whole = Math.floor(stopValue);
          const fraction = stopValue - whole;

          // Use tolerance for floating point comparison
          const tolerance = 0.0001;

          if (Math.abs(fraction) < tolerance) return `${whole}`;

          if (denom === 2) {
            if (Math.abs(fraction - 0.5) < tolerance) return `Â½`;
          } else if (denom === 3) {
            if (Math.abs(fraction - 1 / 3) < tolerance) return `â…“`;
            if (Math.abs(fraction - 2 / 3) < tolerance) return `â…”`;
          } else if (denom === 4) {
            if (Math.abs(fraction - 0.25) < tolerance) return `Â¹â„â‚„`;
            if (Math.abs(fraction - 0.5) < tolerance) return `Â²â„â‚„`;
            if (Math.abs(fraction - 0.75) < tolerance) return `Â³â„â‚„`;
          } else if (denom === 6) {
            if (Math.abs(fraction - 1 / 6) < tolerance) return `Â¹â„â‚†`;
            if (Math.abs(fraction - 2 / 6) < tolerance) return `Â²â„â‚†`;
            if (Math.abs(fraction - 3 / 6) < tolerance) return `Â³â„â‚†`;
            if (Math.abs(fraction - 4 / 6) < tolerance) return `â´â„â‚†`;
            if (Math.abs(fraction - 5 / 6) < tolerance) return `âµâ„â‚†`;
          } else if (denom === 6) {
            if (Math.abs(fraction - 1 / 6) < tolerance) return `Â¹â„â‚†`;
            if (Math.abs(fraction - 2 / 6) < tolerance) return `Â²â„â‚†`;
            if (Math.abs(fraction - 3 / 6) < tolerance) return `Â³â„â‚†`;
            if (Math.abs(fraction - 4 / 6) < tolerance) return `â´â„â‚†`;
            if (Math.abs(fraction - 5 / 6) < tolerance) return `âµâ„â‚†`;
          }

          // Fallback: show as decimal
          return `${stopValue.toFixed(1)}`;
        }

        formatStop(stopValue) {
          const denom = window.stopDenominator || 3;
          const whole = Math.floor(stopValue);
          const fraction = stopValue - whole;
          const tolerance = 0.0001;

          if (Math.abs(fraction) < tolerance) return `${whole}.0`;
          if (denom === 2) {
            if (Math.abs(fraction - 0.5) < tolerance) return `${whole}Â½`;
          } else if (denom === 3) {
            if (Math.abs(fraction - 1 / 3) < tolerance) return `${whole}â…“`;
            if (Math.abs(fraction - 2 / 3) < tolerance) return `${whole}â…”`;
          } else if (denom === 4) {
            if (Math.abs(fraction - 0.25) < tolerance) return `${whole}Â¹â„â‚„`;
            if (Math.abs(fraction - 0.5) < tolerance) return `${whole}Â²â„â‚„`;
            if (Math.abs(fraction - 0.75) < tolerance) return `${whole}Â³â„â‚„`;
          }

          return `${stopValue.toFixed(1)}`;
        }

        updateDisplay() {
          // Update control values
          this.testBaseValue.textContent = `${this.baseTime.toFixed(1)}s`;
          this.testIncrementValue.textContent = `${this.getIncrementLabel(
            this.stepIncrement
          )} stop`;
          this.testStepsValue.textContent = this.numSteps;

          // Update sequence info with method
          const methodText =
            this.method === "cumulative" ? "Cumulative" : "Incremental";
          this.testSequenceInfo.textContent = `${
            this.numSteps
          } steps Ã— ${this.getIncrementLabel(
            this.stepIncrement
          )} stop (${methodText})`;

          // Update time range based on method
          let minTime, maxTime;
          if (this.method === "cumulative") {
            minTime = this.baseTime;
            maxTime = this.steps[this.steps.length - 1]?.time || this.baseTime;
            this.testTimeRange.textContent = `${minTime.toFixed(
              2
            )}s to ${maxTime.toFixed(2)}s`;

            // Update progress labels
            this.progressStart.textContent = `${minTime.toFixed(1)}s`;
            this.progressMiddle.textContent = `${(
              (minTime + maxTime) /
              2
            ).toFixed(1)}s`;
            this.progressEnd.textContent = `${maxTime.toFixed(1)}s`;
          } else {
            // For incremental method, show incremental times range
            minTime = this.steps[0]?.incrementalTime || this.baseTime;
            maxTime =
              this.steps[this.steps.length - 1]?.incrementalTime ||
              this.baseTime;
            this.testTimeRange.textContent = `Step times: ${minTime.toFixed(
              2
            )}s to ${maxTime.toFixed(2)}s`;

            // Show total exposure range for incremental method
            const minTotal = this.baseTime;
            const maxTotal =
              this.steps[this.steps.length - 1]?.totalExposure || this.baseTime;
            this.progressStart.textContent = `${minTotal.toFixed(1)}s`;
            this.progressMiddle.textContent = `${(
              (minTotal + maxTotal) /
              2
            ).toFixed(1)}s`;
            this.progressEnd.textContent = `${maxTotal.toFixed(1)}s`;
          }

          // Update preview
          this.updatePreview();

          // Update info displays
          if (this.steps.length > 0) {
            const totalTime = this.steps.reduce(
              (sum, step) => sum + step.time,
              0
            );
            this.totalTestTimeDisplay.textContent = `${totalTime.toFixed(1)}s`;

            // Update step size display with method-specific info
            if (this.method === "incremental") {
              const denom = window.stopDenominator || 3;
              this.stepSizeDisplay.textContent =
                this.method === "incremental"
                  ? `+${(this.stepIncrement / denom).toFixed(1)} stops`
                  : `${(this.stepIncrement / denom).toFixed(1)} stops`;
            }
          }
        }

        updatePreview() {
          this.testStripPreview.innerHTML = "";
          const showTimes = this.previewMode.checked;

          this.steps.forEach((step, index) => {
            const stepEl = document.createElement("div");
            stepEl.className = "test-step";
            stepEl.dataset.step = step.step;

            // Calculate color intensity based on method
            if (this.method === "cumulative") {
              // Color based on total exposure (cumulative method)
              const maxTime = this.steps[this.steps.length - 1].time;
              const intensity = Math.min(
                100 + (step.time / maxTime) * 150,
                250
              );
              stepEl.style.backgroundColor = `rgb(${intensity}, 0, 0)`;
            } else {
              // Color based on total exposure on paper (incremental method)
              const maxTotal = this.steps[this.steps.length - 1].totalExposure;
              const intensity = Math.min(
                100 + (step.totalExposure / maxTotal) * 150,
                250
              );
              stepEl.style.backgroundColor = `rgb(${intensity}, 0, 0)`;
            }

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              const blueIntensity = Math.min(
                150 +
                  (step.totalExposure /
                    this.steps[this.steps.length - 1].totalExposure) *
                    100,
                250
              );
              stepEl.style.backgroundColor = `rgb(${230 - blueIntensity / 3}, ${
                230 - blueIntensity / 3
              }, ${blueIntensity})`;
            } else if (document.body.classList.contains("day-scheme")) {
              const yellowIntensity = Math.min(
                150 +
                  (step.totalExposure /
                    this.steps[this.steps.length - 1].totalExposure) *
                    100,
                250
              );
              stepEl.style.backgroundColor = `rgb(${yellowIntensity}, ${yellowIntensity}, ${100})`;
            }

            if (
              index === this.currentStep &&
              (this.isRunning || this.isPaused)
            ) {
              stepEl.classList.add("active");
            }

            if (showTimes) {
              if (this.method === "cumulative") {
                stepEl.innerHTML = `
                            <div class="step-time">${step.time.toFixed(
                              1
                            )}s</div>
                            <div class="step-stop">${this.formatStop(
                              step.stop
                            )}</div>
                        `;
              } else {
                stepEl.innerHTML = `
                            <div class="step-time">${step.time.toFixed(
                              1
                            )}s</div>
                            <div class="step-stop">+${this.getIncrementLabel(
                              this.stepIncrement
                            )}</div>
                            <div style="font-size: 0.4rem; color: #600; margin-top: 1px;">
                                Total: ${step.totalExposure.toFixed(1)}s
                            </div>
                        `;
              }
            } else {
              stepEl.innerHTML = `
                        <div class="step-time">${step.step}</div>
                        <div class="step-stop">${this.getIncrementLabel(
                          this.stepIncrement
                        )}</div>
                    `;
            }

            this.testStripPreview.appendChild(stepEl);
          });

          // Update progress bar
          const progressFill = document.getElementById("progressFill");
          // Show progress including the current step being executed (currentStep is 0-indexed)
          const progressPercent =
            ((this.currentStep + 1) / this.steps.length) * 100;
          if (progressFill) {
            progressFill.style.width = `${progressPercent}%`;
          }
        }

        // In the start() method (around line 2400), update to async:
        async start() {
          if (this.isRunning || this.steps.length === 0) return;

          // Disable buttons during countdown
          this.startTestStripBtn.disabled = true;
          this.stopTestTimerBtn.disabled = false; // Keep Stop enabled
          this.resetTestTimerBtn.disabled = true;

          // Start countdown
          const display = this.testTimerDisplay;
          const originalText = display.textContent;
          this.testTimerStatus.textContent = "COUNTDOWN STARTING...";

          await new Promise((resolve) => {
            window.countdownManager.startCountdown(display, () => {
              resolve();
            });
          });

          // Restore display and enable buttons
          display.textContent = originalText;
          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";

          // Continue with original start logic
          this.isRunning = true;
          this.isPaused = false;
          this.currentStep = 0;
          await this.startStep(); // Add await here

          this.startTestStripBtn.textContent = "Pause";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = false;
          this.resetTestTimerBtn.disabled = true;

          // Play start beep
          if (this.testStepBeep.checked) {
            playBeep(600, 0.1, 0.3);
          }
        }

        // Add to FStopTestStripGenerator class (around line 2500)
        async triggerRelayForStep(stepTime) {
          if (
            window.relayManager &&
            window.relayManager.autoTrigger &&
            stepTime > 0
          ) {
            try {
              await window.relayManager.triggerTimerRelay(stepTime);
            } catch (error) {
              console.error("Failed to trigger relay for step:", error);
            }
          }
        }

        // REPLACE the entire startStep() method (around line 2600-2800) with:
        async startStep() {
          if (this.currentStep >= this.steps.length) {
            this.complete();
            return;
          }

          const step = this.steps[this.currentStep];
          this.currentStepTime = step.time;
          this.lastBeepSecond = null;

          // Always show running status while the timer counts down
          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";

          this.currentStepDisplay.textContent = `${this.currentStep + 1}/${
            this.steps.length
          }`;

          if (this.method === "cumulative") {
            this.currentTimeDisplay.textContent = `${step.time.toFixed(2)}s`;
            this.currentStopDisplay.textContent = `${this.formatStop(
              step.stop
            )}`;
            this.timeMultiplierDisplay.textContent = `${Math.pow(
              2,
              step.stop
            ).toFixed(2)}Ã—`;
          } else {
            this.currentTimeDisplay.textContent = `${step.time.toFixed(2)}s`;
            this.currentStopDisplay.textContent = `+${this.getIncrementLabel(
              this.stepIncrement
            )}`;

            const totalExposure = step.totalExposure;
            this.timeMultiplierDisplay.textContent = `${totalExposure.toFixed(
              1
            )}s total`;
          }

          this.testTimerDisplay.textContent = step.time.toFixed(2);

          this.updatePreview();

          // TRIGGER RELAY FOR THIS STEP - AWAIT HERE
          if (window.relayManager && window.relayManager.autoTrigger) {
            try {
              await window.relayManager.triggerTimerRelay(step.time);
            } catch (error) {
              console.error("Failed to trigger relay:", error);
            }
          }

          // Start the interval timer
          this.startInterval();
        }

        startInterval() {
          this.interval = setInterval(() => {
            this.currentStepTime -= 0.1;

            if (this.currentStepTime <= 0) {
              this.currentStepTime = 0;
              this.stepComplete();
            } else {
              this.testTimerDisplay.textContent =
                this.currentStepTime.toFixed(2);

              // 3-second warning beep
              if (this.currentStepTime <= 3 && this.testWarningBeep.checked) {
                const currentSecond = Math.ceil(this.currentStepTime);

                if (
                  currentSecond !== this.lastBeepSecond &&
                  currentSecond <= 3 &&
                  currentSecond > 0
                ) {
                  this.lastBeepSecond = currentSecond;
                  playBeep(400, 0.1, 0.3);
                  this.testTimerDisplay.classList.add("warning");

                  setTimeout(() => {
                    this.testTimerDisplay.classList.remove("warning");
                  }, 300);
                }
              }
            }
          }, 100);
        }

        stepComplete() {
          clearInterval(this.interval);

          // Play step complete beep
          if (this.testStepBeep.checked) {
            playBeep(800, 0.1, 0.3);
          }

          // Update preview to show completed step
          this.updatePreview();

          // Cancel any ongoing countdown (safety check)
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Determine next action based on auto advance setting
          if (this.autoAdvance && !this.isPaused) {
            // Auto advance: move to next step after configured delay
            this.currentStep++;

            if (this.currentStep < this.steps.length) {
              // Update status to show auto advance countdown
              const delaySec = this.autoAdvanceDelay / 1000;
              this.testTimerStatus.textContent = `Auto advancing in ${delaySec}s...`;

              // Start next step after configured delay
              setTimeout(() => {
                if (this.isRunning && !this.isPaused) {
                  this.startStep();
                }
              }, this.autoAdvanceDelay); // Use configured delay
            } else {
              this.complete();
            }
          } else {
            // Manual advance mode
            // Check if this was the last step
            if (this.currentStep >= this.steps.length - 1) {
              // Last step completed - finish immediately
              this.complete();
            } else {
              // More steps remain - pause and wait for user input
              this.isRunning = false; // Pause the timer
              this.isWaitingForNextStep = true; // Track waiting state
              this.testTimerStatus.textContent =
                "STEP COMPLETE - PRESS NEXT STEP";

              // Update Start button to act as Next Step and keep Stop enabled
              this.startTestStripBtn.textContent = "Next Step";
              this.stopTestTimerBtn.disabled = false;

              // Update step number to show current (completed) step
              this.currentStepDisplay.textContent = `${this.currentStep + 1}/${
                this.steps.length
              } (Completed)`;

              // Show instruction based on method
              if (this.method === "incremental") {
                this.testTimerStatus.textContent =
                  "SLIDE MASK â†’ THEN PRESS NEXT STEP";
              }
            }
          }
        }

        pause() {
          if (!this.isRunning) return;

          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = true;

          this.testTimerStatus.textContent = "TEST STRIP PAUSED";
          this.startTestStripBtn.textContent = "Resume";
          this.testTimerDisplay.classList.remove("warning");

          playBeep(400, 0.1, 0.2);
        }

        resume() {
          if (!this.isPaused) return;

          this.isRunning = true;
          this.isPaused = false;

          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";
          this.startTestStripBtn.textContent = "Pause";

          // RESUME from current time instead of restarting the step
          this.startInterval();
        }

        stopCurrentTest() {
          // Allow stopping at any time - no return check

          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.currentStep = 0;
          this.currentStepTime = 0;
          this.lastBeepSecond = null;

          this.testTimerStatus.textContent = "READY FOR TEST STRIP";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;
          this.testTimerDisplay.textContent = "0.00";
          this.testTimerDisplay.classList.remove("warning");

          // Reset step display
          if (this.steps.length > 0) {
            const firstStep = this.steps[0];
            this.currentStepDisplay.textContent = `1/${this.steps.length}`;
            this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
              2
            )}s`;
            this.currentStopDisplay.textContent =
              this.method === "cumulative"
                ? `${this.formatStop(firstStep.stop)}`
                : `+${this.getIncrementLabel(this.stepIncrement)}`;
            this.timeMultiplierDisplay.textContent =
              this.method === "cumulative"
                ? `${Math.pow(2, firstStep.stop).toFixed(2)}Ã—`
                : `${firstStep.totalExposure.toFixed(1)}s total`;
            this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
          }

          this.updatePreview();

          playBeep(600, 0.1, 0.2);
        }

        nextStep() {
          if (
            this.isPaused ||
            (!this.isRunning && this.currentStep < this.steps.length)
          ) {
            // If auto advance is OFF, do countdown before next step
            if (!this.autoAdvance) {
              this.startCountdownForNextStep();
            } else {
              // If auto advance is ON, proceed immediately
              this.proceedToNextStep();
            }
          }
        }

        // NEW METHOD: Start countdown for next step
        startCountdownForNextStep() {
          // Prevent multiple countdowns
          if (window.countdownManager && window.countdownManager.isActive) {
            console.warn("Countdown already active");
            return;
          }
          // Disable buttons during countdown, but keep Stop enabled
          this.startTestStripBtn.disabled = true;
          this.stopTestTimerBtn.disabled = false; // Keep Stop enabled
          this.resetTestTimerBtn.disabled = true;

          // Save original display values AND style properties
          const originalDisplay = this.testTimerDisplay.textContent;
          const originalStatus = this.testTimerStatus.textContent;
          const originalTimerBgColor =
            this.testTimerDisplay.style.backgroundColor;
          const originalTimerColor = this.testTimerDisplay.style.color;
          const originalTimerFontWeight =
            this.testTimerDisplay.style.fontWeight;

          // Store references for cleanup
          this.countdownCleanup = {
            display: originalDisplay,
            status: originalStatus,
            timerBgColor: originalTimerBgColor,
            timerColor: originalTimerColor,
            timerFontWeight: originalTimerFontWeight,
          };

          // Start countdown
          this.testTimerStatus.textContent = "COUNTDOWN FOR NEXT STEP...";

          // Clear any existing cleanup reference first
          if (this.countdownCleanupTimeout) {
            clearTimeout(this.countdownCleanupTimeout);
          }

          try {
            window.countdownManager.startCountdown(
              this.testTimerDisplay,
              () => {
                // Countdown complete callback
                this.restoreDisplayAfterCountdown();
                // Proceed to the actual next step
                this.proceedToNextStep();
              }
            );
          } catch (error) {
            console.error("Countdown failed:", error);
            // Fallback: proceed without countdown
            this.restoreDisplayAfterCountdown();
            this.proceedToNextStep();
          }
        }

        // NEW: Helper method to restore display
        restoreDisplayAfterCountdown() {
          if (this.countdownCleanup) {
            this.testTimerDisplay.textContent = this.countdownCleanup.display;
            this.testTimerStatus.textContent = this.countdownCleanup.status;
            this.testTimerDisplay.style.backgroundColor =
              this.countdownCleanup.timerBgColor;
            this.testTimerDisplay.style.color =
              this.countdownCleanup.timerColor;
            this.testTimerDisplay.style.fontWeight =
              this.countdownCleanup.timerFontWeight;
            this.countdownCleanup = null;
          } else {
            // Default restoration based on theme
            if (document.body.classList.contains("light-scheme")) {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#0066cc";
            } else if (document.body.classList.contains("day-scheme")) {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#ffcc00";
            } else {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#f00";
            }
            this.testTimerDisplay.style.fontWeight = "";
          }

          // Re-enable appropriate buttons
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = false;
          this.resetTestTimerBtn.disabled = true;
        }

        // NEW METHOD: Actual next step logic (moved from original nextStep)
        // In the proceedToNextStep() method (around line 2950), update it to be async:
        async proceedToNextStep() {
          // Clean up any remaining countdown display properties
          this.restoreDisplayAfterCountdown();

          this.currentStep++;

          if (this.currentStep < this.steps.length) {
            this.isRunning = true;
            this.isPaused = false;
            this.isWaitingForNextStep = false;
            await this.startStep(); // Add await here

            // Update button states
            this.startTestStripBtn.textContent = "Pause";
            this.stopTestTimerBtn.disabled = false;
            this.resetTestTimerBtn.disabled = true;
          } else {
            this.complete();
          }
        }

        complete() {
          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;

          if (this.testEndBeep.checked) {
            playBeep(800, 0.1, 0.3);
          }

          this.testTimerStatus.textContent = "TEST STRIP COMPLETE";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;

          // Highlight all steps as complete
          this.currentStep = this.steps.length;
          this.updatePreview();
        }

        reset() {
          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.currentStep = 0;
          this.currentStepTime = 0;

          this.testTimerStatus.textContent = "READY FOR TEST STRIP";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;
          this.testTimerDisplay.textContent = "0.00";
          this.testTimerDisplay.classList.remove("warning");

          // Reset step display
          if (this.steps.length > 0) {
            const firstStep = this.steps[0];
            this.currentStepDisplay.textContent = `1/${this.steps.length}`;
            this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
              2
            )}s`;
            this.currentStopDisplay.textContent =
              this.method === "cumulative"
                ? `${this.formatStop(firstStep.stop)}`
                : `+${this.getIncrementLabel(this.stepIncrement)}`;
            this.timeMultiplierDisplay.textContent =
              this.method === "cumulative"
                ? `${Math.pow(2, firstStep.stop).toFixed(2)}Ã—`
                : `${firstStep.totalExposure.toFixed(1)}s total`;
            this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
          }

          this.updatePreview();
        }

        // Update the toggle() method (around line 3100):
        async toggle() {
          if (this.isRunning) {
            this.pause();
          } else if (this.isPaused) {
            await this.resume();
          } else if (this.isWaitingForNextStep) {
            // Waiting for next step - act like Next Step button
            this.nextStep();
          } else {
            await this.start();
          }
        }

        applyPreset(preset) {
          switch (preset) {
            case "standard":
              this.testBaseSlider.value = 10;
              this.testIncrementSlider.value = 1; // â…“ stop
              this.testStepsSlider.value = 6;
              this.setMethod("cumulative");
              break;
            case "fine":
              this.testBaseSlider.value = 10;
              this.testIncrementSlider.value = 1; // â…“ stop
              this.testStepsSlider.value = 8;
              this.setMethod("incremental");
              break;
            case "coarse":
              this.testBaseSlider.value = 10;
              this.testIncrementSlider.value = 2; // â…” stop
              this.testStepsSlider.value = 5;
              this.setMethod("cumulative");
              break;
            case "full":
              this.testBaseSlider.value = 5;
              this.testIncrementSlider.value = 3; // 1 stop
              this.testStepsSlider.value = 10;
              this.setMethod("incremental");
              break;
          }

          this.updateFromControls();

          // Visual feedback
          const btn = document.querySelector(`[data-preset="${preset}"]`);
          const originalColor = btn.style.backgroundColor;
          btn.style.backgroundColor = "#f00";

          setTimeout(() => {
            btn.style.backgroundColor = originalColor;
          }, 300);
        }
      }

      function updateChart() {
        const baseTime = (function () {
          // Prefer chart slider if present, otherwise fall back to the main base time slider
          if (typeof chartBaseSlider !== "undefined" && chartBaseSlider)
            return parseFloat(chartBaseSlider.value);
          const bt = document.getElementById("baseTimeSlider");
          if (bt) return parseFloat(bt.value);
          if (window.incrementalTimer)
            return parseFloat(window.incrementalTimer.baseTime) || 10;
          if (settingsManager)
            return parseFloat(settingsManager.settings.baseTime) || 10;
          return 10;
        })();
        const chartBaseEl = document.getElementById("chartBaseValue");
        if (chartBaseEl) chartBaseEl.textContent = `${baseTime.toFixed(1)}s`;

        const tableBody = document.getElementById("tableBody");
        const currentStop = parseInt(stopSlider.value);

        tableBody.innerHTML = "";

        let previousTotalTime = null;

        for (let stop = -6; stop <= 6; stop++) {
          const totalTime = calculateTime(baseTime, stop);
          const fromBaseTime = totalTime - baseTime;

          let increment = 0;
          if (previousTotalTime !== null) {
            increment = totalTime - previousTotalTime;
          }
          previousTotalTime = totalTime;

          const stopLabel = formatStop(stop);
          const row = document.createElement("tr");

          if (stop === currentStop) {
            row.className = "current-stop";
          }

          row.innerHTML = `
                <td>${stopLabel}</td>
                <td><strong>${totalTime.toFixed(2)}</strong></td>
                <td>${fromBaseTime >= 0 ? "+" : ""}${fromBaseTime.toFixed(
            2
          )}</td>
                <td class="increment-cell">${
                  increment >= 0 ? "+" : ""
                }${increment.toFixed(2)}</td>
            `;

          tableBody.appendChild(row);
        }
      }

      // Fullscreen Manager
      class FullscreenManager {
        constructor() {
          this.isFullscreen = false;
          this.toggleBtn = document.getElementById("toggleFullscreen");
          this.init();
        }

        init() {
          if (this.toggleBtn) {
            this.toggleBtn.addEventListener("click", () => this.toggle());
          }

          document.addEventListener("fullscreenchange", () =>
            this.handleFullscreenChange()
          );
          document.addEventListener("webkitfullscreenchange", () =>
            this.handleFullscreenChange()
          );
          document.addEventListener("mozfullscreenchange", () =>
            this.handleFullscreenChange()
          );
          document.addEventListener("MSFullscreenChange", () =>
            this.handleFullscreenChange()
          );

          document.addEventListener("keydown", (e) => {
            if (e.key === "F11") {
              e.preventDefault();
              this.toggle();
            }
          });
        }

        toggle() {
          if (!this.isFullscreen) {
            this.enter();
          } else {
            this.exit();
          }
        }

        enter() {
          const element = document.documentElement;

          if (element.requestFullscreen) {
            element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
          } else {
            document.body.classList.add("fullscreen-mode");
            this.isFullscreen = true;
            this.updateButton();
          }
        }

        exit() {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            document.body.classList.remove("fullscreen-mode");
            this.isFullscreen = false;
            this.updateButton();
          }
        }

        handleFullscreenChange() {
          this.isFullscreen = !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
          );

          if (this.isFullscreen) {
            document.body.classList.add("fullscreen-mode");
          } else {
            document.body.classList.remove("fullscreen-mode");
          }

          this.updateButton();
        }

        updateButton() {
          if (this.toggleBtn) {
            this.toggleBtn.textContent = this.isFullscreen
              ? "Exit Fullscreen"
              : "Enter Fullscreen";
          }
        }
      }

      // Initialize everything
      document.addEventListener("DOMContentLoaded", () => {
        // Initialize settings manager first
        settingsManager = new SettingsManager();

        // Initialize calculator
        window.incrementalTimer = new IncrementalTimer();

        // Initialize the combined calculator (replaces both old calculators)
        window.heightCalculator = new EnlargerHeightCalculator(
          window.incrementalTimer
        );

        // Initialize test strip generator
        window.fstopTestGenerator = new FStopTestStripGenerator();

        // Initialize chemical manager (UPDATED)
        window.chemicalManager = new ChemicalManager();

        // Initialize countdown manager
        window.countdownManager = new CountdownManager();

        // Initialize timers
        timerManager.init();

        // Apply saved settings to UI and instances on startup
        loadSettingsToUI();

        // Initialize fullscreen manager
        const fullscreenManager = new FullscreenManager();

        // Initialize relay manager
        window.relayManager = new RelayManager();

        // Color scheme selector
        document.querySelectorAll(".color-scheme-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const scheme = btn.getAttribute("data-scheme");
            settingsManager.setColorScheme(scheme);
          });
        });

        document
          .getElementById("testCountdownBeep")
          ?.addEventListener("click", () => {
            // Test the different beep patterns
            playBeep(400, 0.2, 0.2); // Early second beep
            setTimeout(() => playBeep(600, 0.3, 0.3), 300); // Middle second beep
            setTimeout(() => playBeep(800, 0.2, 0.4), 600); // Last 3 seconds beep
            setTimeout(() => playBeep(1600, 0.5, 0.5), 900); // Final beep
          });

        // Settings panel event listeners
        document
          .getElementById("saveGlobalSettings")
          .addEventListener("click", () => {
            settingsManager.saveGlobalSettings();
          });

        // Live-apply settings as user edits (debounced)
        (function bindLiveSettings() {
          const toBind = [
            { id: "settingBaseTime", evt: "input" },
            { id: "settingDevTime", evt: "input" },
            { id: "settingStopTime", evt: "input" },
            { id: "settingFixTime", evt: "input" },
            { id: "settingFloTime", evt: "input" },
            { id: "settingCountdownDelay", evt: "input" },
            { id: "settingCountdownBeep", evt: "change" },
            { id: "settingCountdownPattern", evt: "change" },
            { id: "settingAutoAdvance", evt: "change" },
            { id: "settingAutoAdvanceDelay", evt: "input" },
            { id: "safelightAutoOff", evt: "change" },
            { id: "settingCalcWarningBeep", evt: "change" },
            { id: "settingCalcEndBeep", evt: "change" },
            { id: "settingAutoStart", evt: "change" },
            { id: "settingTimerWarningBeep", evt: "change" },
            { id: "settingTimerEndBeep", evt: "change" },
            { id: "settingDefaultPhotoFlo", evt: "change" },
            { id: "settingStopIncrement", evt: "change" },
          ];
          toBind.forEach(({ id, evt }) => {
            const el = document.getElementById(id);
            if (!el) return;
            let t = null;
            el.addEventListener(evt, () => {
              clearTimeout(t);
              t = setTimeout(() => {
                settingsManager.applyLiveSettings();
              }, 150);
            });
          });
        })();

        // Helper: render/refresh rulers and denominator handling for stops
        function renderRuler(containerId, minStep, maxStep) {
          const container = document.getElementById(containerId);
          if (!container) return;
          container.setAttribute("aria-label", "Stops scale");
          const total = maxStep - minStep;
          const frag = document.createDocumentFragment();
          for (let i = 0; i <= total; i++) {
            const step = minStep + i;
            const span = document.createElement("span");
            span.style.fontSize = "0.7rem";
            span.style.color = "var(--text-secondary)";
            span.style.flex = "1";
            span.style.textAlign = "center";
            span.textContent = formatStop(step);
            span.setAttribute("aria-hidden", "true");
            frag.appendChild(span);
          }
          container.innerHTML = "";
          container.appendChild(frag);
        }

        function updateAllRulers() {
          renderRuler("calcStopRuler", -6, 6);

          const testContainer = document.getElementById("testIncrementRuler");
          if (!testContainer) return;
          const min = parseInt(
            document.getElementById("testIncrementSlider").min,
            10
          );
          const max = parseInt(
            document.getElementById("testIncrementSlider").max,
            10
          );
          const total = max - min;
          const frag = document.createDocumentFragment();
          for (let i = 0; i <= total; i++) {
            const val = min + i;
            const span = document.createElement("span");
            span.style.fontSize = "0.7rem";
            span.style.color = "var(--text-secondary)";
            span.style.flex = "1";
            span.style.textAlign = "center";
            const denom = window.stopDenominator || 3;
            const stopValue = val / denom;
            const whole = Math.floor(stopValue);
            const frac = stopValue - whole;
            const tol = 1e-6;
            if (Math.abs(frac) < tol) span.textContent = `${whole}`;
            else if (denom === 2) span.textContent = `${whole}Â½`;
            else if (denom === 3) span.textContent = frac < 0.5 ? "â…“" : "â…”";
            else if (denom === 4)
              span.textContent =
                frac === 0.25 ? "Â¹â„â‚„" : frac === 0.5 ? "Â²â„â‚„" : "Â³â„â‚„";
            else if (denom === 6) {
              if (Math.abs(frac - 1 / 6) < tol)
                span.textContent = `${whole}Â¹â„â‚†`;
              else if (Math.abs(frac - 2 / 6) < tol)
                span.textContent = `${whole}Â²â„â‚†`;
              else if (Math.abs(frac - 3 / 6) < tol)
                span.textContent = `${whole}Â³â„â‚†`;
              else if (Math.abs(frac - 4 / 6) < tol)
                span.textContent = `${whole}â´â„â‚†`;
              else if (Math.abs(frac - 5 / 6) < tol)
                span.textContent = `${whole}âµâ„â‚†`;
            } else span.textContent = stopValue.toFixed(1);
            frag.appendChild(span);
          }
          testContainer.innerHTML = "";
          testContainer.appendChild(frag);
        }

        // Segmented controls for denominator
        function getSelectedFromSeg(containerId) {
          const cont = document.getElementById(containerId);
          if (!cont) return null;
          const btn =
            cont.querySelector(".segmented-btn.active") ||
            cont.querySelector('.segmented-btn[aria-pressed="true"]');
          return btn ? parseInt(btn.dataset.denom, 10) : null;
        }
        function setActiveSeg(containerOrId, d) {
          const cont =
            typeof containerOrId === "string"
              ? document.getElementById(containerOrId)
              : containerOrId;
          if (!cont) return;
          Array.from(cont.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === d;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        function initSegControl(containerId) {
          const cont = document.getElementById(containerId);
          if (!cont) return;
          cont.addEventListener("click", (e) => {
            const btn = e.target.closest(".segmented-btn");
            if (!btn) return;
            const d = parseInt(btn.dataset.denom, 10);
            setActiveSeg(cont, d);
            applyDenomChange(d);
          });
          cont.addEventListener("keydown", (e) => {
            if (!["ArrowLeft", "ArrowRight", "Home", "End"].includes(e.key))
              return;
            const buttons = Array.from(cont.querySelectorAll(".segmented-btn"));
            const idx = buttons.findIndex((b) =>
              b.classList.contains("active")
            );
            let next = idx;
            if (e.key === "ArrowLeft") next = Math.max(0, idx - 1);
            if (e.key === "ArrowRight")
              next = Math.min(buttons.length - 1, idx + 1);
            if (e.key === "Home") next = 0;
            if (e.key === "End") next = buttons.length - 1;
            if (next !== idx) {
              buttons[next].focus();
              buttons[next].click();
            }
            e.preventDefault();
          });
        }

        // applyDenomChange now takes numeric denom and rescales sliders to preserve absolute stop values
        function applyDenomChange(d) {
          const newDenom = parseInt(d, 10) || 3;
          const prevDenom =
            window.stopDenominator ||
            (settingsManager && settingsManager.settings.stopDenominator) ||
            3;

          // If denom changed, rescale relevant sliders so the same absolute stop is preserved
          if (newDenom !== prevDenom) {
            // Rescale calculator stop slider (stopSlider values are fractional-step counts)
            const stopSlider = document.getElementById("stopSlider");
            if (stopSlider) {
              const oldVal = parseInt(stopSlider.value, 10) || 0;
              const stopInStops = oldVal / prevDenom; // current stop in full stops
              const newVal = Math.round(stopInStops * newDenom);
              stopSlider.value = newVal;
              // Trigger input handler to update displays
              stopSlider.dispatchEvent(new Event("input", { bubbles: true }));
            }

            // Rescale test increment slider (step increments expressed in fractional-step counts)
            const testInc = document.getElementById("testIncrementSlider");
            if (testInc) {
              const oldInc = parseInt(testInc.value, 10) || 0;
              const incInStops = oldInc / prevDenom;
              let newInc = Math.round(incInStops * newDenom);
              const min = parseInt(testInc.min, 10) || 1;
              const max = parseInt(testInc.max, 10) || 99;
              newInc = Math.max(min, Math.min(max, newInc));
              testInc.value = newInc;
              testInc.dispatchEvent(new Event("input", { bubbles: true }));
            }
          }

          window.stopDenominator = newDenom;

          // Persist setting and keep UI in sync
          if (settingsManager) {
            settingsManager.settings.stopDenominator = newDenom;
            StorageManager.saveSettings(settingsManager.settings);
          }
          const settingsSel = document.getElementById("settingStopIncrement");
          if (settingsSel) settingsSel.value = newDenom;
          // Update assistive live region
          try {
            const live = document.getElementById("settingsLiveStatus");
            if (live)
              live.textContent = `Default stop increment set to ${denomLabel(
                newDenom
              )}`;
          } catch (e) {}

          // Reflect change in segmented controls (if not already set) - keeps buttons active
          setActiveSeg("calcIncrementSeg", newDenom);
          setActiveSeg("testIncrementSeg", newDenom);

          if (window.incrementalTimer) {
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }
          updateAllRulers();
          updateChart();
        }

        // Initialize denom and controls
        window.stopDenominator =
          window.stopDenominator ||
          (settingsManager && settingsManager.settings.stopDenominator) ||
          3;
        setActiveSeg("calcIncrementSeg", window.stopDenominator);
        setActiveSeg("testIncrementSeg", window.stopDenominator);
        initSegControl("calcIncrementSeg");
        initSegControl("testIncrementSeg");
        // Backwards compatibility: update select values if present
        const calcOld = document.getElementById("calcIncrementDenom");
        const testOld = document.getElementById("testIncrementDenom");
        if (calcOld) calcOld.value = window.stopDenominator;
        if (testOld) testOld.value = window.stopDenominator;
        updateAllRulers();

        // Timer profile management in timer tab
        document
          .getElementById("saveTimerProfile")
          ?.addEventListener("click", () => {
            const profileName =
              document.getElementById("timerProfileName").value;
            if (settingsManager.saveCurrentProfile(profileName)) {
              document.getElementById("timerProfileName").value = "";
            }
          });

        document
          .getElementById("clearTimerProfiles")
          ?.addEventListener("click", () => {
            settingsManager.clearAllProfiles();
          });

        // Combined export/import in settings tab
        document
          .getElementById("exportAllProfiles")
          ?.addEventListener("click", () => {
            settingsManager.exportAllData();
          });

        document
          .getElementById("importAllProfiles")
          ?.addEventListener("click", () => {
            document.getElementById("allProfilesFileInput").click();
          });

        document
          .getElementById("allProfilesFileInput")
          .addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
              settingsManager.importAllData(event.target.result);
              e.target.value = "";
            };
            reader.onerror = () => {
              settingsManager.showAllProfilesFeedback(
                "Error reading file",
                "error"
              );
              e.target.value = "";
            };
            reader.readAsText(file);
          });

        // Update profile name input to work with Enter key in timer tab
        document
          .getElementById("timerProfileName")
          ?.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              const profileName =
                document.getElementById("timerProfileName").value;
              if (settingsManager.saveCurrentProfile(profileName)) {
                document.getElementById("timerProfileName").value = "";
              }
            }
          });

        document
          .getElementById("resetAllSettings")
          .addEventListener("click", () => {
            settingsManager.resetAllSettings();
          });

        // Initialize audio context on any user interaction
        document.addEventListener("click", initAudioContext);
        document.addEventListener("keydown", initAudioContext);

        // Initialize collapsible rows in the CALC, CHEMICAL and TIMER tabs
        (function initCalcCollapsibles() {
          const STORAGE_KEY = "calc_collapsed";
          let stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}");
          const sections = document.querySelectorAll(
            "#calc .collapsible, #chemical .collapsible, #timer .collapsible, #settings .collapsible"
          );
          // Clean up any stored keys that no longer correspond to existing sections
          const existingIds = Array.from(sections)
            .map((s) => s.getAttribute("data-id"))
            .filter(Boolean);
          Object.keys(stored).forEach((key) => {
            if (!existingIds.includes(key)) {
              delete stored[key];
            }
          });
          // Persist cleaned state back to storage
          localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
          sections.forEach((sec) => {
            const id = sec.getAttribute("data-id") || "";
            const header = sec.querySelector(".collapsible-header");
            const content = sec.querySelector(".collapsible-content");
            if (!header || !content) return;

            // Default: collapsed unless explicitly set to false in storage
            const collapsed = stored[id] !== false;
            header.setAttribute("aria-expanded", collapsed ? "false" : "true");
            content.style.maxHeight = collapsed
              ? "0px"
              : content.scrollHeight + "px";

            header.addEventListener("click", () => {
              const expanded = header.getAttribute("aria-expanded") === "true";
              header.setAttribute("aria-expanded", expanded ? "false" : "true");
              if (expanded) {
                content.style.maxHeight = "0px";
                stored[id] = true;
              } else {
                content.style.maxHeight = content.scrollHeight + "px";
                stored[id] = false;
              }
              localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
            });

            header.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                header.click();
              }
            });
          });

          // Recalculate max-heights on resize (for fluid content)
          window.addEventListener("resize", () => {
            sections.forEach((sec) => {
              const header = sec.querySelector(".collapsible-header");
              const content = sec.querySelector(".collapsible-content");
              if (
                header &&
                content &&
                header.getAttribute("aria-expanded") === "true"
              ) {
                content.style.maxHeight = content.scrollHeight + "px";
              }
            });
          });
        })();

        // Initial chart update
        updateChart();
      });
    </script>
  </body>
</html>
