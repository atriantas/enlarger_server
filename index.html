<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Darkroom Timer (Pico 2 W)</title>
    <style>
      /* ===== CONSOLIDATED STYLES FOR REDUCED REDUNDANCY ===== */
      /* The following similar classes have been consolidated:
         1. List containers: .chemical-preset-list + .shelf-life-list (replaces .profile-list)
         2. List items: .shelf-life-item (replaces .chemical-preset-item, .profile-item, .list-item, .relay-item)
         3. Toggle buttons: .toggle-btn (replaces .paper-btn, .paper-size-btn, 
            .dilution-btn, .method-btn, .color-scheme-btn, .btn-toggle, .paper-size-buttons)
         4. Action buttons: .btn-action (replaces .chemical-preset-btn, .shelf-life-btn, .profile-btn)
         5. Action containers: .shelf-life-actions (replaces .chemical-preset-actions)
         6. Flex containers: .custom-dilution (replaces .custom-paper-size)
         7. Flexible buttons: .settings-btn (replaces .repeat-btn, .btn-flex, .relay-toggle-btn) - uses inline styles for specific variants
         8. Settings buttons: .settings-btn consolidates .preset-btn, .capacity-btn, .global-btn
         9. Panel containers: .incremental-timer (replaces .test-strip-preview-container, 
            .chemical-calculator, .chemical-presets, .capacity-tracker, .shelf-life-tracker, .instructions-panel, .panel-base, .panel-container, .contrast-calculator)
         10. Label classes: .label-sm (replaces .info-label, .chemical-label-sm)
         11. Value classes: .value-display (replaces .result-value, .chemical-result-value)
         12. 3-column grid selectors: .dilution-selector (replaces .color-scheme-selector)
         13. Full-width action buttons: .settings-btn (replaces .fullscreen-btn)
         14. Medium label classes: .setting-label (replaces .sound-label, .preview-label) - CONSOLIDATED
         15. Select dropdowns: .settings-input (replaces .fstop-select)
         16. Panel containers: .incremental-timer (replaces .timer-settings)
         17. Button groups: .settings-btn-group (replaces .global-controls, .timer-controls)
         18. Section headers: .title-sm (replaces .timer-status)
         19. Flex groups: .flex-group (replaces .preview-legend, .preview-options) - CONSOLIDATED into .shelf-life-actions
         20. Step info containers: .current-step-info - CONSOLIDATED into .shelf-life-actions with inline styles
         21. Progress bars: .progress-bar (replaces .progress-fill) - uses gradient background for all progress indicators
         22. Progress labels: .progress-labels (replaces .test-progress-labels) - consolidated into single class
         23. Panel containers: .incremental-timer (replaces .test-presets) - uses inline styles for light background variants
         24. Button grids: .settings-group (replaces .preset-buttons) - uses 2-column grid layout
         25. Method selectors: .settings-group (replaces .method-selector) - uses 2-column grid layout with inline styles
         All variants use the same base styles with class-specific overrides.
      */

      /* ===== CSS VARIABLES - PRECISE MATCH TO ORIGINAL ===== */
      :root {
        /* Dark Scheme (Original Default) - EXACT matches */
        --bg: #000;
        --text: #f00;
        --text-secondary: #900;

        --accent: #f00;
        --accent-dark: #700;

        --panel: #100;
        --panel-light: #200;

        --border: #300;
        --border-light: #400;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #300, #600, #f00);
      }

      /* Light Scheme - Clean grey tones with blue accent */
      body.light-scheme {
        --bg: #ffffff;
        --text: #1a1a1a;
        --text-secondary: #666666;

        --accent: #3a86de;
        --accent-dark: #2769ac;

        --panel: #e0e0e0;
        --panel-light: #f2f2f2;

        --border: #a0a0a0;
        --border-light: #bdbdbd;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #bdbdbd, #757575, #2196f3);
      }

      /* Day Scheme - Dark grey tones with blue accent */
      body.day-scheme {
        --bg: #040404;
        --text: #e0e0e0;
        --text-secondary: #9e9e9e;

        --accent: #3a86de;
        --accent-dark: #2769ac;

        --panel: #1e1e1e;
        --panel-light: #2d2d2d;

        --border: #424242;
        --border-light: #616161;

        --warning: #ff5500;

        --slider-track: linear-gradient(to right, #424242, #757575, #42a5f5);
      }

      /* ===== BASE STYLES (IDENTICAL TO ORIGINAL) ===== */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        background-color: var(--bg);
        color: var(--text);
        line-height: 1.3;
        padding: 6px;
        min-height: 100vh;
        transition:
          background-color 0.3s,
          color 0.3s;
        overflow: hidden; /* Hide scrollbar */
      }

      .container {
        max-width: 480px;
        margin: 0 auto;
        height: 100vh; /* Full viewport height */
        overflow-y: auto; /* Allow scrolling within container */
        scrollbar-width: none; /* Firefox */
      }

      /* Hide scrollbar for Chrome, Safari and Opera */
      .container::-webkit-scrollbar {
        display: none;
      }

      /* ===== HEADER (EXACT MATCH) ===== */
      header {
        text-align: center;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--border);
      }

      h1 {
        font-size: 1.2rem;
        margin-bottom: 3px;
      }

      /* ===== COLLAPSIBLE TAB NAVIGATION ===== */
      .tab-nav-container {
        position: relative;
        margin-bottom: 8px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 6px;
      }

      .menu-button {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        padding: 8px 12px;
        background: var(--panel-light);
        color: var(--text);
        border: 1px solid var(--border-light);
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: bold;
        cursor: pointer;
        transition: none;
      }

      .menu-button:hover {
        background: var(--panel-light);
        border-color: var(--border-light);
      }

      .menu-button:focus {
        outline: none;
      }

      .menu-icon {
        font-size: 1.1rem;
        margin-right: 8px;
      }

      .menu-label {
        flex: 1;
        text-align: left;
      }

      .active-tab-name {
        color: var(--accent);
        font-weight: bold;
        margin-left: auto;
        padding-left: 8px;
      }

      .tab-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 8px;
        margin-top: 4px;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: translateY(-10px);
        transition: all 0.25s ease;
        z-index: 100;
        pointer-events: none; /* Prevent clicks when closed */
      }

      .tab-dropdown.open {
        max-height: 400px;
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto; /* Allow clicks when open */
      }

      .tab-dropdown-item {
        display: block;
        width: 100%;
        padding: 10px 12px;
        background: transparent;
        color: var(--text);
        border: none;
        border-bottom: 1px solid var(--border);
        font-size: 0.9rem;
        font-weight: bold;
        text-align: left;
        cursor: pointer;
        transition: none;
      }

      .tab-dropdown-item:last-child {
        border-bottom: none;
      }

      .tab-dropdown-item:hover {
        background: var(--panel);
        color: var(--text);
      }

      .tab-dropdown-item.active {
        background: var(--border-light);
        color: var(--accent);
        border-left: 3px solid var(--accent);
      }

      .tab-dropdown-item:focus {
        outline: none;
      }

      /* ===== OLD TAB STYLES (DEPRECATED - kept for reference) ===== */
      .tabs {
        display: none; /* Hidden - replaced by collapsible navigation */
      }

      .tab-button {
        display: none; /* Hidden - replaced by dropdown items */
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      /* ===== CALCULATOR CONTROLS (EXACT MATCH) ===== */
      .control {
        margin-bottom: 10px;
      }

      /* control-label now consolidated with settings-label */

      .slider {
        width: 100%;
        height: 24px;
        appearance: none;
        -webkit-appearance: none;
        background: transparent;
      }

      .slider::-webkit-slider-runnable-track {
        width: 100%;
        height: 3px;
        background: var(--slider-track);
      }

      .slider::-webkit-slider-thumb {
        appearance: none;
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: var(--accent);
        margin-top: -8px;
      }

      /* Unified result display containers */
      .info-box {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        text-align: center;
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px;
      }

      .timer-display {
        font-size: 2.5rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-weight: bold;
        text-align: center;
        margin: 10px 0;
        color: var(--text);
        min-height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      /* ===== BUTTON STYLES (EXACT MATCH) ===== */
      .exp-btn {
        flex: 1;
        padding: 8px;
        background: var(--accent);
        border: 1px solid var(--accent-dark);
        color: var(--bg);
        border-radius: 8px;
        font-size: 0.9rem;
        font-weight: bold;
        cursor: pointer;
        min-width: 120px;
        min-height: 60px;
      }

      .exp-btn.active {
        background: var(--border-light);
        border-color: var(--accent);
      }

      .exp-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .exp-btn.warning {
        border-color: var(--warning);
        animation: pulse 1s infinite;
      }

      .exp-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 10px;
      }

      /* info-box is the unified result display container */

      /* Unified small label class - consolidates info-label, label-sm, chemical-label-sm, label-sm */
      .label-sm {
        font-size: 0.65rem;
        color: var(--text-secondary);
        margin-bottom: 3px;
      }

      /* Unified value display class - consolidates result-value, chemical-result-value */
      .value-display {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-weight: bold;
        color: var(--text);
        font-size: 0.8rem;
      }

      /* ===== TIMER GRID (EXACT MATCH) ===== */
      .timer-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 8px;
        height: 320px;
        margin-bottom: 10px;
      }

      .timer-box {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 6px;
        padding: 6px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
      }

      /* Disabled state - black and red only */
      .timer-box.disabled {
        background: var(--border-light);
        border-color: var(--border-light);
        color: var(--border-light);
        color: var(--text-secondary);
        opacity: 0.2;
        cursor: not-allowed;
      }

      .timer-btn .time-display {
        background: var(--border-light);
        border-color: var(--border-light);
        color: var(--text-secondary);
        cursor: not-allowed;
      }

      /* Unified title classes */
      .title-sm {
        font-size: 0.75rem;
        color: var(--text);
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .title-md {
        font-size: 0.9rem;
        color: var(--title);
        margin-bottom: 8px;
        text-transform: uppercase;
      }

      .time-display {
        font-size: 1.6rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-weight: bold;
        color: var(--text);
        margin: 4px 0;
        text-align: center;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .timer-controls-2 {
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .adjust-row {
        display: flex;
        gap: 6px;
        margin-bottom: 2px;
      }

      .timer-btn {
        flex: 1;
        padding: 4px;
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 6px;
        font-size: 0.7rem;
        cursor: pointer;
        white-space: nowrap;
      }

      .timer-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .timer-btn.active {
        background: var(--border);
        border-color: var(--accent);
      }

      /* Timer states */
      .timer-box.running {
        border-color: var(--accent);
        background: var(--panel-light);
      }

      .timer-box.warning {
        border-color: var(--warning);
        animation: pulse 1s infinite;
      }

      .timer-box.complete {
        border-color: var(--accent);
        background: var(--border);
      }

      .settings-section {
        margin-bottom: 10px;
        border-bottom: 1px solid var(--border);
        padding-bottom: 10px;
      }

      .settings-section:last-child {
        border-bottom: none;
      }

      /* settings-title now uses .title-md */

      .settings-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }

      .settings-item {
        display: flex;
        flex-direction: column;
        gap: 3px;
      }

      /* Unified label for form controls */
      .control-label,
      .settings-label {
        font-size: 0.75rem;
        color: var(--text-secondary);
      }

      .control-label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 3px;
      }

      /* Base input field (consolidated) */
      .settings-input {
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text);
        padding: 4px 6px;
        font-size: 0.8rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        flex: auto;
      }

      .settings-input:focus {
        outline: none;
        border-color: var(--accent);
      }

      .settings-input::placeholder {
        color: var(--text);
        opacity: 0.7;
      }

      /* Unified list container - consolidates chemical-preset-list, shelf-life-list */
      .shelf-life-list {
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        max-height: 200px;
        overflow-y: auto;
        margin-top: 10px;
        margin-bottom: 10px;
      }

      /* Unified list item - replaces chemical-preset-item, shelf-life-item */
      .shelf-life-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px;
        border-bottom: 1px solid var(--border);
        font-size: 0.75rem;
      }

      .shelf-life-item:last-child {
        border-bottom: none;
      }

      .shelf-life-item.active {
        background: var(--border);
        font-weight: bold;
      }

      .settings-btn {
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--text);
        border-radius: 6px;
        padding: 6px 12px;
        font-size: 0.8rem;
        cursor: pointer;
        width: 100%;
      }

      .settings-btn.primary {
        background: var(--border-light);
        border-color: var(--accent);
        margin-top: 0.5rem;
      }

      .settings-btn.danger {
        background: var(--border);
        border-color: var(--accent);
      }

      .settings-btn-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }

      .settings-btn-group .settings-btn {
        flex: 1;
      }

      /* setting-item now uses .item-container */

      /* Unified medium label class - consolidates setting-label, preview-label */
      .setting-label {
        font-size: 0.7rem;
        white-space: nowrap;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 28px;
        height: 14px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider-switch {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--border);
        transition: 0.2s;
        border-radius: 6px;
      }

      .slider-switch:before {
        position: absolute;
        content: "";
        height: 10px;
        width: 10px;
        left: 2px;
        bottom: 2px;
        background-color: var(--bg);
        transition: 0.2s;
        border-radius: 50%;
      }

      input:checked + .slider-switch {
        background-color: var(--accent);
      }

      input:checked + .slider-switch:before {
        transform: translateX(14px);
      }

      /* chemical-result-box removed - using info-box instead */

      /* chemical-label-sm now uses .label-sm */
      /* chemical-result-value uses unified value classes */

      .test-strip-preview {
        display: flex;
        height: 60px;
        margin: 10px 0;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
      }

      .test-step {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        transition: background-color 0.3s;
      }

      .test-step.active {
        background: var(--border-light) !important;
      }

      .step-time {
        font-size: 0.6rem;
        font-weight: bold;
        color: var(--bg);
        text-align: center;
        z-index: 2;
      }

      .step-stop {
        font-size: 0.6rem;
        color: var(--bg);
        margin-top: 2px;
      }

      /* ===== FOOTER (EXACT MATCH) ===== */
      footer {
        text-align: center;
        margin-top: 10px;
        padding-top: 6px;
        border-top: 1px solid var(--border);
        font-size: 0.6rem;
        color: var(--text-secondary);
      }

      /* ===== ANIMATIONS (EXACT MATCH) ===== */
      @keyframes pulse {
        0% {
          border-color: var(--warning);
        }
        50% {
          border-color: var(--warning);
        }
        100% {
          border-color: var(--warning);
        }
      }

      /* ===== THE REST OF THE ORIGINAL STYLES WITH VARIABLES ===== */

      /* Chart styles */

      .time-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.7rem;
      }

      .time-table th,
      .time-table td {
        padding: 5px 3px;
        text-align: center;
        border-bottom: 1px solid var(--border);
      }

      .time-table th {
        background: var(--panel-light);
        color: var(--text);
        border-bottom: 1px solid var(--border);
        white-space: nowrap;
      }

      .time-table tr:nth-child(even) {
        background: var(--panel);
      }

      /* increment-cell can use .label-sm */

      /* Unified flex control groups */
      .sound-controls {
        display: flex;
        justify-content: space-around;
        margin-top: 10px;
      }

      /* .repeat-btn consolidated into .settings-btn with inline styles */
      /* .paper-size-buttons consolidated into .dilution-selector with inline styles */
      /* .custom-paper-size consolidated into .custom-dilution */

      /* Panel container for all panel-style sections */
      .incremental-timer {
        background: var(--panel);
        padding: 10px;
        border-radius: 6px;
        margin-top: 10px;
        margin-bottom: 10px;
      }

      /* 2-column grid layouts */
      .paper-selector {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-bottom: 10px;
      }

      /* Base toggle button (consolidated for all variants) */
      .toggle-btn {
        padding: 8px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text);
        cursor: pointer;
        text-align: center;
        font-size: 0.75rem;
      }

      .toggle-btn.active {
        background: var(--border);
        border-color: var(--border-light);
        font-weight: bold;
      }

      /* Chemical management styles */
      .dilution-selector {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 10px;
      }

      /* Flex containers for various controls */
      .custom-dilution,
      .capacity-controls {
        display: flex;
        gap: 8px;
        margin-top: 8px;
      }

      .capacity-controls {
        margin: 10px 0;
      }

      .custom-dilution input {
        flex: 1;
        text-align: center;
        padding: 4px 6px;
        background: var(--panel-light);
        border: 1px solid var(--border-light);
        border-radius: 6px;
        color: var(--text);
        font-size: 0.8rem;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      /* Unified input focus already handled by .settings-input:focus */

      /* Unified flex-row class for action buttons - replaces .chemical-preset-actions */
      .shelf-life-actions {
        display: flex;
        gap: 6px;
      }

      /* Base action button - replaces .chemical-preset-btn, .shelf-life-btn */
      .btn-action {
        background: var(--border);
        border: 1px solid var(--border-light);
        color: var(--accent);
        border-radius: 6px;
        padding: 2px 6px;
        font-size: 0.65rem;
        cursor: pointer;
      }

      .btn-action.delete {
        border-color: var(--accent);
        color: var(--accent);
      }

      .btn-action {
        min-width: 50px;
      }

      .progress-container {
        height: 8px;
        background: var(--border);
        border-radius: 6px;
        overflow: hidden;
        margin: 10px 0;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--border-light), var(--accent));
        width: 0%;
        transition: width 0.5s ease;
      }

      .progress-labels {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
        color: var(--text-secondary);
        margin-top: 5px;
      }

      /* Paper Size Selector */
      .paper-size-selector {
        margin-top: 10px;
        margin-bottom: 10px;
      }

      .custom-dilution input {
        flex: 1;
        text-align: center;
      }

      /* .shelf-life-list styles consolidated above */

      .shelf-life-item:last-child {
        border-bottom: none;
      }

      .shelf-life-item.expiring {
        background: var(--panel-light);
        border-left: 3px solid var(--accent);
      }

      .shelf-life-item.expired {
        background: var(--panel);
        border-left: 3px solid var(--accent);
        animation: pulse 2s infinite;
      }

      .shelf-life-days {
        font-weight: bold;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .shelf-life-days.expiring {
        color: var(--warning);
      }

      .shelf-life-days.expired {
        color: var(--accent);
      }

      .shelf-life-actions {
        display: flex;
        gap: 4px;
      }

      /* F-STOP TEST STRIP GENERATOR STYLES */
      /* preview-controls now consolidated with sound-controls */

      .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.7rem;
      }

      .legend-color {
        width: 12px;
        height: 12px;
        border-radius: 6px;
      }

      .test-timer-display {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin: 10px 0;
      }

      /* label-sm now uses .label-sm, value-display uses unified value classes */

      .test-progress-container {
        margin: 15px 0;
      }

      .test-progress-bar {
        height: 6px;
        background: var(--border);
        border-radius: 6px;
        overflow: hidden;
        position: relative;
      }

      /* Countdown display styles */
      .countdown-active {
        animation: countdown-pulse 1s infinite;
      }

      @keyframes countdown-pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
        100% {
          transform: scale(1);
        }
      }

      .control input:checked + .slider-switch {
        background-color: var(--accent);
      }

      /* ===== FULLSCREEN STYLES ===== */
      body.fullscreen-mode {
        padding: 0;
      }

      /* Container: use a single canonical set of rules for fullscreen */
      body.fullscreen-mode .container {
        max-width: 960px;
        margin: 0 auto;
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* container shouldn't scroll; tab content should */
      }

      /* Collapsible navigation should stay at top in fullscreen */
      body.fullscreen-mode .tab-nav-container {
        border-bottom: 1px solid var(--border);
        margin-bottom: 0;
        flex-shrink: 0;
        padding-bottom: 8px;
      }

      body.fullscreen-mode .menu-button {
        padding: 12px 16px;
        font-size: 1rem;
      }

      body.fullscreen-mode .tab-dropdown {
        max-height: 50vh; /* Limit height in fullscreen */
        pointer-events: none; /* Prevent clicks when closed */
        box-shadow: none; /* Remove shadow in fullscreen */
      }

      body.fullscreen-mode .tab-dropdown.open {
        max-height: 50vh; /* Limit height in fullscreen */
        pointer-events: auto; /* Allow clicks when open */
        box-shadow: none; /* Remove shadow in fullscreen */
      }

      body.fullscreen-mode .tab-dropdown-item {
        padding: 12px 16px;
        font-size: 1rem;
      }

      /* Hide header and footer in fullscreen */
      body.fullscreen-mode header,
      body.fullscreen-mode footer {
        display: none;
      }

      /* Tab content: scrollable and flexible in fullscreen */
      body.fullscreen-mode .tab-content.active {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 8px;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      /* Ensure tab contents are scrollable by default in fullscreen */
      body.fullscreen-mode .tab-content {
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      body.fullscreen-mode .tab-content::-webkit-scrollbar {
        display: none;
      }

      /* Timer tab specific adjustments */
      body.fullscreen-mode #timer.tab-content.active {
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none; /* Firefox */
      }

      /* Settings tab adjustments */
      body.fullscreen-mode #settings.tab-content.active {
        overflow-y: auto;
        overflow-x: hidden;
      }

      /* Collapsible rows in CALC tab */
      .collapsible {
        border-top: 1px solid var(--border);
        margin-top: 10px;
        padding-top: 6px;
      }
      .collapsible-header {
        width: 100%;
        text-align: left;
        background: transparent;
        border: none;
        color: var(--text);
        font-weight: bold;
        padding: 8px 6px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.95rem;
      }
      .collapsible-header::after {
        content: "▾";
        transition: transform 0.2s ease;
        color: var(--text-secondary);
        font-size: 0.9rem;
      }
      .collapsible-header[aria-expanded="false"]::after {
        transform: rotate(-90deg);
      }
      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.28s ease;
        max-height: 0;
      }
      .collapsible .exp-info {
        margin-top: 6px;
      }
      .collapsible .info-box {
        margin-bottom: 6px;
      }

      /* -------------------------------------------------------------
         Controls: Segmented control (increment selectors)
         - Clear, accessible focus styles using --accent
         - Responsive adjustments for small screens
         - Small wrap behavior so controls remain usable on narrow widths
         ------------------------------------------------------------- */
      .segmented-control {
        display: inline-flex;
        border: 1px solid var(--border);
        border-radius: 6px;
        overflow: hidden;
        background: var(--panel);
        align-items: center;
        gap: 0; /* buttons are visually separated by borders */
      }

      .segmented-control .segmented-btn {
        background: transparent;
        border: none;
        padding: 8px 12px;
        cursor: pointer;
        color: var(--text);
        font-size: 0.9rem;
        min-width: 44px;
        text-align: center;
        line-height: 1;
      }

      .segmented-control .segmented-btn:not(:last-child) {
        border-right: 1px solid var(--border);
      }

      .segmented-control .segmented-btn.active,
      .segmented-control .segmented-btn[aria-pressed="true"] {
        background: var(--border-light);
        color: var(--accent);
      }

      /* Prefer the more semantic :focus-visible when available */
      .segmented-control .segmented-btn:focus {
        outline: none;
      }
      .segmented-control .segmented-btn:focus-visible {
        /* Use accent color for the outline if available, with a subtle shadow for depth */
        outline: 2px solid var(--accent);
        box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.12);
        z-index: 1;
      }

      /* Container for segmented controls (centers buttons) */
      .segmented-control-container {
        margin-top: 6px;
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
      }

      /* Accessibility helper: visually-hidden */
      .visually-hidden {
        position: absolute !important;
        height: 1px;
        width: 1px;
        overflow: hidden;
        clip: rect(1px, 1px, 1px, 1px);
        white-space: nowrap;
        border: 0;
        padding: 0;
        margin: -1px;
      }

      /* Custom filter bank layout */
      .custom-filter-header {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        align-items: center;
        margin-bottom: 8px;
      }

      .custom-filter-rows {
        display: grid;
        grid-template-columns: 1fr;
        gap: 6px;
      }

      .custom-filter-row {
        display: grid;
        grid-template-columns: 1.1fr 0.6fr 0.6fr;
        gap: 6px;
        align-items: center;
      }

      .custom-filter-row input[type="text"] {
        width: 100%;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .custom-filter-row input[type="text"]::placeholder {
        color: var(--text);
        opacity: 0.7;
      }

      .custom-filter-row input[type="number"] {
        width: 100%;
        padding: 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--panel);
        color: var(--text);
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      }

      .custom-filter-row input[type="number"]::placeholder {
        color: var(--text);
        opacity: 0.7;
      }

      .custom-filter-row button {
        padding: 6px;
        border-radius: 6px;
        border: 1px solid var(--border);
        background: var(--accent-muted);
        color: var(--text);
        cursor: pointer;
      }

      .custom-filter-row button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      /* Relay styles remain outside fullscreen concerns */
      /* relay-controls now consolidated with .incremental-timer */

      /* .relay-item consolidated into .shelf-life-item with inline styles */

      /* .relay-toggle-btn consolidated into .settings-btn with inline styles */

      /* Mobile adjustments for fullscreen with profiles */
      @media (max-width: 400px) {
        body.fullscreen-mode #timer .timer-grid {
          height: auto; /* Maintain flexible height */
          min-height: 320px; /* ensure space for 2x2 grid */
          display: grid; /* keep 2-column grid in fullscreen on mobile */
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          gap: 6px;
        }
      }

      /* Desktop adjustments */
      @media (min-width: 401px) {
        /* Fullscreen mode adjustments for desktop */
        body.fullscreen-mode .timer-grid {
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          height: auto; /* Changed from calc(100vh - 120px) */
        }

        /* Ensure timer tab can scroll and the grid can flex in fullscreen on wider screens */
        body.fullscreen-mode #timer.tab-content.active {
          display: flex;
          flex-direction: column;
          min-height: 0; /* allow flex children to shrink */
          overflow-y: auto; /* enable scrolling if content overflows */
          -webkit-overflow-scrolling: touch;
        }
      }

      /* ===== MOBILE STYLES - EXACT MATCH ===== */
      @media (max-width: 400px) {
        /* Calculator info - 2 columns on mobile */
        .exp-info {
          grid-template-columns: 1fr 1fr;
        }

        /* Settings - 2 columns on mobile */
        .settings-group {
          grid-template-columns: 1fr 1fr;
        }

        /* Chemical management mobile adjustments */
        .dilution-selector {
          grid-template-columns: repeat(2, 1fr);
        }

        .capacity-controls {
          flex-direction: column;
        }

        /* Fullscreen mode adjustments for mobile */
        body.fullscreen-mode {
          padding: 0;
        }

        body.fullscreen-mode .container {
          padding: 0;
        }

        body.fullscreen-mode .tab-nav-container {
          margin-bottom: 0;
          border-bottom: none;
        }

        body.fullscreen-mode .menu-button {
          padding: 14px 16px;
          font-size: 1.1rem;
        }

        body.fullscreen-mode .tab-dropdown {
          max-height: 70vh; /* More height on mobile fullscreen */
          pointer-events: none; /* Prevent clicks when closed */
          box-shadow: none; /* Remove shadow in fullscreen */
        }

        body.fullscreen-mode .tab-dropdown.open {
          max-height: 70vh; /* More height on mobile fullscreen */
          pointer-events: auto; /* Allow clicks when open */
          box-shadow: none; /* Remove shadow in fullscreen */
        }

        body.fullscreen-mode .tab-dropdown-item {
          padding: 14px 16px;
          font-size: 1.1rem;
        }

        /* Collapsible navigation mobile adjustments */
        .menu-button {
          padding: 10px 12px;
          font-size: 1rem;
        }

        .menu-icon {
          font-size: 1.2rem;
        }

        .tab-dropdown {
          max-height: 60vh; /* Limit height on mobile */
          overflow-y: auto; /* Allow scrolling if many tabs */
        }

        .tab-dropdown-item {
          padding: 12px 12px;
          font-size: 1rem;
        }

        /* Test strip mobile adjustments */
        .test-timer-display {
          flex-direction: column;
          gap: 5px;
        }

        .paper-selector {
          grid-template-columns: 1fr;
        }
        .segmented-control {
          flex-wrap: wrap;
          justify-content: center;
        }
        .segmented-control .segmented-btn {
          padding: 6px 8px;
          min-width: 36px;
          font-size: 0.85rem;
        }
        .segmented-control-container {
          gap: 6px;
        }

        .proof-grid {
          display: grid;
          gap: 2px;
          background: var(--border);
          padding: 4px;
          border-radius: 8px;
        }

        .proof-cell {
          width: 100%;
          aspect-ratio: 1 / 1;
          background: #111;
          border: 1px solid #000;
          border-radius: 2px;
        }

        .proof-cell.proof-cursor {
          outline: 2px solid var(--accent);
        }

        .proof-cell.proof-reference {
          box-shadow: inset 0 0 0 2px var(--warning);
        }

        .proof-cell.proof-selected {
          box-shadow: inset 0 0 0 3px #4A9EFF;
        }

        .proof-cell.proof-reference.proof-selected {
          box-shadow: inset 0 0 0 2px var(--warning), inset 0 0 0 4px #4A9EFF;
        }

        .proof-cell.proof-clipped-white {
          outline: 2px solid #ccc;
        }

        .proof-cell.proof-clipped-black {
          outline: 2px solid #111;
        }

        .proof-legend {
          display: flex;
          justify-content: space-between;
          font-size: 0.6rem;
          color: var(--text-secondary);
          margin-top: 6px;
        }

        .proof-histogram {
          margin-top: 8px;
          background: #0b0b0b;
          border: 1px solid #000;
          border-radius: 8px;
          padding: 6px;
        }

        .proof-histogram-label {
          text-align: center;
          margin-bottom: 4px;
          color: var(--text-secondary);
        }

        .proof-histogram-canvas {
          width: 100%;
          height: 90px;
          display: block;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>CYANOWOOD TIMER & TOOLS</h1>
      </header>

      <!-- Accessibility: live status for settings updates -->
      <div
        id="settingsLiveStatus"
        class="visually-hidden"
        aria-live="polite"
        aria-atomic="true"
      ></div>

      <!-- Collapsible Tab Navigation -->
      <div class="tab-nav-container">
        <button
          class="menu-button"
          id="menuButton"
          aria-expanded="false"
          aria-controls="tabDropdown"
        >
          <span class="menu-icon">☰</span>
          <span class="menu-label">Menu</span>
          <span class="active-tab-name" id="activeTabName">CALC</span>
        </button>

        <div
          class="tab-dropdown"
          id="tabDropdown"
          role="menu"
          aria-hidden="true"
        >
          <button
            class="tab-dropdown-item"
            data-tab="fstop-test"
            role="menuitem"
          >
            TEST
          </button>
          <button
            class="tab-dropdown-item"
            data-tab="light-meter"
            role="menuitem"
          >
            METER
          </button>
          <button class="tab-dropdown-item" data-tab="split" role="menuitem">
            SPLIT
          </button>
          <button
            class="tab-dropdown-item active"
            data-tab="calc"
            role="menuitem"
          >
            CALC
          </button>
          <button class="tab-dropdown-item" data-tab="timer" role="menuitem">
            TIMER
          </button>
          <button class="tab-dropdown-item" data-tab="relay" role="menuitem">
            CONTROL
          </button>
          <button class="tab-dropdown-item" data-tab="chemical" role="menuitem">
            CHEMICAL
          </button>
          <button class="tab-dropdown-item" data-tab="chart" role="menuitem">
            CHART
          </button>
          <button class="tab-dropdown-item" data-tab="logs" role="menuitem">
            LOGS
          </button>
          <button class="tab-dropdown-item" data-tab="settings" role="menuitem">
            SETTINGS
          </button>
        </div>
      </div>

      <!-- Calculator Tab with Incremental Exposure Timer -->
      <div id="calc" class="tab-content active">
        <!-- Split-Grade Times Display (hidden by default) -->
        <div
          id="splitGradeDisplay"
          class="incremental-timer"
          style="display: none"
        >
          <div class="title-md">Split-Grade Times</div>
          <div class="info-box" style="margin-bottom: 8px">
            <div class="label-sm">NEUTRAL TIME</div>
            <div class="value-display" id="splitNeutralDisplay">--</div>
            <div class="label-sm" style="margin-top: 4px">
              BASE TIMES (Burn Split)
            </div>
            <div class="value-display" id="splitTimeDisplayCalc">--</div>
            <div class="label-sm" style="margin-top: 4px">TOTAL EXPOSURE</div>
            <div class="value-display" id="splitTotalDisplay">--</div>
          </div>
          <div class="settings-group">
            <button
              class="settings-btn"
              id="applyHighlights"
              style="background: var(--border-light)"
            >
              <span style="font-size: 0.7rem">HIGHLIGHTS</span><br />
              <span id="highlightsTime" style="font-size: 0.9rem">--</span>
            </button>
            <button
              class="settings-btn"
              id="applyShadows"
              style="background: var(--border-light)"
            >
              <span style="font-size: 0.7rem">SHADOWS</span><br />
              <span id="shadowsTime" style="font-size: 0.9rem">--</span>
            </button>
          </div>
          <div class="settings-btn-group">
            <button class="settings-btn danger" id="clearSplitData">
              Clear Split Data
            </button>
          </div>
          <div class="label-sm" style="margin-top: 8px; text-align: center">
            Click to apply time to BASE TIME • Use STOP ADJUST for dodge/burn
          </div>
        </div>

        <div class="control">
          <div class="control-label">
            <span>BASE TIME</span>
            <span class="value-display" id="baseTimeValue">10.0s</span>
          </div>
          <input
            type="range"
            min="0.4"
            max="50"
            step="0.1"
            value="10"
            class="slider"
            id="baseTimeSlider"
          />
        </div>

        <div class="control">
          <div class="control-label">
            <span>STOP ADJUST</span>
            <span class="value-display" id="stopValue">0.0</span>
          </div>
          <input
            type="range"
            min="-6"
            max="6"
            step="1"
            value="0"
            class="slider"
            id="stopSlider"
          />

          <!-- Dynamic ruler that will be populated based on selected increment denominator -->
          <div
            id="calcStopRuler"
            style="
              display: flex;
              justify-content: space-between;
              margin-top: 5px;
              padding: 0 5px;
            "
          >
            <!-- labels populated by JS -->
          </div>

          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="calcIncrementSeg"
              role="tablist"
              aria-label="Calc stop increment"
            >
              <button
                type="button"
                class="segmented-btn"
                data-denom="1"
                aria-pressed="false"
              >
                1
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="2"
                aria-pressed="false"
              >
                1/2
              </button>
              <button
                type="button"
                class="segmented-btn active"
                data-denom="3"
                aria-pressed="true"
              >
                1/3
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="4"
                aria-pressed="false"
              >
                1/4
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="6"
                aria-pressed="false"
              >
                1/6
              </button>
            </div>
          </div>
        </div>

        <div class="info-box">
          <div class="label-sm">SELECTED EXPOSURE</div>
          <div class="value-display" id="resultTime" style="font-size: 1.2rem">
            10.00
          </div>
          <div class="label-sm" id="resultDetails">BASE (0.0 stops)</div>
        </div>

        <!-- Simplified Incremental Exposure Timer -->
        <div class="incremental-timer">
          <div class="title-sm" id="timerStatus" style="text-align: center">
            READY FOR EXPOSURE
          </div>
          <div class="timer-display" id="calcTimerDisplay">10.00</div>

          <!-- Notes Input for Current Exposure -->
          <div class="control">
            <div class="control-label">
              <span>Notes for this exposure</span>
            </div>
            <input
              type="text"
              id="calcNotesInput"
              class="settings-input"
              placeholder="e.g., Added 1 stop - perfect"
              style="width: 100%"
            />
          </div>

          <div class="settings-btn-group">
            <button class="exp-btn" id="startExposure">Start Exposure</button>
            <button class="exp-btn" id="stopCalcTimer" disabled>Stop</button>
            <button class="exp-btn" id="resetCalcTimer">Reset</button>
            <button
              class="settings-btn"
              id="repeatExposure"
              disabled
              style="
                flex: 1;
                font-size: 0.9rem;
                font-weight: bold;
                padding: 8px;
              "
            >
              Repeat Last
            </button>
          </div>

          <!-- Simplified Information Display -->
          <div class="exp-info">
            <div class="info-box">
              <div class="label-sm">Selected Stop</div>
              <div class="value-display" id="selectedStopDisplay">0.0</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Previous Total</div>
              <div class="value-display" id="previousTotalDisplay">0.00</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Current Total</div>
              <div class="value-display" id="currentTotalDisplay">10.00</div>
            </div>
            <div class="info-box">
              <div class="label-sm">This Exposure</div>
              <div class="value-display" id="thisExposureDisplay">10.00</div>
            </div>
          </div>
        </div>

        <!-- NEW: Transfer to TIMER Tab Button -->
        <div class="settings-btn-group" style="margin-top: 10px">
          <button
            class="settings-btn primary"
            id="transferToTimer"
            style="
              background: var(--accent);
              color: var(--bg);
              font-weight: bold;
              padding: 10px;
              font-size: 0.9rem;
              width: 100%;
            "
          >
            Transfer to TIMER Tab →
          </button>
        </div>

        <!-- MODIFIED ENLARGER HEIGHT CALCULATOR WITH CONTRAST CONTROL INTEGRATED -->
        <div class="incremental-timer" style="margin-top: 10px">
          <div class="title-sm" style="text-align: center">
            ENLARGER & CONTRAST CALCULATOR
          </div>
          <!-- Original Settings Section -->
          <div class="info-box">
            <div class="label-sm">Original Time (s)</div>
            <div class="value-display" id="originalTimeValue">10.00</div>
            <div style="display: flex; gap: 5px; margin-top: 5px">
              <button
                class="timer-btn"
                id="copyCurrentTime"
                style="flex: 1; font-size: 0.6rem; padding: 2px 4px"
              >
                Use Current
              </button>
            </div>
          </div>

          <!-- Height Adjustments -->
          <section class="collapsible" data-id="head-height">
            <button class="collapsible-header" aria-expanded="false">
              Head Height Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="label-sm">Original Height (cm)</div>
                  <div class="value-display" id="originalHeightValue">30.0</div>
                  <div style="margin-top: 5px">
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-bottom: 2px;
                      "
                    >
                      Coarse adjustment
                    </div>
                    <input
                      type="range"
                      min="10"
                      max="60"
                      step="1"
                      value="30"
                      class="slider"
                      id="originalHeightCoarseSlider"
                    />
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-top: 3px;
                        margin-bottom: 2px;
                      "
                    >
                      Fine adjustment (±0.5cm)
                    </div>
                    <input
                      type="range"
                      min="-5"
                      max="5"
                      step="1"
                      value="0"
                      class="slider"
                      id="originalHeightFineSlider"
                      style="height: 16px"
                    />
                  </div>
                </div>
                <div class="info-box">
                  <div class="label-sm">New Height (cm)</div>
                  <div class="value-display" id="newHeightValue">30.0</div>
                  <div style="margin-top: 5px">
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-bottom: 2px;
                      "
                    >
                      Coarse adjustment
                    </div>
                    <input
                      type="range"
                      min="10"
                      max="60"
                      step="1"
                      value="30"
                      class="slider"
                      id="newHeightCoarseSlider"
                    />
                    <div
                      style="
                        font-size: 0.6rem;
                        color: var(--text-secondary);
                        margin-top: 3px;
                        margin-bottom: 2px;
                      "
                    >
                      Fine adjustment (±0.5cm)
                    </div>
                    <input
                      type="range"
                      min="-5"
                      max="5"
                      step="1"
                      value="0"
                      class="slider"
                      id="newHeightFineSlider"
                      style="height: 16px"
                    />
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- F-Stop Adjustment -->
          <section class="collapsible" data-id="fstop">
            <button class="collapsible-header" aria-expanded="false">
              F-Stop Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <div class="info-box">
                  <div class="label-sm">Original F-Stop</div>
                  <select
                    class="settings-input"
                    id="originalFStop"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="2.8">f/2.8</option>
                    <option value="4">f/4</option>
                    <option value="5.6" selected>f/5.6</option>
                    <option value="8">f/8</option>
                    <option value="11">f/11</option>
                    <option value="16">f/16</option>
                    <option value="22">f/22</option>
                    <option value="32">f/32</option>
                  </select>
                </div>
                <div class="info-box">
                  <div class="label-sm">New F-Stop</div>
                  <select
                    class="settings-input"
                    id="newFStop"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="2.8">f/2.8</option>
                    <option value="4">f/4</option>
                    <option value="5.6" selected>f/5.6</option>
                    <option value="8">f/8</option>
                    <option value="11">f/11</option>
                    <option value="16">f/16</option>
                    <option value="22">f/22</option>
                    <option value="32">f/32</option>
                  </select>
                </div>
              </div>
            </div>
          </section>

          <!-- Paper Size Adjustment -->
          <section class="collapsible" data-id="paper-size">
            <button class="collapsible-header" aria-expanded="false">
              Paper Size Adjustment
            </button>
            <div class="collapsible-content">
              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 0"
              >
                <!-- Original Paper Size -->
                <div class="info-box">
                  <div class="label-sm">Original Paper Size</div>
                  <select
                    class="settings-input"
                    id="originalPaperSize"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="0.011">3.5×5" (0.011 m²)</option>
                    <option value="0.013">4×5" (0.013 m²)</option>
                    <option value="0.023">5×7" (0.023 m²)</option>
                    <option value="0.052" selected>8×10" (0.052 m²)</option>
                    <option value="0.099">11×14" (0.099 m²)</option>
                    <option value="0.206">16×20" (0.206 m²)</option>
                    <option value="custom">Custom size...</option>
                  </select>
                  <!-- ADD "style" attribute to this div -->
                  <div
                    id="originalCustomPaperSize"
                    style="display: none; margin-top: 5px"
                  >
                    <input
                      type="number"
                      min="0.001"
                      max="1"
                      step="0.001"
                      value="0.052"
                      class="settings-input"
                      id="originalCustomPaperSizeValue"
                      placeholder="m²"
                      style="width: 80px; font-size: 0.7rem"
                    />
                    <button
                      class="timer-btn"
                      id="setOriginalCustomPaper"
                      style="font-size: 0.6rem; padding: 2px 4px"
                    >
                      Set
                    </button>
                  </div>
                </div>

                <!-- New Paper Size -->
                <div class="info-box">
                  <div class="label-sm">New Paper Size</div>
                  <select
                    class="settings-input"
                    id="newPaperSize"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="0.011">3.5×5" (0.011 m²)</option>
                    <option value="0.013">4×5" (0.013 m²)</option>
                    <option value="0.023">5×7" (0.023 m²)</option>
                    <option value="0.052" selected>8×10" (0.052 m²)</option>
                    <option value="0.099">11x14" (0.099 m²)</option>
                    <option value="0.206">16x20" (0.206 m²)</option>
                    <option value="custom">Custom size...</option>
                  </select>
                  <!-- ADD "style" attribute to this div -->
                  <div
                    id="newCustomPaperSize"
                    style="display: none; margin-top: 5px"
                  >
                    <input
                      type="number"
                      min="0.001"
                      max="1"
                      step="0.001"
                      value="0.052"
                      class="settings-input"
                      id="newCustomPaperSizeValue"
                      placeholder="m²"
                      style="width: 80px; font-size: 0.7rem"
                    />
                    <button
                      class="timer-btn"
                      id="setNewCustomPaper"
                      style="font-size: 0.6rem; padding: 2px 4px"
                    >
                      Set
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- CONTRAST CONTROL INTEGRATED -->
          <section class="collapsible" data-id="contrast-filter">
            <button class="collapsible-header" aria-expanded="false">
              Contrast Filter Adjustment
            </button>
            <div class="collapsible-content">
              <div class="control">
                <div class="control-label">
                  <span>PAPER BRAND</span>
                </div>
                <div class="settings-group" style="margin-top: 5px">
                  <button
                    class="toggle-btn active"
                    data-brand="FOMA"
                    id="btnContrastFoma"
                  >
                    FOMA
                  </button>
                  <button
                    class="toggle-btn"
                    data-brand="Ilford"
                    id="btnContrastIlford"
                  >
                    Ilford
                  </button>
                </div>
              </div>

              <div
                class="exp-info"
                style="grid-template-columns: 1fr 1fr; margin-top: 8px"
              >
                <!-- Paper Type Dropdowns -->
                <div class="info-box">
                  <div class="label-sm">Paper Type</div>

                  <!-- Ilford Paper Type (hidden by default) -->
                  <div
                    id="ilfordPaperSelector"
                    class="control"
                    style="display: none; margin-top: 5px"
                  >
                    <select
                      class="settings-input"
                      id="ilfordPaperType"
                      style="width: 100%"
                    >
                      <option value="cooltone">Multigrade RC Cooltone</option>
                      <option value="portfolio">
                        Multigrade IV RC Portfolio (Discontinued)
                      </option>
                      <option value="rc_deluxe_new">
                        MULTIGRADE RC DELUXE (NEW)
                      </option>
                      <option value="rc_portfolio_new">
                        MULTIGRADE RC PORTFOLIO (NEW)
                      </option>
                      <option value="fb_classic">Multigrade FB Classic</option>
                      <option value="fb_warmtone">
                        Multigrade FB Warmtone
                      </option>
                      <option value="fb_cooltone">
                        Multigrade FB Cooltone
                      </option>
                    </select>
                  </div>

                  <!-- FOMA Paper Type (visible when FOMA selected) -->
                  <div
                    id="fomaPaperSelector"
                    class="control"
                    style="margin-top: 5px"
                  >
                    <select
                      class="settings-input"
                      id="fomaPaperType"
                      style="width: 100%"
                    >
                      <option value="fomaspeed">FOMASPEED VARIANT</option>
                      <option value="fomabrom">FOMABROM VARIANT</option>
                      <option value="fomapastel_mg">
                        FOMAPASTEL MG (Special FB Colored Base)
                      </option>
                      <option value="fomatone_mg_classic_variant">
                        FOMATONE MG Classic (Warm Tone)
                      </option>
                    </select>
                  </div>
                </div>
                <div class="info-box">
                  <div class="label-sm">Contrast Filter</div>
                  <select
                    class="settings-input"
                    id="contrastFilterSelect"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="none">No filter</option>
                  </select>
                  <div
                    class="exp-info"
                    style="grid-template-columns: 1fr 1fr; margin-top: 5px"
                  >
                    <div class="info-box" style="padding: 3px" id="isoRBox">
                      <div class="label-sm">ISO R</div>
                      <div class="value-display" id="isoValue">105</div>
                    </div>
                    <div class="info-box" style="padding: 3px">
                      <div class="label-sm">Contrast Factor</div>
                      <div class="value-display" id="filterFactorValue">
                        1.0×
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

          <!-- Custom Filter Bank -->
          <section class="collapsible" data-id="custom-filter-bank">
            <button class="collapsible-header" aria-expanded="false">
              Custom Factor Bank
            </button>
            <div class="collapsible-content">
              <div class="custom-filter-header">
                <div>
                  <div class="label-sm">Group</div>
                  <select
                    class="settings-input"
                    id="customFilterGroup"
                    style="
                      width: 100%;
                      text-align: center;
                      cursor: pointer;
                      margin-top: 8px;
                    "
                  >
                    <option value="0">Group A</option>
                    <option value="1">Group B</option>
                    <option value="2">Group C</option>
                  </select>
                </div>
                <div>
                  <div class="label-sm">Group Name</div>
                  <input
                    type="text"
                    id="customFilterGroupName"
                    class="settings-input"
                    placeholder="Group name"
                    style="width: 100%"
                  />
                </div>
              </div>

              <div
                style="
                  font-size: 0.8rem;
                  color: var(--text-secondary);
                  margin-bottom: 6px;
                "
              >
                Store up to 12 named factors per group (3 groups). Use these to
                drive the Contrast Factor used in New Adjusted Time. Values
                auto-save and are included in Export All Data.
              </div>

              <div class="custom-filter-rows" id="customFilterRows"></div>
            </div>
          </section>

          <!-- Combined Factors Display -->
          <div
            class="title-sm"
            style="text-align: center; font-size: 0.65rem; margin-top: 15px"
          >
            Factors & Time
          </div>
          <div
            class="exp-info"
            style="grid-template-columns: 1fr 1fr 1fr 1fr 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="label-sm">Height Factor</div>
              <div class="value-display" id="heightFactorDisplay">1.00x</div>
            </div>
            <div class="info-box">
              <div class="label-sm">F-Stop Factor</div>
              <div class="value-display" id="fstopFactor">1.00x</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Paper Factor</div>
              <div class="value-display" id="paperSizeFactor">1.00x</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Contrast Factor</div>
              <div class="value-display" id="filterFactorValueDisplay">
                1.00x
              </div>
            </div>
            <div class="info-box">
              <div class="label-sm">Custom Factor</div>
              <div class="value-display" id="customBankFactorDisplay">
                1.00x
              </div>
            </div>
          </div>

          <div
            class="exp-info"
            style="grid-template-columns: 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="label-sm">Combined Factor</div>
              <div class="value-display" id="combinedFactor">1.00x</div>
            </div>
          </div>

          <div
            class="exp-info"
            style="grid-template-columns: 1fr; margin-top: 8px"
          >
            <div class="info-box">
              <div class="label-sm">New Adjusted Time (s)</div>
              <div class="value-display" id="newAdjustedTime">10.00</div>
              <div
                style="
                  font-size: 0.6rem;
                  color: var(--text-secondary);
                  margin-top: 3px;
                "
              >
                Formula: Original Time × (New Height ÷ Original Height)² × (New
                F-Stop ÷ Original F-Stop)² × (√New Paper Area ÷ √Original Paper
                Area)² × Filter Factor
              </div>
            </div>
          </div>

          <div style="margin-top: 10px; text-align: center">
            <button
              class="exp-btn"
              id="applyHeightTime"
              style="margin-bottom: 5px"
            >
              Apply Adjusted Time as Base Time
            </button>
            <div
              style="
                font-size: 0.6rem;
                color: var(--text-secondary);
                margin-top: 3px;
              "
            >
              Example: 10s at 30cm, f/5.6, No filter → 22.5s at 45cm, f/5.6, No
              filter<br />
              Example with filter: 10s at f/5.6 → 14s with Y filter (1.4×
              factor)
            </div>
          </div>
        </div>
      </div>

      <!-- SPLIT Tab - Split-Grade Calculator -->
      <div id="split" class="tab-content">
        <div class="incremental-timer">
          <div class="title-md">The Ilford Way - Split-Grade</div>

          <div class="control">
            <div class="control-label">
              <span>NEUTRAL TIME (Test Strip Result)</span>
              <span class="value-display" id="neutralTimeValue">10.0s</span>
            </div>
            <input
              type="range"
              class="slider"
              id="neutralTimeSlider"
              min="0.4"
              max="50"
              step="0.1"
              value="10.0"
            />
          </div>

          <div class="control">
            <div class="control-label">
              <span>PAPER BRAND</span>
            </div>
            <div class="settings-group" style="margin-top: 5px">
              <button
                class="toggle-btn active"
                data-brand="FOMA"
                id="btnSplitFoma"
              >
                FOMA
              </button>
              <button
                class="toggle-btn"
                data-brand="Ilford"
                id="btnSplitIlford"
              >
                Ilford
              </button>
            </div>
          </div>

          <!-- FOMA Paper Type Selection (hidden by default) -->
          <div class="control" id="fomaPaperSelection" style="display: none">
            <div class="control-label">
              <span>FOMA PAPER TYPE</span>
            </div>
            <select
              class="settings-input"
              id="splitFomaPaperType"
              style="width: 100%; margin-top: 5px"
            >
              <option value="fomaspeed">FOMASPEED VARIANT</option>
              <option value="fomabrom">FOMABROM VARIANT</option>
              <option value="fomapastel_mg">
                FOMAPASTEL MG (Special FB Colored Base)
              </option>
              <option value="fomatone_mg_classic_variant">
                FOMATONE MG Classic (Warm Tone)
              </option>
            </select>
          </div>

          <!-- Ilford Paper Type Selection (hidden by default) -->
          <div class="control" id="ilfordPaperSelection" style="display: none">
            <div class="control-label">
              <span>ILFORD PAPER TYPE</span>
            </div>
            <select
              class="settings-input"
              id="splitIlfordPaperType"
              style="width: 100%; margin-top: 5px"
            >
              <option value="cooltone">Multigrade RC Cooltone</option>
              <option value="portfolio">
                Multigrade IV RC Portfolio (Discontinued)
              </option>
              <option value="rc_deluxe_new">MULTIGRADE RC DELUXE (NEW)</option>
              <option value="rc_portfolio_new">
                MULTIGRADE RC PORTFOLIO (NEW)
              </option>
              <option value="fb_classic">Multigrade FB Classic</option>
              <option value="fb_warmtone">Multigrade FB Warmtone</option>
              <option value="fb_cooltone">Multigrade FB Cooltone</option>
            </select>
          </div>

          <div class="control">
            <div class="control-label">
              <span>SOFT FILTER (Highlights)</span>
            </div>
            <div class="segmented-control-container">
              <div class="segmented-control" id="splitSoftFilter">
                <button class="segmented-btn" data-filter="00">00</button>
                <button class="segmented-btn" data-filter="0">0</button>
                <button class="segmented-btn" data-filter="1">1</button>
                <button class="segmented-btn" data-filter="2">2</button>
                <button class="segmented-btn" data-filter="3">3</button>
                <button class="segmented-btn" data-filter="4">4</button>
                <button class="segmented-btn" data-filter="5">5</button>
              </div>
            </div>
          </div>

          <div class="control">
            <div class="control-label">
              <span>HARD FILTER (Shadows)</span>
            </div>
            <div class="segmented-control-container">
              <div class="segmented-control" id="splitHardFilter">
                <button class="segmented-btn" data-filter="00">00</button>
                <button class="segmented-btn" data-filter="0">0</button>
                <button class="segmented-btn" data-filter="1">1</button>
                <button class="segmented-btn" data-filter="2">2</button>
                <button class="segmented-btn" data-filter="3">3</button>
                <button class="segmented-btn" data-filter="4">4</button>
                <button class="segmented-btn" data-filter="5">5</button>
              </div>
            </div>
          </div>

          <div class="control">
            <div class="control-label">
              <span>SHADOW BURN PERCENTAGE</span>
              <span class="value-display" id="burnPercentValue">50%</span>
            </div>
            <input
              type="range"
              class="slider"
              id="burnPercentSlider"
              min="0"
              max="100"
              step="5"
              value="50"
            />
          </div>

          <div class="info-box">
            <div class="label-sm">BASE TIMES (Before Filters)</div>
            <div class="value-display" id="splitTimeDisplay">-- s</div>
            <div class="label-sm" style="margin-top: 6px">
              HIGHLIGHTS (Soft + Factor)
            </div>
            <div class="value-display" id="softResult">-- s</div>
            <div class="label-sm" style="margin-top: 6px">
              SHADOWS (Hard + Factor)
            </div>
            <div class="value-display" id="hardResult">-- s</div>
            <div class="label-sm" style="margin-top: 6px; font-weight: bold">
              TOTAL EXPOSURE
            </div>
            <div class="value-display" id="totalResult" style="font-size: 1rem">
              -- s
            </div>
          </div>

          <div class="settings-btn-group">
            <button class="settings-btn primary" id="sendToCalc">
              Send to CALC
            </button>
          </div>
        </div>

        <!-- Split-Grade Presets -->
        <section class="collapsible" data-id="split-presets">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">SPLIT-GRADE PRESETS</div>
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer" style="margin-top: 15px">
              <div class="title-md">Split-Grade Presets</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Preset Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="splitPresetName"
                    placeholder="Enter preset name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label"> </div>
                  <button class="settings-btn" id="saveSplitPreset">
                    Save Current as Preset
                  </button>
                </div>
              </div>

              <div class="title-md">Saved Presets</div>
              <div class="shelf-life-list" id="splitPresetList">
                <!-- Split presets will be listed here -->
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn danger" id="clearSplitPresets">
                  Clear All
                </button>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Chart Tab with Incremental Time Column -->
      <div id="chart" class="tab-content">
        <!-- BASE TIME slider removed per user request -->
        <div
          class="chart-note"
          role="note"
          title="This chart uses the main BASE TIME control in the CALC tab."
          aria-label="Chart uses base time from CALC"
          style="
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
          "
        >
          ⓘ Uses BASE TIME from CALC tab
        </div>

        <div style="overflow-x: auto; margin-bottom: 10px">
          <table
            class="time-table"
            id="timeTable"
            style="margin-left: -6px; margin-right: -6px"
          >
            <thead>
              <tr>
                <th>STOP</th>
                <th>TOTAL TIME</th>
                <th>+/- FROM BASE</th>
                <th>INCREMENT</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- F-Stop Test Strip Generator Tab -->
      <div id="fstop-test" class="tab-content">
        <div class="control">
          <div class="control-label">
            <span>BASE TIME</span>
            <span class="value-display" id="testBaseValue">10.0s</span>
          </div>
          <input
            type="range"
            min="1"
            max="50"
            step="0.5"
            value="10"
            class="slider"
            id="testBaseSlider"
          />
        </div>

        <div class="control">
          <div class="control-label">
            <span>INCREMENT (in stops)</span>
            <span class="value-display" id="testIncrementValue">⅓ stop</span>
          </div>
          <input
            type="range"
            min="1"
            max="9"
            step="1"
            value="1"
            class="slider"
            id="testIncrementSlider"
          />

          <!-- Dynamic ruler populated by JS based on denominator -->
          <div
            id="testIncrementRuler"
            style="
              display: flex;
              justify-content: space-between;
              margin-top: 5px;
              padding: 0 5px;
            "
          >
            <!-- labels populated by JS -->
          </div>

          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="testIncrementSeg"
              role="tablist"
              aria-label="Test stop increment"
            >
              <button
                type="button"
                class="segmented-btn"
                data-denom="1"
                aria-pressed="false"
              >
                1
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="2"
                aria-pressed="false"
              >
                1/2
              </button>
              <button
                type="button"
                class="segmented-btn active"
                data-denom="3"
                aria-pressed="true"
              >
                1/3
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="4"
                aria-pressed="false"
              >
                1/4
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-denom="6"
                aria-pressed="false"
              >
                1/6
              </button>
            </div>
          </div>
        </div>

        <div class="control">
          <div class="control-label">
            <span>NUMBER OF STEPS</span>
            <span class="value-display" id="testStepsValue">6</span>
          </div>
          <input
            type="range"
            min="3"
            max="12"
            step="1"
            value="6"
            class="slider"
            id="testStepsSlider"
          />
        </div>

        <!-- NEW: Method Selector -->
        <div class="control">
          <div class="control-label">
            <span>METHOD</span>
            <span class="value-display" id="testMethodValue">Cumulative</span>
          </div>
          <div class="settings-group" style="margin-top: 5px; margin-bottom: 0">
            <button class="toggle-btn active" data-method="cumulative">
              Cumulative
            </button>
            <button class="toggle-btn" data-method="incremental">
              Incremental
            </button>
          </div>
        </div>

        <!-- NEW: Auto Advance Toggle -->
        <div class="control">
          <div class="control-label">
            <span>AUTO ADVANCE</span>
            <span class="value-display" id="autoAdvanceValue">OFF</span>
          </div>
          <label class="switch">
            <input type="checkbox" id="autoAdvanceToggle" />
            <span class="slider-switch"></span>
          </label>
          <div
            style="
              font-size: 0.6rem;
              color: var(--text-secondary);
              margin-top: 3px;
              text-align: center;
            "
          >
            <span id="autoAdvanceDescription">Pause after each step</span>
          </div>
        </div>

        <div class="info-box">
          <div class="label-sm">TEST STRIP SEQUENCE</div>
          <div
            class="value-display"
            id="testSequenceInfo"
            style="font-size: 1.2rem"
          >
            6 steps × ⅓ stop
          </div>
          <div class="label-sm" id="testTimeRange">10.00s to 31.75s</div>
        </div>

        <!-- UPDATED: Instructions Panel with Auto Advance Info -->
        <div class="incremental-timer">
          <div class="title-sm" style="text-align: center">INSTRUCTIONS</div>
          <div id="methodInstructions">
            <div
              class="cumulative-instructions"
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                line-height: 1.3;
                padding: 5px;
              "
            >
              <strong>CUMULATIVE METHOD:</strong><br />
              • Expose each strip for its total time<br />
              •
              <span id="cumulativeAdvanceText"
                >Auto-advance: OFF - Press Next Step between exposures</span
              >
            </div>
            <div
              class="incremental-instructions"
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                line-height: 1.3;
                padding: 5px;
                display: none;
              "
            >
              <strong>INCREMENTAL METHOD:</strong><br />
              • First strip: expose for base time<br />
              • Slide mask, expose next strip for difference<br />
              •
              <span id="incrementalAdvanceText"
                >Auto-advance: OFF - Press Next Step after sliding mask</span
              >
            </div>
          </div>
          <div
            style="
              margin-top: 5px;
              font-size: 0.6rem;
              color: var(--accent);
              text-align: center;
            "
          >
            <span id="autoAdvanceStatus">Current: Manual Advance</span>
          </div>
        </div>

        <!-- Visual Test Strip Preview -->
        <div class="incremental-timer">
          <div class="title-sm" style="text-align: center">
            TEST STRIP LAYOUT
          </div>
          <div class="test-strip-preview" id="testStripPreview">
            <!-- Will be populated by JavaScript -->
          </div>
          <div
            class="sound-controls"
            style="justify-content: space-between; align-items: center"
          >
            <div class="shelf-life-actions" style="align-items: center">
              <label class="switch">
                <input type="checkbox" id="previewMode" checked />
                <span class="slider-switch"></span>
              </label>
              <span class="setting-label">Show Times</span>
            </div>
          </div>

          <!-- Transfer Destination Selection -->
          <div style="margin-top: 10px; text-align: center">
            <div
              style="
                font-size: 0.65rem;
                color: var(--text-secondary);
                margin-bottom: 5px;
              "
            >
              Click test steps to apply time to:
            </div>
            <div class="segmented-control-container">
              <div
                class="segmented-control"
                id="transferDestinationSeg"
                role="tablist"
                aria-label="Transfer destination"
              >
                <button
                  type="button"
                  class="segmented-btn"
                  id="transferToCalc"
                  data-destination="calc"
                  aria-pressed="false"
                  style="min-width: 80px; font-size: 0.75rem"
                >
                  → CALC
                </button>
                <button
                  type="button"
                  class="segmented-btn"
                  id="transferToSplit"
                  data-destination="split"
                  aria-pressed="false"
                  style="min-width: 80px; font-size: 0.75rem"
                >
                  → SPLIT
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Test Strip Timer Controls -->
        <div class="incremental-timer" style="margin-top: 10px">
          <div class="title-sm" id="testTimerStatus" style="text-align: center">
            READY FOR TEST STRIP
          </div>
          <div class="test-timer-display">
            <div
              class="shelf-life-actions"
              style="
                flex: 1;
                align-items: center;
                justify-content: center;
                text-align: center;
                gap: 0;
              "
            >
              <div class="label-sm">Current Step</div>
              <div class="value-display" id="currentStepDisplay">1/6</div>
            </div>
            <div class="timer-display" id="testTimerDisplay">10.00</div>
            <div
              class="shelf-life-actions"
              style="
                flex: 1;
                align-items: center;
                justify-content: center;
                text-align: center;
                gap: 0;
              "
            >
              <div class="label-sm">Time</div>
              <div class="value-display" id="currentTimeDisplay">10.00s</div>
            </div>
          </div>

          <div class="test-progress-container">
            <div class="test-progress-bar" id="testProgressBar">
              <div class="progress-bar" id="progressFill"></div>
            </div>
            <div class="progress-labels">
              <span id="progressStart">10.0s</span>
              <span id="progressMiddle">19.0s</span>
              <span id="progressEnd">31.8s</span>
            </div>
          </div>

          <div class="settings-btn-group">
            <button class="exp-btn" id="startTestStrip">
              Start Test Strip
            </button>
            <button class="exp-btn" id="stopTestTimer" disabled>Stop</button>
            <button class="exp-btn" id="resetTestTimer">Reset</button>
          </div>

          <!-- Notes Input for Test Strip -->
          <div class="control">
            <div class="control-label">
              <span>Notes for this test strip</span>
            </div>
            <input
              type="text"
              id="testNotesInput"
              class="settings-input"
              placeholder="e.g., Portrait - find base exposure"
              style="width: 100%"
            />
          </div>

          <!-- Test Strip Information -->
          <div class="exp-info">
            <div class="info-box">
              <div class="label-sm">Step Size</div>
              <div class="value-display" id="stepSizeDisplay">0.0 stops</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Current Stop</div>
              <div class="value-display" id="currentStopDisplay">0.0</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Time Multiplier</div>
              <div class="value-display" id="timeMultiplierDisplay">1.00×</div>
            </div>
            <div class="info-box">
              <div class="label-sm">Total Time</div>
              <div class="value-display" id="totalTestTimeDisplay">68.3s</div>
            </div>
          </div>

          <!-- Test Strip Profiles Section -->
          <section class="collapsible" data-id="test-strip-profiles">
            <button class="collapsible-header" aria-expanded="false">
              <div class="collapsible-title">TEST STRIP PROFILES</div>
            </button>
            <div class="collapsible-content">
              <div class="incremental-timer" style="margin-top: 15px">
                <div class="title-md">Test Strip Profiles</div>

                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Profile Name</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="testStripProfileName"
                      placeholder="Enter profile name"
                      maxlength="20"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label"> </div>
                    <button class="settings-btn" id="saveTestStripProfile">
                      Save Current as Profile
                    </button>
                  </div>
                </div>

                <div class="title-md">Saved Test Strip Profiles</div>
                <div class="shelf-life-list" id="testStripProfileList">
                  <!-- Test strip profiles will be listed here -->
                </div>

                <div class="settings-btn-group">
                  <button
                    class="settings-btn danger"
                    id="clearTestStripProfiles"
                  >
                    Clear All
                  </button>
                </div>
              </div>
            </div>
          </section>
        </div>
      </div>

      <!-- UPDATED: CHEMICAL MANAGEMENT TAB -->
      <div id="chemical" class="tab-content">
        <!-- Mix Calculator -->
        <section class="collapsible" data-id="chemical-mix">
          <button class="collapsible-header" aria-expanded="false">
            CHEMICAL MIX CALCULATOR
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                CHEMICAL MIX CALCULATOR
              </div>

              <div class="control">
                <div class="control-label">
                  <span>TOTAL VOLUME</span>
                  <span class="value-display" id="totalVolumeValue"
                    >1000ml</span
                  >
                </div>
                <input
                  type="range"
                  min="100"
                  max="5000"
                  step="50"
                  value="1000"
                  class="slider"
                  id="totalVolumeSlider"
                />
              </div>

              <div
                class="title-sm"
                style="
                  text-align: center;
                  font-size: 0.75rem;
                  margin-bottom: 8px;
                "
              >
                DILUTION RATIO
              </div>
              <div class="dilution-selector">
                <button class="toggle-btn active" data-ratio="1+9">
                  1+9 (1:10)
                </button>
                <button class="toggle-btn" data-ratio="1+14">
                  1+14 (1:15)
                </button>
                <button class="toggle-btn" data-ratio="1+19">
                  1+19 (1:20)
                </button>
                <button class="toggle-btn" data-ratio="1+24">
                  1+24 (1:25)
                </button>
                <button class="toggle-btn" data-ratio="1+29">
                  1+29 (1:30)
                </button>
                <button class="toggle-btn" data-ratio="1+39">
                  1+39 (1:40)
                </button>
              </div>

              <div
                class="title-sm"
                style="
                  text-align: center;
                  font-size: 0.75rem;
                  margin-top: 10px;
                  margin-bottom: 5px;
                "
              >
                OR CUSTOM RATIO
              </div>
              <div class="custom-dilution">
                <input
                  type="number"
                  min="1"
                  max="100"
                  value="1"
                  class="settings-input"
                  id="customStockParts"
                  placeholder="Stock"
                />
                <div style="color: var(--text-secondary); align-self: center">
                  +
                </div>
                <input
                  type="number"
                  min="1"
                  max="100"
                  value="9"
                  class="settings-input"
                  id="customWaterParts"
                  placeholder="Water"
                />
              </div>

              <div
                class="incremental-timer"
                style="background: var(--panel-light); margin-bottom: 0"
              >
                <div
                  class="title-sm"
                  style="text-align: center; font-size: 0.75rem"
                >
                  MIXING INSTRUCTIONS
                </div>
                <div class="chemical-results-grid">
                  <div class="info-box">
                    <div class="label-sm">STOCK SOLUTION</div>
                    <div
                      class="value-display"
                      id="stockVolume"
                      style="font-size: 1.2rem"
                    >
                      100ml
                    </div>
                  </div>
                  <div class="info-box">
                    <div class="label-sm">WATER</div>
                    <div
                      class="value-display"
                      id="waterVolume"
                      style="font-size: 1.2rem"
                    >
                      900ml
                    </div>
                  </div>
                </div>
                <div
                  style="
                    font-size: 0.6rem;
                    color: --text-secondary;
                    text-align: center;
                    margin-top: 8px;
                  "
                >
                  Add stock to water, not water to stock
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Chemical Presets Section - NEW -->
        <section class="collapsible" data-id="chemical-presets">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">CHEMICAL PRESETS</div>
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer" style="margin-top: 15px">
              <div class="title-md">Chemical Presets</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Preset Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="chemicalPresetName"
                    placeholder="Enter preset name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn" id="saveChemicalPreset">
                    Save Current as Preset
                  </button>
                </div>
              </div>

              <div class="title-md">Saved Chemical Presets</div>
              <div class="shelf-life-list" id="chemicalPresetList">
                <!-- Chemical presets will be listed here -->
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn danger" id="clearChemicalPresets">
                  Clear All
                </button>
              </div>
            </div>
          </div>
        </section>

        <!-- UPDATED: Developer Capacity Tracker with Paper Area Calculations -->
        <section class="collapsible" data-id="capacity-tracker">
          <button class="collapsible-header" aria-expanded="false">
            DEVELOPER CAPACITY TRACKER
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                DEVELOPER CAPACITY TRACKER
              </div>

              <div class="control">
                <div class="control-label">
                  <span>CAPACITY (m² per liter)</span>
                  <span class="value-display" id="capacityValue">0.5</span>
                </div>
                <input
                  type="range"
                  min="0.1"
                  max="40"
                  step="0.1"
                  value="0.5"
                  class="slider"
                  id="capacitySlider"
                />
              </div>

              <div class="control">
                <div class="control-label">
                  <span>TRAY VOLUME (ml)</span>
                  <span class="value-display" id="trayVolumeValue">1000</span>
                </div>
                <input
                  type="range"
                  min="100"
                  max="5000"
                  step="100"
                  value="1000"
                  class="slider"
                  id="trayVolumeSlider"
                />
              </div>

              <!-- NEW: Paper Size Selector -->
              <div class="paper-size-selector">
                <div class="dilution-selector">
                  <button class="toggle-btn" data-size="0.011">
                    3.5x5" (0.011 m²)
                  </button>
                  <button class="toggle-btn active" data-size="0.013">
                    4x5" (0.013 m²)
                  </button>
                  <button class="toggle-btn" data-size="0.023">
                    5x7" (0.023 m²)
                  </button>
                  <button class="toggle-btn" data-size="0.052">
                    8x10" (0.052 m²)
                  </button>
                  <!-- CHANGED -->
                  <button class="toggle-btn" data-size="0.099">
                    11x14" (0.099 m²)
                  </button>
                  <!-- CHANGED -->
                  <button class="toggle-btn" data-size="0.206">
                    16x20" (0.206 m²)
                  </button>
                  <!-- CHANGED -->
                </div>
                <div class="custom-dilution">
                  <!-- Chemical tab capacity tracker custom paper size -->
                  <input
                    type="number"
                    min="0.001"
                    max="1"
                    step="0.001"
                    value="0.052"
                    class="settings-input"
                    id="customPaperSize"
                    placeholder="Custom m²"
                  />
                  <button class="toggle-btn" id="useCustomSize">Use</button>
                </div>
              </div>

              <div class="info-box" style="margin: 10px 0">
                <div class="label-sm">MAX PRINTS THIS BATCH</div>
                <div
                  class="value-display"
                  id="maxPrintsValue"
                  style="font-size: 1.2rem"
                >
                  6
                </div>
                <div class="label-sm" id="printsRemaining">
                  6 prints remaining (0.48 m²)
                </div>
              </div>

              <div class="progress-container">
                <div
                  class="progress-bar"
                  id="capacityProgressBar"
                  style="width: 0%"
                ></div>
              </div>
              <div class="progress-labels">
                <span>0</span>
                <span id="capacityMiddleLabel">3</span>
                <span id="capacityMaxLabel">6</span>
              </div>

              <div class="capacity-controls">
                <button class="settings-btn" id="addPrint">+1 Print</button>
                <button class="settings-btn" id="add5Prints">+5 Prints</button>
                <button class="settings-btn" id="resetPrints">Reset</button>
              </div>

              <div class="exp-info" style="margin-top: 12px">
                <div class="info-box">
                  <div class="label-sm">Prints Done</div>
                  <div class="value-display" id="printsDoneValue">0</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">Area Used</div>
                  <div class="value-display" id="areaUsedValue">0.00 m²</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">% Used</div>
                  <div class="value-display" id="percentUsedValue">0%</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">Status</div>
                  <div class="value-display" id="capacityStatus">Fresh</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- UPDATED: Shelf Life Tracker with Custom Chemical Name -->
        <section class="collapsible" data-id="shelf-life">
          <button class="collapsible-header" aria-expanded="false">
            SHELF LIFE TRACKER
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                SHELF LIFE TRACKER
              </div>

              <div class="settings-group" style="margin-top: 10px">
                <div class="settings-item">
                  <div class="settings-label">Chemical</div>
                  <select class="settings-input" id="chemicalType">
                    <option value="developer">Developer</option>
                    <option value="stopbath">Stop Bath</option>
                    <option value="fixer">Fixer</option>
                    <option value="hypoclear">Hypo Clear</option>
                    <option value="photof">Photo Wash</option>
                    <option value="custom">Custom</option>
                  </select>
                </div>
                <div
                  class="settings-item"
                  id="customChemicalNameContainer"
                  style="display: none"
                >
                  <div class="settings-label">Custom Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="customChemicalName"
                    placeholder="Enter chemical name"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Shelf Life (days)</div>
                  <input
                    type="number"
                    min="1"
                    max="365"
                    value="30"
                    class="settings-input"
                    id="shelfLifeDays"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Date Mixed/Opened</div>
                  <input
                    type="date"
                    class="settings-input"
                    id="chemicalDate"
                    value=""
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button
                    class="settings-btn"
                    id="addChemical"
                    style="margin-top: 0"
                  >
                    Add Chemical
                  </button>
                </div>
              </div>

              <div
                class="title-sm"
                style="text-align: center; font-size: 0.75rem; margin-top: 15px"
              >
                ACTIVE CHEMICALS
              </div>
              <div class="shelf-life-list" id="shelfLifeList">
                <!-- Chemicals will be listed here -->
              </div>

              <div style="margin-top: 10px; text-align: center">
                <button class="settings-btn" id="clearExpired">
                  Clear Expired
                </button>
                <div
                  style="
                    font-size: 0.6rem;
                    color: var(--text-secondary);
                    margin-top: 5px;
                  "
                >
                  Red items expired, orange expire in 3 days
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Timer Tab with Photo Wash Toggle AND Timer Profiles -->
      <div id="timer" class="tab-content">
        <div class="timer-grid">
          <!-- Developer Timer -->
          <div class="timer-box" id="timerDev">
            <div class="title-sm">Developer</div>
            <div class="time-display" id="displayDev">01:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Dev" data-action="minus">
                  -1s
                </button>
                <button class="timer-btn" data-timer="Dev" data-action="plus">
                  +1s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnDev">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Dev"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Stop Bath Timer -->
          <div class="timer-box" id="timerStop">
            <div class="title-sm">Stop Bath</div>
            <div class="time-display" id="displayStop">00:30</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Stop" data-action="minus">
                  -1s
                </button>
                <button class="timer-btn" data-timer="Stop" data-action="plus">
                  +1s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnStop">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Stop"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Fixer Timer -->
          <div class="timer-box" id="timerFix">
            <div class="title-sm">Fixer</div>
            <div class="time-display" id="displayFix">05:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Fix" data-action="minus">
                  -1s
                </button>
                <button class="timer-btn" data-timer="Fix" data-action="plus">
                  +1s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnFix">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Fix"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>

          <!-- Photo Wash Timer -->
          <div class="timer-box" id="timerFlo">
            <div class="title-sm">Photo Wash</div>
            <div class="time-display" id="displayFlo">01:00</div>
            <div class="timer-controls-2">
              <div class="adjust-row">
                <button class="timer-btn" data-timer="Flo" data-action="minus">
                  -1s
                </button>
                <button class="timer-btn" data-timer="Flo" data-action="plus">
                  +1s
                </button>
              </div>
              <div class="adjust-row">
                <button class="timer-btn" id="btnFlo">Start</button>
                <button
                  class="timer-btn"
                  data-timer="Flo"
                  data-action="reset"
                  disabled
                >
                  Reset
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="settings-btn-group">
          <button class="exp-btn" id="startAll">Start All</button>
          <button class="exp-btn" id="resetAll">Reset All</button>
        </div>

        <!-- Factorial Development Tool -->
        <section class="collapsible" data-id="factorial-development">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">FACTORIAL DEVELOPMENT</div>
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer" style="margin-top: 15px">
              <div class="info-box">
                <div class="label-sm">CURRENT MULTIPLIER</div>
                <div id="factorialMultiplier" class="value-display">
                  Not Set
                </div>
                <div class="label-sm" id="factorialStatus">
                  Set Dev time and start first print
                </div>
              </div>

              <div class="settings-btn-group">
                <button class="exp-btn" id="markBaseline">MARK BASELINE</button>
              </div>

              <div class="settings-btn-group">
                <button class="exp-btn" id="blackPoint">BLACK POINT</button>
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn" id="resetMultiplier">
                  Reset Multiplier
                </button>
              </div>

              <div
                class="label-sm"
                style="margin-top: 8px; text-align: center; line-height: 1.4"
              >
                <strong>Workflow:</strong><br />
                1. Set Dev time → Start → Mark Baseline when black appears<br />
                2. Next prints → Black Point when black appears → Auto-adjusts
                timer
              </div>
            </div>
          </div>
        </section>

        <!-- Timer Profiles Section MOVED from SETTINGS tab -->
        <section class="collapsible" data-id="timer-profiles">
          <button class="collapsible-header" aria-expanded="false">
            <div class="collapsible-title">TIMER PROFILES</div>
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer" style="margin-top: 15px">
              <div class="title-md">Timer Profiles</div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Profile Name</div>
                  <input
                    type="text"
                    class="settings-input"
                    id="timerProfileName"
                    placeholder="Enter profile name"
                    maxlength="20"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn" id="saveTimerProfile">
                    Save Current as Profile
                  </button>
                </div>
              </div>

              <div class="title-md">Saved Timer Profiles</div>
              <div class="shelf-life-list" id="timerProfileList">
                <!-- Timer profiles will be listed here -->
              </div>

              <div class="settings-btn-group">
                <button class="settings-btn danger" id="clearTimerProfiles">
                  Clear All
                </button>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Add this new tab content section after the SETTINGS tab content -->
      <div id="relay" class="tab-content">
        <div class="incremental-timer">
          <div class="settings-section">
            <div class="title-md">Relay Control (Manual)</div>
            <div
              class="incremental-timer"
              style="background: var(--panel-light); margin-bottom: 0"
            >
              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 1 (GP14)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay1Name"
                      value="Enlarger Timer"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="1"
                      data-gpio="14"
                      id="toggleRelay1"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 2 (GP15)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay2Name"
                      value="Safelight"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="2"
                      data-gpio="15"
                      id="toggleRelay2"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 3 (GP16)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay3Name"
                      value="Ventilation"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="3"
                      data-gpio="16"
                      id="toggleRelay3"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>

              <div class="shelf-life-item" style="display: block">
                <div class="settings-group">
                  <div class="settings-item">
                    <div class="settings-label">Relay 4 (GP17)</div>
                    <input
                      type="text"
                      class="settings-input"
                      id="relay4Name"
                      value="White Light"
                      placeholder="Relay name"
                    />
                  </div>
                  <div class="settings-item">
                    <div class="settings-label">State</div>
                    <button
                      class="settings-btn"
                      style="min-width: 80px"
                      data-relay="4"
                      data-gpio="17"
                      id="toggleRelay4"
                    >
                      OFF
                    </button>
                  </div>
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <button class="settings-btn" id="allRelaysOn">All ON</button>
                </div>
                <div class="settings-item">
                  <button class="settings-btn" id="allRelaysOff">
                    All OFF
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Temperature Control Section -->
          <div class="settings-section">
            <div class="title-md">Temperature Control</div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Enable Temperature Control</div>
                <label class="switch">
                  <input type="checkbox" id="temperatureControlToggle" />
                  <span class="slider-switch"></span>
                </label>
              </div>
            </div>

            <!-- Temperature Control Content (hidden when disabled) -->
            <div id="temperatureControlContent" style="display: none">
              <div class="info-box">
                <div class="label-sm">Current Temperature</div>
                <div
                  class="value-display"
                  id="temperatureDisplay"
                  style="font-size: 1.8em"
                >
                  -- °C
                </div>
                <div
                  class="label-sm"
                  id="temperatureStatus"
                  style="margin-top: 4px"
                >
                  Disabled
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Target (°C)</div>
                  <input
                    type="number"
                    id="targetTemperatureInput"
                    class="settings-input"
                    placeholder="20.0"
                    min="15"
                    max="50"
                    step="0.5"
                    value="20.0"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <button class="settings-btn primary" id="setTargetTempBtn">
                    Set Target
                  </button>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Heating (GP16)</div>
                  <div id="relayStatusDisplay" class="value-display">OFF</div>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Dead Zone</div>
                  <div id="hysteresisInfo" class="value-display">±0.5°C</div>
                </div>
              </div>

              <div class="label-sm" style="margin-top: 12px">
                Temperature History (15 min)
              </div>
              <canvas
                id="temperatureChart"
                height="150"
                style="
                  width: 100%;
                  border: 1px solid var(--border);
                  background: var(--bg-darker);
                  margin-top: 4px;
                "
              ></canvas>

              <div id="dataPointsInfo" class="label-sm" style="margin-top: 8px">
                0 readings
              </div>

              <div
                id="temperatureConnectionStatus"
                class="info-box"
                style="margin-top: 12px; display: none; background: #ffeaa7"
              >
                <div class="label-sm" style="color: #d63031">
                  ⚠️ Sensor Disconnected - Relay OFF
                </div>
              </div>
            </div>
          </div>

          <div class="settings-section">
            <div class="title-md">Controller Manager</div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Server IP (auto-detected)</div>
                <input
                  type="text"
                  class="settings-input"
                  id="relayServerIP"
                  placeholder="Auto-detected from page URL"
                  value=""
                  readonly
                />
              </div>
              <div class="settings-item">
                <div class="settings-label">Server Port</div>
                <input
                  type="number"
                  class="settings-input"
                  id="relayServerPort"
                  value="80"
                  readonly
                />
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Test Connection</div>
                <button class="settings-btn" id="testRelayConnection">
                  Test
                </button>
              </div>
              <div class="settings-item">
                <div class="settings-label">Status</div>
                <div
                  id="relayStatus"
                  style="color: var(--text-secondary); font-size: 0.8rem"
                >
                  Not connected
                </div>
              </div>
            </div>
          </div>

          <!-- WiFi Configuration Section (Pico 2 W) -->
          <div class="settings-section">
            <div class="title-md">WiFi Configuration</div>
            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                margin-bottom: 8px;
              "
            >
              Connect to a WiFi router for mDNS access (darkroom.local)
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">WiFi SSID</div>
                <input
                  type="text"
                  class="settings-input"
                  id="wifiSSID"
                  placeholder="Your WiFi network name"
                />
              </div>
              <div class="settings-item">
                <div class="settings-label">WiFi Password</div>
                <input
                  type="password"
                  class="settings-input"
                  id="wifiPassword"
                  placeholder="WiFi password"
                />
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <button class="settings-btn primary" id="connectWifi">
                  Connect to WiFi
                </button>
              </div>
              <div class="settings-item">
                <div class="settings-label">WiFi Status</div>
                <div
                  id="wifiStatus"
                  style="color: var(--text-secondary); font-size: 0.8rem"
                >
                  AP Mode (192.168.4.1)
                </div>
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <button
                  class="settings-btn"
                  id="forceHotspotMode"
                  style="background: var(--accent-color)"
                >
                  Force Hotspot Mode
                </button>
              </div>
              <div class="settings-item">
                <button class="settings-btn danger" id="clearWifiCredentials">
                  Clear WiFi Credentials
                </button>
              </div>
            </div>
            <div
              style="
                font-size: 0.65rem;
                color: var(--text-secondary);
                margin-top: 8px;
              "
            >
              Note: After connecting to WiFi, access via darkroom.local
            </div>
          </div>
        </div>
      </div>

      <!-- UPDATED: Settings Tab WITH Countdown Settings AND Auto Advance -->
      <div id="settings" class="tab-content">
        <div class="incremental-timer">
          <!-- Fullscreen Section -->
          <div class="settings-section">
            <div class="title-md">Display</div>
            <button
              class="settings-btn primary"
              id="toggleFullscreen"
              style="
                padding: 8px 16px;
                text-transform: uppercase;
                margin-bottom: 1rem;
              "
            >
              Toggle Fullscreen
            </button>
            <div class="title-md">Color Scheme</div>
            <div class="dilution-selector">
              <button class="toggle-btn active" data-scheme="dark">
                Darkroom (Default)
              </button>
              <button class="toggle-btn" data-scheme="light">Day</button>
              <button class="toggle-btn" data-scheme="day">Night</button>
            </div>
          </div>

          <!-- Updates Section -->
          <div class="settings-section">
            <div class="title-md">Updates</div>
            <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 8px;">
              Check for new versions from GitHub and update automatically
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <div class="settings-label">Current Version</div>
                <div
                  id="currentAppVersion"
                  style="color: var(--text-secondary); font-size: 0.8rem; padding: 6px 0;"
                >
                  Loading...
                </div>
              </div>
              <div class="settings-item">
                <div class="settings-label">Latest Version</div>
                <div
                  id="latestAppVersion"
                  style="color: var(--text-secondary); font-size: 0.8rem; padding: 6px 0;"
                >
                  Unknown
                </div>
              </div>
            </div>
            <div class="settings-group">
              <div class="settings-item">
                <button class="settings-btn primary" id="checkUpdatesBtn">
                  Check for Updates
                </button>
              </div>
              <div class="settings-item">
                <div id="updateStatus" style="color: var(--text-secondary); font-size: 0.8rem; min-height: 20px;">
                  Ready
                </div>
              </div>
            </div>
            <div id="updateProgress" style="display: none; margin-top: 8px;">
              <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 4px;">Progress:</div>
              <div style="width: 100%; height: 4px; background: var(--bg-secondary); border-radius: 2px; overflow: hidden;">
                <div id="updateProgressBar" style="width: 0%; height: 100%; background: var(--accent-color); transition: width 0.3s ease;"></div>
              </div>
              <div id="updateProgressText" style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 4px; text-align: center;">0%</div>
            </div>
            <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px;">
              Note: Pico will restart automatically after a successful update
            </div>
          </div>

          <!-- GLOBAL SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="global-settings">
            <button class="collapsible-header" aria-expanded="false">
              GLOBAL SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Base Time (s)</div>
                  <input
                    type="number"
                    min="1"
                    max="50"
                    step="0.5"
                    class="settings-input"
                    id="settingBaseTime"
                    value="10"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Stop Increment</div>
                  <select id="settingStopIncrement" class="settings-input">
                    <option value="1">1 stop</option>
                    <option value="2">1/2 stop</option>
                    <option value="3">1/3 stop</option>
                    <option value="4">1/4 stop</option>
                    <option value="6">1/6 stop</option>
                  </select>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Countdown Delay (s)</div>
                  <input
                    type="number"
                    min="0"
                    max="30"
                    step="1"
                    class="settings-input"
                    id="settingCountdownDelay"
                    value="5"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Countdown Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingCountdownBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Beep Pattern</div>
                  <select class="settings-input" id="settingCountdownPattern">
                    <option value="every-second">Beep every second</option>
                    <option value="last3">Beep last 3 seconds only</option>
                    <option value="last5">Beep last 5 seconds only</option>
                    <option value="none">No beeps</option>
                  </select>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Test Pattern</div>
                  <button
                    class="settings-btn"
                    id="testCountdownBeep"
                    style="font-size: 0.7rem; padding: 4px 8px"
                  >
                    Test Beep
                  </button>
                </div>
              </div>
            </div>
          </section>

          <!-- CALC SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="calc-settings">
            <button class="collapsible-header" aria-expanded="false">
              CALC SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Base Time Min (s)</div>
                  <input
                    type="number"
                    id="baseTimeMin"
                    class="settings-input"
                    min="0.1"
                    max="10"
                    step="0.1"
                    value="0.4"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Base Time Max (s)</div>
                  <input
                    type="number"
                    id="baseTimeMax"
                    class="settings-input"
                    min="10"
                    max="300"
                    step="1"
                    value="50"
                  />
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Calc 3s Beep</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingCalcWarningBeep"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Calc End Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingCalcEndBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>
            </div>
          </section>

          <!-- TEST STRIP SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="test-strip-settings">
            <button class="collapsible-header" aria-expanded="false">
              TEST STRIP SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Auto Advance</div>
                  <label class="switch">
                    <input type="checkbox" id="settingAutoAdvance" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Auto Advance Delay (s)</div>
                  <input
                    type="number"
                    min="0"
                    max="30"
                    step="1"
                    class="settings-input"
                    id="settingAutoAdvanceDelay"
                    value="1"
                  />
                </div>
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Test Base Time Min (s)</div>
                  <input
                    type="number"
                    id="testBaseTimeMin"
                    class="settings-input"
                    min="0.5"
                    max="10"
                    step="0.5"
                    value="1"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Test Base Time Max (s)</div>
                  <input
                    type="number"
                    id="testBaseTimeMax"
                    class="settings-input"
                    min="10"
                    max="300"
                    step="1"
                    value="50"
                  />
                </div>
              </div>
            </div>
          </section>

          <!-- TIMER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="timer-settings">
            <button class="collapsible-header" aria-expanded="false">
              TIMER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Developer (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="600"
                    step="5"
                    class="settings-input time-input"
                    id="settingDevTime"
                    value="60"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Stop Bath (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="300"
                    step="5"
                    class="settings-input time-input"
                    id="settingStopTime"
                    value="30"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Default Fixer (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="600"
                    step="5"
                    class="settings-input time-input"
                    id="settingFixTime"
                    value="300"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Default Photo Wash (s)</div>
                  <input
                    type="number"
                    min="5"
                    max="300"
                    step="5"
                    class="settings-input time-input"
                    id="settingFloTime"
                    value="60"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Timer 10s Beep</div>
                  <label class="switch">
                    <input
                      type="checkbox"
                      id="settingTimerWarningBeep"
                      checked
                    />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Timer End Beep</div>
                  <label class="switch">
                    <input type="checkbox" id="settingTimerEndBeep" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>
            </div>
          </section>

          <!-- CONTROLLER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="controller-settings">
            <button class="collapsible-header" aria-expanded="false">
              CONTROLLER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="settings-group">
                <div class="settings-item">
                  <div
                    id="safelightAutoOffStatus"
                    style="color: var(--text-secondary); font-size: 0.8rem"
                  >
                    Loading...
                  </div>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Safelight Auto-Off</div>
                  <label class="switch">
                    <input type="checkbox" id="safelightAutoOff" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">&nbsp;</div>
                  <div
                    style="
                      font-size: 0.7rem;
                      color: var(--text-secondary);
                      text-align: center;
                    "
                  >
                    Turn off safelight when enlarger is on
                  </div>
                </div>
              </div>

              <div class="title-md" style="margin-top: 12px">
                Auto - Manual Enlarger Control
              </div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Auto-trigger Enlarger</div>
                  <label class="switch">
                    <input type="checkbox" id="autoTriggerRelay" checked />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Test Timer Relay</div>
                  <div style="display: flex; gap: 5px">
                    <input
                      type="number"
                      class="settings-input"
                      id="testTimerSeconds"
                      value="5"
                      min="0.1"
                      max="60"
                      step="0.1"
                      style="flex: 1"
                    />
                    <button class="settings-btn" id="testTimerRelay">
                      Test
                    </button>
                  </div>
                </div>
              </div>

              <div
                style="
                  font-size: 0.7rem;
                  color: var(--text-secondary);
                  margin-top: 10px;
                "
              >
                Note: When enabled, the timer relay (GP14) will automatically
                trigger during countdown timers in CALC and F-STOP TEST tabs.
                Time is sent as a single request with delay parameter for
                maximum accuracy.
              </div>
            </div>
          </section>

          <!-- METER SETTINGS Collapsible Section -->
          <section class="collapsible" data-id="meter-settings">
            <button class="collapsible-header" aria-expanded="false">
              METER SETTINGS
            </button>
            <div class="collapsible-content">
              <div class="title-md">Virtual Proof Stability</div>
              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Stability Detection</div>
                  <label class="switch">
                    <input type="checkbox" id="proofStabilityEnabled" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
                <div class="settings-item">
                  <div class="settings-label">Beep On Stable</div>
                  <label class="switch">
                    <input type="checkbox" id="proofStabilityBeep" />
                    <span class="slider-switch"></span>
                  </label>
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Tolerance (%)</div>
                  <input
                    type="number"
                    id="proofStabilityTolerance"
                    class="settings-input"
                    min="0.5"
                    max="10"
                    step="0.1"
                    value="2.5"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Min Stable Reads</div>
                  <input
                    type="number"
                    id="proofStabilityMinStable"
                    class="settings-input"
                    min="1"
                    max="5"
                    step="1"
                    value="2"
                  />
                </div>
              </div>

              <div class="settings-group">
                <div class="settings-item">
                  <div class="settings-label">Max Wait (ms)</div>
                  <input
                    type="number"
                    id="proofStabilityMaxWait"
                    class="settings-input"
                    min="300"
                    max="3000"
                    step="50"
                    value="900"
                  />
                </div>
                <div class="settings-item">
                  <div class="settings-label">Min Delta (lux)</div>
                  <input
                    type="number"
                    id="proofStabilityMinDelta"
                    class="settings-input"
                    min="0.05"
                    max="5"
                    step="0.05"
                    value="0.2"
                  />
                </div>
              </div>

              <div
                style="
                  font-size: 0.7rem;
                  color: var(--text-secondary);
                  margin-top: 10px;
                "
              >
                Capture starts only after readings stabilize within tolerance.
              </div>
            </div>
          </section>

          <div class="settings-section">
            <button class="settings-btn primary" id="saveGlobalSettings">
              Save All Settings
            </button>
            <div id="allProfilesFeedback" class="json-feedback"></div>
          </div>

          <!-- UPDATED: Profile & Chemical Presets Sharing Section -->
          <div class="settings-section">
            <div class="title-md">Profile & Chemical Presets Sharing</div>
            <div class="settings-btn-group">
              <button class="settings-btn" id="exportAllProfiles">
                Export All Data
              </button>
              <button class="settings-btn" id="importAllProfiles">
                Import All Data
              </button>
            </div>
            <input
              type="file"
              id="allProfilesFileInput"
              accept=".json"
              style="display: none"
            />

            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                margin-top: 8px;
              "
            >
              Exports Timer Profiles, Chemical Presets, Capacity Tracker, and
              Shelf Life Data in one file
            </div>
          </div>

          <!-- Reset Section -->
          <div class="settings-section">
            <div class="title-md">Reset</div>
            <button class="settings-btn danger" id="resetAllSettings">
              Reset All Settings
            </button>
            <div
              style="
                font-size: 0.7rem;
                color: var(--text-secondary);
                text-align: center;
                margin-top: 5px;
              "
            >
              This will reset all settings to defaults and clear all data
            </div>
          </div>
        </div>
      </div>

      <!-- LIGHT METER / CONTRAST ANALYZER Tab -->
      <div id="light-meter" class="tab-content">
        <!-- Mode Selection -->
        <div class="control">
          <div class="control-label">
            <span>METER MODE</span>
            <span class="value-display" id="meterModeValue">Exposure</span>
          </div>
          <div class="segmented-control-container">
            <div
              class="segmented-control"
              id="meterModeSeg"
              role="tablist"
              aria-label="Meter mode selection"
            >
              <button
                type="button"
                class="segmented-btn active"
                data-mode="exposure"
                aria-pressed="true"
              >
                Exposure
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-mode="contrast"
                aria-pressed="false"
              >
                Contrast
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-mode="split"
                aria-pressed="false"
              >
                Split-Grade
              </button>
              <button
                type="button"
                class="segmented-btn"
                data-mode="proof"
                aria-pressed="false"
              >
                Virtual Proof
              </button>
            </div>
          </div>
        </div>

        <!-- Paper & Filter System Selection -->
        <section class="collapsible" data-id="paper-filter-setup">
          <button class="collapsible-header" aria-expanded="true">
            PAPER & FILTER SETUP
          </button>
          <div class="collapsible-content" style="display: block">
            <div class="incremental-timer">
              <!-- Paper Brand Selection -->
              <div class="control">
                <div class="control-label">
                  <span>PAPER BRAND</span>
                </div>
                <div class="settings-group" style="margin-top: 5px">
                  <button
                    class="toggle-btn active"
                    data-brand="ilford"
                    id="btnMeterIlford"
                  >
                    Ilford
                  </button>
                  <button
                    class="toggle-btn"
                    data-brand="foma"
                    id="btnMeterFoma"
                  >
                    FOMA
                  </button>
                </div>
              </div>

              <!-- Ilford Paper Type (visible when Ilford selected) -->
              <div id="meterIlfordPaperSelector" class="control">
                <div class="control-label">
                  <span>ILFORD PAPER TYPE</span>
                </div>
                <select
                  class="settings-input"
                  id="meterIlfordPaperType"
                  style="width: 100%"
                ></select>
              </div>

              <!-- FOMA Paper Type (hidden by default) -->
              <div
                id="meterFomaPaperSelector"
                class="control"
                style="display: none"
              >
                <div class="control-label">
                  <span>FOMA PAPER TYPE</span>
                </div>
                <select
                  class="settings-input"
                  id="meterFomaPaperType"
                  style="width: 100%"
                ></select>
              </div>

              <!-- Calibration Display -->
              <div class="info-box" style="margin-top: 10px">
                <div class="label-sm">CALIBRATION FOR CURRENT PAPER</div>
                <div
                  class="label-sm"
                  id="meterCurrentPaperName"
                  style="
                    font-size: 0.6rem;
                    color: var(--accent);
                    margin-bottom: 4px;
                  "
                >
                  Ilford MG IV RC
                </div>
                <div class="value-display" id="meterCalibrationValue">
                  1000 lux·s
                </div>
                <div
                  class="label-sm"
                  style="margin-top: 4px; font-size: 0.55rem"
                >
                  Auto-saved per paper type
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- EXPOSURE METER MODE -->
        <div id="meterExposureMode" class="meter-mode-content">
          <div class="incremental-timer">
            <div class="title-sm" style="text-align: center">
              EXPOSURE METER
            </div>
            <div
              class="label-sm"
              style="text-align: center; margin-bottom: 10px"
            >
              Place sensor on baseboard under enlarger light
            </div>

            <!-- Sensor Status -->
            <div class="info-box" style="margin-bottom: 10px">
              <div class="label-sm">SENSOR STATUS</div>
              <div class="value-display" id="sensorStatus">Checking...</div>
            </div>

            <!-- Averaging Control -->
            <div class="control">
              <div class="control-label">
                <span>AVERAGING SAMPLES</span>
                <span class="value-display" id="avgSamplesValue">5</span>
              </div>
              <input
                type="range"
                min="1"
                max="10"
                step="1"
                value="5"
                class="slider"
                id="avgSamplesSlider"
              />
            </div>

            <!-- Measure Button -->
            <div class="settings-btn-group" style="margin-top: 10px">
              <button class="exp-btn" id="measureLuxBtn">MEASURE LUX</button>
            </div>

            <!-- Results Display -->
            <div class="exp-info" style="margin-top: 10px">
              <div class="info-box">
                <div class="label-sm">LUX READING</div>
                <div class="value-display" id="luxReading">--</div>
              </div>
              <div class="info-box">
                <div class="label-sm">VARIANCE</div>
                <div class="value-display" id="luxVariance">--</div>
              </div>
            </div>

            <!-- Exposure Time Result -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">CALCULATED EXPOSURE TIME</div>
              <div
                class="timer-display"
                id="meterExposureTime"
                style="font-size: 2.5rem"
              >
                --.--
              </div>
            </div>

            <!-- Filter Grade Selection (for exposure adjustment) -->
            <div class="control" style="margin-top: 10px">
              <div class="control-label">
                <span>FILTER GRADE (optional)</span>
              </div>
              <select
                class="settings-input"
                id="exposureFilterGrade"
                style="width: 100%"
              >
                <option value="">None (no filter)</option>
                <option value="00">Grade 00</option>
                <option value="0">Grade 0</option>
                <option value="1">Grade 1</option>
                <option value="2" selected>Grade 2 (Normal)</option>
                <option value="3">Grade 3</option>
                <option value="4">Grade 4</option>
                <option value="5">Grade 5</option>
              </select>
            </div>

            <!-- Send to CALC Button -->
            <div class="settings-btn-group" style="margin-top: 15px">
              <button
                class="settings-btn primary"
                id="sendExposureToCalc"
                disabled
              >
                → Send to CALC Timer
              </button>
            </div>
          </div>
        </div>

        <!-- CONTRAST ANALYSIS MODE (Single-Grade) -->
        <div
          id="meterContrastMode"
          class="meter-mode-content"
          style="display: none"
        >
          <div class="incremental-timer">
            <div class="title-sm" style="text-align: center">
              CONTRAST ANALYZER
            </div>
            <div
              class="label-sm"
              style="text-align: center; margin-bottom: 10px"
            >
              Measure highlight and shadow areas to determine contrast grade
            </div>

            <!-- Averaging Control -->
            <div class="control">
              <div class="control-label">
                <span>AVERAGING SAMPLES</span>
                <span class="value-display" id="contrastAvgSamplesValue"
                  >5</span
                >
              </div>
              <input
                type="range"
                min="1"
                max="10"
                step="1"
                value="5"
                class="slider"
                id="contrastAvgSamplesSlider"
              />
            </div>

            <!-- Highlight Measurement -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">HIGHLIGHT (brightest area)</div>
              <div class="value-display" id="highlightLux">-- lux</div>
              <button
                class="settings-btn"
                id="measureHighlightBtn"
                style="margin-top: 5px"
              >
                Measure Highlight
              </button>
            </div>

            <!-- Shadow Measurement -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">SHADOW (darkest area)</div>
              <div class="value-display" id="shadowLux">-- lux</div>
              <button
                class="settings-btn"
                id="measureShadowBtn"
                style="margin-top: 5px"
              >
                Measure Shadow
              </button>
            </div>

            <!-- Contrast Analysis Results -->
            <div class="info-box" style="margin-top: 15px">
              <div class="label-sm">CONTRAST RANGE (ΔEV)</div>
              <div
                class="timer-display"
                id="deltaEVDisplay"
                style="font-size: 2.5rem"
              >
                --
              </div>
              <div class="label-sm" style="margin-top: 4px">
                Higher ΔEV = higher contrast negative
              </div>
            </div>

            <!-- Recommended Filter Grade -->
            <div class="exp-info" style="margin-top: 10px">
              <div class="info-box">
                <div class="label-sm">RECOMMENDED GRADE</div>
                <div
                  class="value-display"
                  id="recommendedGrade"
                  style="font-size: 1.8rem"
                >
                  --
                </div>
              </div>
              <div class="info-box">
                <div class="label-sm">MATCH QUALITY</div>
                <div class="value-display" id="matchQuality">--</div>
              </div>
            </div>


            <!-- Analysis Reasoning -->
            <div
              class="info-box"
              style="
                margin-top: 10px;
                background: rgba(50, 150, 255, 0.1);
                border-color: rgba(50, 150, 255, 0.3);
              "
            >
              <div class="label-sm" style="color: #6699ff">
                ANALYSIS REASONING
              </div>
              <div
                class="label-sm"
                style="font-size: 0.85rem; margin-top: 5px"
                id="analysisReasoning"
              >
                --
              </div>
            </div>

            <!-- Suggested Exposure Time -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">SUGGESTED EXPOSURE TIME</div>
              <div
                class="label-sm"
                style="
                  font-size: 0.85rem;
                  margin-top: 5px;
                  padding-top: 5px;
                  border-top: 1px solid rgba(100, 200, 100, 0.3);
                "
              >
                <div style="display: flex; justify-content: space-between">
                  <span>Midpoint Time:</span>
                  <span
                    style="font-weight: bold; font-size: 1.1rem"
                    id="suggestedExposureTime"
                    >-- sec</span
                  >
                </div>
                <div
                  style="display: flex; justify-content: space-between; margin-top: 3px"
                >
                  <span>Midpoint Lux:</span>
                  <span style="font-weight: bold" id="midpointLuxDisplay"
                    >-- lux</span
                  >
                </div>
              </div>
              <div
                class="label-sm"
                style="
                  font-size: 0.8rem;
                  margin-top: 5px;
                  font-style: italic;
                  color: #aaa;
                "
                id="exposureNote"
              >
                --
              </div>
            </div>

            <!-- Action Buttons -->
            <div class="settings-btn-group" style="margin-top: 15px">
              <button class="settings-btn" id="analyzeContrastBtn" disabled>
                Analyze Contrast
              </button>
              <button class="settings-btn" id="sendContrastToCalc" disabled>
                Send Suggested Time to CALC
              </button>
              <button class="settings-btn" id="clearContrastBtn">
                Clear Readings
              </button>
            </div>
          </div>
        </div>

        <!-- SPLIT-GRADE MODE -->
        <div
          id="meterSplitMode"
          class="meter-mode-content"
          style="display: none"
        >
          <div class="incremental-timer">
            <div class="title-sm" style="text-align: center">
              SPLIT-GRADE ANALYZER
            </div>
            <div
              class="label-sm"
              style="text-align: center; margin-bottom: 10px"
            >
              Calculate absolute exposure times for split-grade printing
            </div>

            <!-- Averaging Control -->
            <div class="control">
              <div class="control-label">
                <span>AVERAGING SAMPLES</span>
                <span class="value-display" id="splitAvgSamplesValue">5</span>
              </div>
              <input
                type="range"
                min="1"
                max="10"
                step="1"
                value="5"
                class="slider"
                id="splitAvgSamplesSlider"
              />
            </div>

            <!-- Highlight Measurement for Split Grade -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">HIGHLIGHT AREA</div>
              <div class="value-display" id="splitHighlightLux">-- lux</div>
              <button
                class="settings-btn"
                id="splitMeasureHighlightBtn"
                style="margin-top: 5px"
              >
                Measure Highlight
              </button>
            </div>

            <!-- Shadow Measurement for Split Grade -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">SHADOW AREA</div>
              <div class="value-display" id="splitShadowLux">-- lux</div>
              <button
                class="settings-btn"
                id="splitMeasureShadowBtn"
                style="margin-top: 5px"
              >
                Measure Shadow
              </button>
            </div>

            <!-- Contrast Analysis -->
            <div class="info-box" style="margin-top: 15px">
              <div class="label-sm">CONTRAST RANGE (ΔEV)</div>
              <div
                class="timer-display"
                id="splitDeltaEV"
                style="font-size: 2rem"
              >
                --
              </div>
              <div class="label-sm" style="margin-top: 4px">
                Match Quality: <span id="splitMatchQuality">--</span>
              </div>
              <div
                class="label-sm"
                id="splitMatchNote"
                style="
                  margin-top: 4px;
                  font-size: 0.55rem;
                  color: var(--text-secondary);
                "
              >
                --
              </div>
            </div>

            <!-- Paper & Filter Characteristics (Split-Grade) -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">PAPER CHARACTERISTICS</div>
              <div class="label-sm" style="margin-top: 5px; font-size: 0.85rem">
                <div style="display: flex; justify-content: space-between">
                  <span>Printable EV:</span>
                  <span style="font-weight: bold" id="splitPrintableEV">-- EV</span>
                </div>
              </div>
              <div class="label-sm" style="font-size: 0.85rem">
                <div style="display: flex; justify-content: space-between">
                  <span>Gamma (Tone Curve):</span>
                  <span style="font-weight: bold" id="splitPaperGamma">--</span>
                </div>
              </div>
              <div class="label-sm" style="font-size: 0.85rem">
                <div style="display: flex; justify-content: space-between">
                  <span>Contrast Index:</span>
                  <span style="font-weight: bold" id="splitContrastIndex">--</span>
                </div>
              </div>
              <div class="label-sm" style="font-size: 0.85rem">
                <div style="display: flex; justify-content: space-between">
                  <span>Density Range:</span>
                  <span style="font-weight: bold" id="splitDensityRange">
                    -- (Dmin-Dmax)
                  </span>
                </div>
              </div>
            </div>

            <!-- Analysis Reasoning -->
            <div
              class="info-box"
              style="
                margin-top: 10px;
                background: rgba(50, 150, 255, 0.1);
                border-color: rgba(50, 150, 255, 0.3);
              "
            >
              <div class="label-sm" style="color: #6699ff">
                ANALYSIS REASONING
              </div>
              <div
                class="label-sm"
                style="font-size: 0.85rem; margin-top: 5px"
                id="splitAnalysisReasoning"
              >
                --
              </div>
            </div>

            <!-- Exposure Times Results -->
            <div class="exp-info" style="margin-top: 15px">
              <div
                class="info-box"
                style="
                  background: rgba(255, 200, 50, 0.1);
                  border-color: rgba(255, 200, 50, 0.3);
                "
              >
                <div class="label-sm" style="color: #ffcc00">SOFT EXPOSURE</div>
                <div
                  class="value-display"
                  id="splitSoftTime"
                  style="font-size: 1.8rem"
                >
                  --.--
                </div>
                <div class="label-sm" style="margin-top: 4px">
                  <span id="splitSoftFilterName">--</span> |
                  <span id="splitSoftPercent">--%</span>
                </div>
              </div>
              <div
                class="info-box"
                style="
                  background: rgba(200, 50, 255, 0.1);
                  border-color: rgba(200, 50, 255, 0.3);
                "
              >
                <div class="label-sm" style="color: #cc66ff">HARD EXPOSURE</div>
                <div
                  class="value-display"
                  id="splitHardTime"
                  style="font-size: 1.8rem"
                >
                  --.--
                </div>
                <div class="label-sm" style="margin-top: 4px">
                  <span id="splitHardFilterName">--</span> |
                  <span id="splitHardPercent">--%</span>
                </div>
              </div>
            </div>

            <div class="settings-btn-group" style="margin-top: 10px">
              <button
                class="settings-btn"
                id="sendSplitBothToCalc"
                disabled
              >
                → Send Both to CALC
              </button>
            </div>

            <!-- Total Time -->
            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">TOTAL EXPOSURE TIME</div>
              <div
                class="timer-display"
                id="splitTotalTime"
                style="font-size: 2.2rem"
              >
                --.--
              </div>
            </div>

            <!-- Guidance Message -->
            <div
              class="info-box"
              style="
                margin-top: 15px;
                background: rgba(50, 150, 255, 0.1);
                border-color: rgba(50, 150, 255, 0.3);
              "
            >
              <div class="label-sm" style="color: #6699ff; text-align: center">
                HOW TO USE
              </div>
              <div class="label-sm" style="text-align: center; margin-top: 5px">
                1. Measure highlight and shadow areas<br />
                2. Click "Calculate Split-Grade"<br />
                3. Send times to CALC tab for exposure
              </div>
            </div>

            <!-- Action Buttons -->
            <div class="settings-btn-group" style="margin-top: 15px">
              <button class="settings-btn" id="calculateSplitBtn" disabled>
                Calculate Split-Grade
              </button>
            </div>

            <div class="settings-btn-group" style="margin-top: 10px">
              <button class="settings-btn" id="clearSplitBtn">
                Clear Readings
              </button>
            </div>
          </div>
        </div>

        <!-- VIRTUAL PROOF MODE -->
        <div
          id="meterProofMode"
          class="meter-mode-content"
          style="display: none"
        >
          <div class="incremental-timer">
            <div class="title-sm" style="text-align: center">
              VIRTUAL PROOF
            </div>
            <div
              class="label-sm"
              style="text-align: center; margin-bottom: 10px"
            >
              Sequential scan to rebuild a grayscale preview
            </div>

            <div class="control">
              <div class="control-label">
                <span>GRID SIZE</span>
                <span class="value-display" id="proofGridTotal">--</span>
              </div>
              <div style="display: flex; gap: 8px; margin-top: 6px">
                <input
                  type="number"
                  id="proofGridWidth"
                  class="settings-input"
                  min="1"
                  max="50"
                  step="1"
                  value="30"
                  style="width: 50%"
                />
                <input
                  type="number"
                  id="proofGridHeight"
                  class="settings-input"
                  min="1"
                  max="50"
                  step="1"
                  value="20"
                  style="width: 50%"
                />
              </div>
              <div class="settings-btn-group" style="margin-top: 8px">
                <button class="settings-btn" id="proofApplyGridBtn">
                  Apply Grid
                </button>
              </div>
            </div>

            <div class="control">
              <div class="control-label">
                <span>AVERAGING SAMPLES</span>
                <span class="value-display" id="proofAvgSamplesValue">5</span>
              </div>
              <input
                type="range"
                min="1"
                max="10"
                step="1"
                value="5"
                class="slider"
                id="proofAvgSamplesSlider"
              />
            </div>

            <div class="control" style="margin-top: 10px">
              <div class="control-label">
                <span>PREVIEW FILTER GRADE</span>
              </div>
              <select
                class="settings-input"
                id="proofFilterGrade"
                style="width: 100%"
              ></select>
            </div>

            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">SCAN PROGRESS</div>
              <div class="value-display" id="proofScanProgress">0/0</div>
              <div class="label-sm" id="proofScanStatus">Idle</div>
              <div class="settings-btn-group" style="margin-top: 6px">
                <button class="settings-btn" id="proofMeasureNextBtn">
                  Measure Next Cell
                </button>
                <button
                  class="settings-btn"
                  id="proofSetReferenceBtn"
                  disabled
                >
                  Set Zone V Reference
                </button>
                <button
                  class="settings-btn"
                  id="proofRecomputeBtn"
                  disabled
                >
                  Recompute Preview
                </button>
                <button class="settings-btn" id="proofClearBtn">
                  Clear Grid
                </button>
              </div>
            </div>

            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">LAST SAMPLE</div>
              <div class="label-sm" id="proofLastLux">Lux: --</div>
              <div class="label-sm" id="proofLastZone">Zone: --</div>
              <div class="label-sm" id="proofLastIsoR">ISO R: --</div>
              <div class="label-sm" id="proofLastEvRange">EV Range: --</div>
              <div class="label-sm" id="proofLastDensity">Density: --</div>
              <div class="label-sm" id="proofLastClipping">Clipping: --</div>
            </div>

            <div class="info-box" style="margin-top: 10px">
              <div class="label-sm">VIRTUAL PROOF</div>
              <div class="proof-grid" id="proofGrid"></div>
              <div class="proof-legend">
                <span>Dark (black)</span>
                <span>Light (white)</span>
              </div>
              <div class="proof-histogram">
                <div class="label-sm proof-histogram-label">HISTOGRAM</div>
                <canvas
                  id="proofHistogram"
                  class="proof-histogram-canvas"
                  role="img"
                  aria-label="Virtual proof histogram"
                ></canvas>
              </div>
            </div>
          </div>
        </div>

        <!-- Calibration Section -->
        <section class="collapsible" data-id="meter-calibration">
          <button class="collapsible-header" aria-expanded="false">
            CALIBRATION
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="title-sm" style="text-align: center">
                CALIBRATION PROCEDURE
              </div>
              <div class="label-sm" style="line-height: 1.4; padding: 5px">
                <strong>To calibrate:</strong><br />
                1. Set up enlarger with a typical negative<br />
                2. Measure lux at baseboard (use exposure mode)<br />
                3. Make test strip prints<br />
                4. Determine correct exposure time<br />
                5. Calculate: calibration = measured_lux × correct_time<br />
                6. Enter value below
              </div>

              <!-- Manual Calibration Input -->
              <div class="control" style="margin-top: 10px">
                <div class="control-label">
                  <span>CALIBRATION CONSTANT (lux·s)</span>
                </div>
                <input
                  type="number"
                  id="calibrationInput"
                  class="settings-input"
                  placeholder="e.g., 1000"
                  min="1"
                  max="100000"
                  step="1"
                  value="1000"
                  style="width: 100%"
                />
              </div>

              <!-- Quick Calibration Calculator -->
              <div class="info-box" style="margin-top: 10px">
                <div class="label-sm">QUICK CALIBRATION CALCULATOR</div>
                <div style="display: flex; gap: 10px; margin-top: 5px">
                  <div style="flex: 1">
                    <div class="label-sm">Measured Lux</div>
                    <input
                      type="number"
                      id="calMeasuredLux"
                      class="settings-input"
                      placeholder="lux"
                      style="width: 100%"
                    />
                  </div>
                  <div style="flex: 1">
                    <div class="label-sm">Correct Time (s)</div>
                    <input
                      type="number"
                      id="calCorrectTime"
                      class="settings-input"
                      placeholder="seconds"
                      step="0.1"
                      style="width: 100%"
                    />
                  </div>
                </div>
                <button
                  class="settings-btn"
                  id="calculateCalibrationBtn"
                  style="margin-top: 8px; width: 100%"
                >
                  Calculate & Apply
                </button>
              </div>

              <!-- Save Calibration -->
              <div class="settings-btn-group" style="margin-top: 15px">
                <button class="settings-btn primary" id="saveCalibrationBtn">
                  Save Calibration
                </button>
              </div>
            </div>
          </div>
        </section>

        <!-- Sensor Information -->
        <section class="collapsible" data-id="sensor-info">
          <button class="collapsible-header" aria-expanded="false">
            SENSOR INFORMATION
          </button>
          <div class="collapsible-content">
            <div class="incremental-timer">
              <div class="exp-info">
                <div class="info-box">
                  <div class="label-sm">SENSOR TYPE</div>
                  <div class="value-display" id="sensorType">TSL2591X</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">CONNECTION</div>
                  <div class="value-display" id="sensorConnection">I²C</div>
                </div>
              </div>
              <div class="exp-info" style="margin-top: 10px">
                <div class="info-box">
                  <div class="label-sm">CURRENT GAIN</div>
                  <div class="value-display" id="sensorGain">MED (25×)</div>
                </div>
                <div class="info-box">
                  <div class="label-sm">INTEGRATION</div>
                  <div class="value-display" id="sensorIntegration">300ms</div>
                </div>
              </div>

              <!-- Gain Control -->
              <div class="control" style="margin-top: 10px">
                <div class="control-label">
                  <span>SENSOR GAIN</span>
                </div>
                <select
                  class="settings-input"
                  id="sensorGainSelect"
                  style="width: 100%"
                >
                  <option value="auto">Auto (recommended)</option>
                  <option value="low">Low (1×) - very bright</option>
                  <option value="med" selected>Medium (25×) - normal</option>
                  <option value="high">High (428×) - dim</option>
                  <option value="max">Maximum (9876×) - very dim</option>
                </select>
              </div>

              <!-- Integration Time Control -->
              <div class="control" style="margin-top: 10px">
                <div class="control-label">
                  <span>INTEGRATION TIME</span>
                </div>
                <select
                  class="settings-input"
                  id="sensorIntegrationSelect"
                  style="width: 100%"
                >
                  <option value="100">100ms (fastest)</option>
                  <option value="200">200ms</option>
                  <option value="300" selected>300ms (balanced)</option>
                  <option value="400">400ms</option>
                  <option value="500">500ms</option>
                  <option value="600">600ms (most sensitive)</option>
                </select>
              </div>

              <div class="settings-btn-group" style="margin-top: 10px">
                <button class="settings-btn" id="applySensorSettingsBtn">
                  Apply Sensor Settings
                </button>
                <button class="settings-btn" id="refreshSensorStatusBtn">
                  Refresh Status
                </button>
              </div>
            </div>
          </div>
        </section>
      </div>

      <!-- NEW: LOGS Tab for Exposure Session Logging -->
      <div id="logs" class="tab-content">
        <div class="incremental-timer">
          <div class="title-md">EXPOSURE SESSION LOGS</div>
          <div class="label-sm" style="margin-bottom: 8px">
            Automatically tracks your printing sessions. Temporary sessions (max
            6) are auto-saved. Save permanently to keep sessions forever.
          </div>

          <!-- Session Statistics -->
          <div class="info-box" style="margin-bottom: 10px">
            <div class="label-sm">SESSION STATISTICS</div>
            <div class="value-display" id="logStats">Loading...</div>
          </div>

          <!-- Temporary Sessions (Auto-saved) -->
          <div class="title-sm" style="margin-top: 10px">
            TEMPORARY SESSIONS (Auto-saved)
          </div>
          <div class="shelf-life-list" id="tempSessionsList">
            <div
              class="shelf-life-item"
              style="justify-content: center; color: var(--text-secondary)"
            >
              No temporary sessions yet
            </div>
          </div>

          <!-- Permanent Sessions (User-saved) -->
          <div class="title-sm" style="margin-top: 10px">
            PERMANENT SESSIONS
          </div>
          <div class="shelf-life-list" id="permanentSessionsList">
            <div
              class="shelf-life-item"
              style="justify-content: center; color: var(--text-secondary)"
            >
              No permanent sessions saved
            </div>
          </div>

          <!-- Action Buttons -->
          <div class="settings-btn-group">
            <button class="settings-btn" id="exportCSV">Export CSV</button>
            <button class="settings-btn" id="exportJSON">Export JSON</button>
            <button class="settings-btn" id="importJSON">Import JSON</button>
            <button class="settings-btn danger" id="clearAllLogs">
              Clear All Logs
            </button>
          </div>
        </div>
      </div>

      <footer>
        <div>DARKROOM TIMER v3.0.0 (Pico 2 W)</div>
        <div>
          Height & Aperture & Paper Size & Contrast Calculator: New Time =
          Original Time × (New Height ÷ Original Height)² × (New F-Stop ÷
          Original F-Stop)² × (√New Paper Area ÷ √Original Paper Area)² × Filter
          Factor
        </div>
        <div>
          Chemical Mix Calculator: Stock = Total Volume ÷ (Stock Parts + Water
          Parts)
        </div>
        <div>
          Capacity Calculator: Max Prints = (Capacity × Tray Volume / 1000) ÷
          Paper Area
        </div>
        <div>
          Countdown Feature: Configurable 0-30 second delay with audible beeps
          before all timers start
        </div>
        <div>
          Test Strip Auto Advance: Toggle automatic progression between test
          strip steps
        </div>
        <div>
          Data Export: Includes Timer Profiles, Chemical Presets, Capacity
          Tracker, and Shelf Life Data
        </div>
      </footer>
    </div>

    <script>
      // Storage keys - UPDATED
      const STORAGE_KEYS = {
        SETTINGS: "darkroom_timer_settings",
        PROFILES: "darkroom_timer_profiles",
        CURRENT_PROFILE: "darkroom_timer_current_profile",
        COLOR_SCHEME: "darkroom_timer_color_scheme",
        CHEMICAL_PRESETS: "darkroom_timer_chemical_presets",
        CAPACITY_TRACKER: "darkroom_timer_capacity_tracker",
        SHELF_LIFE: "darkroom_timer_shelf_life",
        CUSTOM_FILTER_BANKS: "darkroom_timer_custom_filter_banks",
        TEST_STRIP_PROFILES: "darkroom_timer_test_strip_profiles",
        CURRENT_TEST_STRIP_PROFILE: "darkroom_timer_current_test_strip_profile",
        SPLIT_GRADE_PRESETS: "darkroom_timer_split_grade_presets",
        CURRENT_SPLIT_PRESET: "darkroom_timer_current_split_preset",
        TEST_TRANSFER_DESTINATION: "darkroom_timer_test_transfer_destination",
        // Light meter calibrations (per paper type)
        LIGHT_METER_CALIBRATIONS: "darkroom_timer_light_meter_calibrations",
        // Logging tool storage keys
        TEMP_SESSIONS: "darkroom_timer_temp_sessions",
        PERMANENT_SESSIONS: "darkroom_timer_permanent_sessions",
      };

      // Application configuration - constants to eliminate magic numbers
      const CONFIG = {
        AUDIO: {
          BEEP_FREQUENCY_HZ: 600,
          BEEP_DURATION_SEC: 0.3,
          BEEP_VOLUME: 0.3,
          FEEDBACK_TIMEOUT_MS: 3000,
        },
      };

      // Default settings - UPDATED with countdown settings AND auto advance
      const DEFAULT_SETTINGS = {
        baseTime: 10.0,
        devTime: 60,
        stopTime: 30,
        fixTime: 60,
        floTime: 30,
        calcWarningBeep: true,
        calcEndBeep: true,
        timerWarningBeep: true,
        timerEndBeep: true,
        currentProfile: null,
        colorScheme: "dark",
        // Countdown settings
        countdownDelay: 5, // Countdown delay in seconds
        countdownBeep: true, // Countdown beep enabled
        countdownPattern: "every-second", // Countdown beep pattern: 'every-second'|'last3'|'last5'|'none'
        // Test strip auto-advance
        autoAdvance: false,
        autoAdvanceDelay: 1,
        safelightAutoOff: true, // Turn off safelight when enlarger is on
        stopDenominator: 3, // Denominator for f-stop fractions (2, 3, or 4)
        proofStabilityEnabled: true,
        proofStabilityBeep: true,
        proofStabilityTolerance: 2.5,
        proofStabilityMinStable: 2,
        proofStabilityMaxWait: 900,
        proofStabilityMinDelta: 0.2,
        // Base time slider limits
        baseTimeMin: 0.4,
        baseTimeMax: 50,
        // Test base time slider limits
        testBaseTimeMin: 1,
        testBaseTimeMax: 50,
        // Test strip transfer destination
        testTransferDestination: "calc", // 'calc' or 'split'
      };

      // Default timer times (seconds)
      const DEFAULT_TIMER_TIMES = {
        Dev: 60,
        Stop: 30,
        Fix: 60,
        Flo: 30,
      };

      function getDefaultCustomFilterBanks() {
        const defaultLabels = [
          "Grade 00",
          "Grade 0",
          "Grade 0.5",
          "Grade 1",
          "Grade 1.5",
          "Grade 2",
          "Grade 2.5",
          "Grade 3",
          "Grade 3.5",
          "Grade 4",
          "Grade 4.5",
          "Grade 5",
        ];

        const makeGroup = (name) => ({
          name,
          slots: defaultLabels.map((label) => ({ label, value: 1.0 })),
        });

        return [
          makeGroup("Group A"),
          makeGroup("Group B"),
          makeGroup("Group C"),
        ];
      }

      // Global variables for timer management
      let settingsManager;
      let timerManager;
      let audioService = null; // Centralized audio service

      // ===== AUDIO SERVICE CLASS =====
      /**
       * AudioService - Manages Web Audio API for sound feedback
       *
       * Provides a centralized audio system for all timer and UI sound effects.
       * Handles audio context initialization, resume on user interaction, and
       * provides preset sound patterns for different events.
       *
       * @class
       * @example
       * const audio = new AudioService();
       * await audio.playPreset('timerComplete');
       */
      class AudioService {
        /**
         * Creates an AudioService instance
         * @constructor
         * @property {AudioContext|null} audioContext - The Web Audio API context
         * @property {boolean} initialized - Whether audio context is initialized
         * @property {Object} presets - Collection of sound presets with frequency, duration, volume
         */
        constructor() {
          this.audioContext = null;
          this.initialized = false;
          this.presets = {
            // Timer presets
            warning: { frequency: 600, duration: 0.3, volume: 0.3 },
            timerWarning: { frequency: 400, duration: 0.3, volume: 0.3 },
            timerComplete: { frequency: 800, duration: 0.1, volume: 0.5 },

            // Calculator presets
            calcWarning: { frequency: 600, duration: 0.3, volume: 0.3 },
            calcComplete: { frequency: 1600, duration: 0.1, volume: 0.5 },

            // Countdown presets
            countdown: { frequency: 400, duration: 0.2, volume: 0.2 },
            countdownMid: { frequency: 600, duration: 0.3, volume: 0.3 },
            countdownUrgent: { frequency: 800, duration: 0.2, volume: 0.4 },
            countdownComplete: { frequency: 1600, duration: 0.5, volume: 0.5 },

            // UI feedback presets
            success: { frequency: 800, duration: 0.3, volume: 0.3 },
            action: { frequency: 600, duration: 0.3, volume: 0.3 },
            pause: { frequency: 600, duration: 0.3, volume: 0.2 },
            error: { frequency: 400, duration: 0.3, volume: 0.3 },
            lowTone: { frequency: 400, duration: 0.3, volume: 0.3 },

            // Relay presets
            relayOn: { frequency: 800, duration: 0.1, volume: 0.3 },
            relayOff: { frequency: 400, duration: 0.5, volume: 0.3 },
            relayTrigger: { frequency: 600, duration: 0.3, volume: 0.3 },
            relayBurst: { frequency: 600, duration: 0.1, volume: 0.3 },

            // Chemical presets
            chemicalAction: { frequency: 600, duration: 0.3, volume: 0.2 },
            chemicalSave: { frequency: 600, duration: 0.5, volume: 0.3 },
            chemicalDelete: { frequency: 800, duration: 0.5, volume: 0.3 },

            // Other presets
            complete: { frequency: 1600, duration: 0.1, volume: 0.5 },
          };
        }

        /**
         * Initialize the Web Audio API context
         * @returns {boolean} Success status
         * @description Must be called before any audio playback. Requires user interaction.
         */
        init() {
          if (this.initialized) return true;

          try {
            this.audioContext = new (
              window.AudioContext || window.webkitAudioContext
            )();
            this.initialized = true;
            console.log("AudioService initialized");
            return true;
          } catch (e) {
            console.warn("Web Audio API not supported:", e);
            return false;
          }
        }

        /**
         * Ensure audio context is running (resume if suspended)
         * @async
         * @returns {Promise<void>}
         * @description Automatically initializes if needed and resumes suspended context
         */
        async ensureRunning() {
          if (!this.audioContext) {
            this.init();
          }

          if (this.audioContext && this.audioContext.state === "suspended") {
            try {
              await this.audioContext.resume();
            } catch (e) {
              console.warn("Failed to resume audio context:", e);
            }
          }
        }

        /**
         * Play a beep with specified parameters
         * @async
         * @param {number} [frequency=800] - Frequency in Hz (20-20000)
         * @param {number} [duration=0.1] - Duration in seconds
         * @param {number} [volume=0.3] - Volume level (0.0-1.0)
         * @returns {Promise<void>}
         * @description Creates a sine wave oscillator with exponential fade-out
         */
        async playBeep(frequency = 800, duration = 0.1, volume = 0.3) {
          await this.ensureRunning();

          if (!this.audioContext) return;

          try {
            const oscillator = this.audioContext.createOscillator();
            const gainNode = this.audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(this.audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = "sine";

            gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(
              0.01,
              this.audioContext.currentTime + duration,
            );

            oscillator.start(this.audioContext.currentTime);
            oscillator.stop(this.audioContext.currentTime + duration);
          } catch (e) {
            console.warn("Could not play beep:", e);
          }
        }

        /**
         * Play a preset beep by name
         * @async
         * @param {string} presetName - Name of the preset (e.g., 'timerComplete', 'warning')
         * @returns {Promise<void>}
         * @description Looks up preset configuration and plays with stored parameters
         */
        async playPreset(presetName) {
          const preset = this.presets[presetName];
          if (!preset) {
            console.warn(`Unknown preset: ${presetName}`);
            return;
          }
          await this.playBeep(preset.frequency, preset.duration, preset.volume);
        }

        /**
         * Play countdown beep pattern based on remaining seconds
         * @async
         * @param {number} secondsRemaining - Seconds left in countdown
         * @returns {Promise<void>}
         * @description Plays different beep patterns based on urgency:
         * - 0-3 seconds: urgent high-pitch beep
         * - 4-5 seconds: mid-pitch beep
         * - 6+ seconds: standard beep
         */
        async playCountdownBeep(secondsRemaining) {
          if (secondsRemaining <= 3) {
            await this.playPreset("countdownUrgent");
          } else if (secondsRemaining <= 5) {
            await this.playPreset("countdownMid");
          } else {
            await this.playPreset("countdown");
          }
        }
      }

      // ===== DRIFT-CORRECTED TIMER UTILITY =====
      /**
       * DriftCorrectedTimer - High-precision timer with drift compensation
       *
       * Provides millisecond-accurate timing by compensating for JavaScript's
       * timer drift. Uses Date.now() instead of setInterval for photographic
       * timing precision. Essential for accurate exposure timing.
       *
       * @class
       * @example
       * const timer = new DriftCorrectedTimer(() => {
       *   console.log('Tick');
       * }, 1000);
       * timer.start();
       */
      class DriftCorrectedTimer {
        /**
         * Creates a DriftCorrectedTimer instance
         * @constructor
         * @param {Function} callback - Function to execute on each tick
         * @param {number} interval - Interval in milliseconds between ticks
         * @property {Function} callback - The callback function to execute
         * @property {number} interval - The target interval in milliseconds
         * @property {number|null} expected - The expected timestamp of next tick
         * @property {number|null} timeout - The setTimeout identifier
         * @property {boolean} running - Whether the timer is currently running
         */
        constructor(callback, interval) {
          this.callback = callback;
          this.interval = interval;
          this.expected = null;
          this.timeout = null;
          this.running = false;
        }

        /**
         * Start the timer
         * @returns {void}
         * @description Begins the timer loop with drift correction
         */
        start() {
          if (this.running) return;

          this.running = true;
          this.expected = Date.now() + this.interval;
          this.timeout = setTimeout(() => this.step(), this.interval);
        }

        /**
         * Execute one timer tick with drift compensation
         * @private
         * @returns {void}
         * @description Calculates drift and schedules next tick with adjusted delay
         */
        step() {
          if (!this.running) return;

          const drift = Date.now() - this.expected;

          // Call the callback
          this.callback();

          // Calculate next tick with drift correction
          this.expected += this.interval;
          const nextDelay = Math.max(0, this.interval - drift);

          this.timeout = setTimeout(() => this.step(), nextDelay);
        }

        /**
         * Stop the timer
         * @returns {void}
         * @description Halts the timer and clears any pending timeouts
         */
        stop() {
          this.running = false;
          if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }
        }

        /**
         * Check if timer is running
         * @returns {boolean} True if timer is currently running
         */
        isRunning() {
          return this.running;
        }
      }

      // ===== TEMPERATURE MANAGER =====
      /**
       * TemperatureManager - Handles temperature sensor polling and UI updates
       *
       * Polls /temperature endpoint every 1-2 seconds, maintains circular buffer
       * of last 60 readings (15-min rolling window), renders live graph.
       * Target temperature persisted to localStorage.
       *
       * @class
       */
      class TemperatureManager {
        constructor() {
          this.serverIP = window.serverIP || "192.168.4.1";
          this.pollInterval = 15000; // Poll every 15 seconds (matches backend sensor read)
          this.pollTask = null;
          this.dataBuffer = []; // Circular buffer (max 60 points)
          this.maxDataPoints = 60; // 15 minutes at 15sec intervals
          this.lastUpdateTime = 0;
          this.enabled = false;

          // Storage keys
          this.storageKey = "temperature_target";
          this.enabledKey = "temperature_enabled";

          // Load settings from localStorage
          this.targetTemperature = this.loadTargetTemperature();
          this.enabled = this.loadEnabled();

          // Initialize UI elements
          this.initUI();
        }

        initUI() {
          const targetInput = document.getElementById("targetTemperatureInput");
          const setBtn = document.getElementById("setTargetTempBtn");
          const toggle = document.getElementById("temperatureControlToggle");
          const content = document.getElementById("temperatureControlContent");

          if (targetInput) {
            targetInput.value = this.targetTemperature.toFixed(1);
          }

          if (setBtn) {
            setBtn.addEventListener("click", () => this.setTargetTemperature());
          }

          // Enter key support
          if (targetInput) {
            targetInput.addEventListener("keypress", (e) => {
              if (e.key === "Enter") {
                this.setTargetTemperature();
              }
            });
          }

          // Toggle switch handler
          if (toggle) {
            toggle.checked = this.enabled;
            toggle.addEventListener("change", () => {
              this.setEnabled(toggle.checked);
            });
          }

          // Show/hide content based on enabled state
          if (content) {
            content.style.display = this.enabled ? "block" : "none";
          }

          // If enabled from localStorage, sync with backend and start polling
          if (this.enabled) {
            this.syncAndStartPolling();
          }
        }

        async syncAndStartPolling() {
          // Sync enable state with backend on startup
          try {
            const response = await fetch(
              `http://${this.serverIP}/temperature-enable?enabled=true`,
            );
            const data = await response.json();

            if (data.status === "success") {
              this.startPolling();
              this.pollTemperature();
            } else {
              console.warn(
                "Failed to enable temperature on backend:",
                data.error,
              );
              // Disable locally if backend fails
              this.enabled = false;
              this.saveEnabled(false);
              const toggle = document.getElementById(
                "temperatureControlToggle",
              );
              if (toggle) toggle.checked = false;
              const content = document.getElementById(
                "temperatureControlContent",
              );
              if (content) content.style.display = "none";
            }
          } catch (e) {
            console.error("Failed to sync with backend:", e);
            // Keep local state but show connection error
            const statusEl = document.getElementById("temperatureStatus");
            if (statusEl) statusEl.textContent = "⚠️ Server unreachable";
          }
        }

        loadTargetTemperature() {
          const saved = localStorage.getItem(this.storageKey);
          return saved ? parseFloat(saved) : 20.0;
        }

        saveTargetTemperature(target) {
          localStorage.setItem(this.storageKey, target.toFixed(1));
        }

        loadEnabled() {
          return localStorage.getItem(this.enabledKey) === "true";
        }

        saveEnabled(enabled) {
          localStorage.setItem(this.enabledKey, enabled.toString());
        }

        isEnabled() {
          return this.enabled;
        }

        async setEnabled(enabled) {
          // Send enable/disable command to backend first
          try {
            const response = await fetch(
              `http://${this.serverIP}/temperature-enable?enabled=${enabled}`,
            );
            const data = await response.json();

            if (data.status !== "success") {
              console.error("Failed to set temperature enable:", data.error);
              // Revert toggle state on failure
              const toggle = document.getElementById(
                "temperatureControlToggle",
              );
              if (toggle) toggle.checked = this.enabled;
              alert(
                `Error: ${data.error || "Failed to enable temperature control"}`,
              );
              return;
            }
          } catch (e) {
            console.error("Error setting temperature enable:", e);
            // Revert toggle state on failure
            const toggle = document.getElementById("temperatureControlToggle");
            if (toggle) toggle.checked = this.enabled;
            alert("Failed to connect to server");
            return;
          }

          // Backend confirmed - update local state
          this.enabled = enabled;
          this.saveEnabled(enabled);

          const content = document.getElementById("temperatureControlContent");
          const statusEl = document.getElementById("temperatureStatus");

          if (content) {
            content.style.display = enabled ? "block" : "none";
          }

          if (enabled) {
            this.startPolling();
            // Immediately poll to get first reading
            this.pollTemperature();
            if (statusEl) {
              statusEl.textContent = "Starting...";
            }
          } else {
            this.stopPolling();
            // Clear data buffer when disabled
            this.dataBuffer = [];
            if (statusEl) {
              statusEl.textContent = "Disabled";
            }
          }
        }

        async setTargetTemperature() {
          try {
            const input = document.getElementById("targetTemperatureInput");
            if (!input) return;

            const target = parseFloat(input.value);

            if (isNaN(target) || target < 15 || target > 50) {
              alert("Temperature must be between 15°C and 50°C");
              input.value = this.targetTemperature.toFixed(1);
              return;
            }

            // Send to server
            const response = await fetch(
              `http://${this.serverIP}/temperature-control?target=${target}`,
            );
            const data = await response.json();

            if (data.status === "success") {
              this.targetTemperature = target;
              this.saveTargetTemperature(target);
              console.log(`✓ Target temperature set to ${target}°C`);
            } else {
              alert(`Error: ${data.error || "Failed to set temperature"}`);
              input.value = this.targetTemperature.toFixed(1);
            }
          } catch (e) {
            console.error("Error setting temperature:", e);
            alert("Failed to set temperature - server unreachable?");
          }
        }

        async pollTemperature() {
          try {
            const response = await fetch(`http://${this.serverIP}/temperature`);
            const data = await response.json();

            if (data.status === "success") {
              this.addDataPoint(data.temperature, data.target, data.relay_on);
              this.updateDisplay(data);
            } else {
              console.warn("Temperature read failed:", data.error);
              this.updateDisplayError(data.error);
            }
          } catch (e) {
            console.error("Temperature poll error:", e);
            this.updateDisplayError("Connection failed");
          }
        }

        addDataPoint(temp, target, relayOn) {
          if (temp === null || temp === undefined) return;

          this.dataBuffer.push({
            temp,
            target,
            relayOn,
            timestamp: Date.now(),
          });

          // Keep circular buffer size
          if (this.dataBuffer.length > this.maxDataPoints) {
            this.dataBuffer.shift();
          }
        }

        updateDisplay(data) {
          // Update current temperature
          const tempDisplay = document.getElementById("temperatureDisplay");
          if (tempDisplay && data.temperature !== null) {
            tempDisplay.textContent = `${data.temperature.toFixed(1)} °C`;

            // Color code based on status
            if (data.temperature < data.target - 0.5) {
              tempDisplay.style.color = "#74b9ff"; // Blue - heating
            } else if (data.temperature >= data.target) {
              tempDisplay.style.color = "#00b894"; // Green - at target
            } else {
              tempDisplay.style.color = "#fdcb6e"; // Orange - close
            }
          }

          // Update status
          const statusEl = document.getElementById("temperatureStatus");
          if (statusEl) {
            if (!data.connected) {
              statusEl.textContent = "⚠️ Sensor disconnected";
              statusEl.style.color = "#d63031";
            } else if (data.relay_on) {
              statusEl.textContent = "🔥 Heating...";
              statusEl.style.color = "#ff7675";
            } else {
              statusEl.textContent = "✓ Ready";
              statusEl.style.color = "#00b894";
            }
          }

          // Update relay status
          const relayDisplay = document.getElementById("relayStatusDisplay");
          if (relayDisplay) {
            relayDisplay.textContent = data.relay_on ? "ON" : "OFF";
            relayDisplay.style.color = data.relay_on
              ? "#ff7675"
              : "var(--text)";
          }

          // Update connection status alert
          const connStatus = document.getElementById(
            "temperatureConnectionStatus",
          );
          if (connStatus) {
            connStatus.style.display = !data.connected ? "block" : "none";
          }

          // Update data points info
          const pointsInfo = document.getElementById("dataPointsInfo");
          if (pointsInfo) {
            pointsInfo.textContent = `${this.dataBuffer.length} readings in buffer`;
          }

          // Render graph
          this.renderGraph();
        }

        updateDisplayError(error) {
          const statusEl = document.getElementById("temperatureStatus");
          if (statusEl) {
            statusEl.textContent = `⚠️ ${error}`;
            statusEl.style.color = "#d63031";
          }

          const connStatus = document.getElementById(
            "temperatureConnectionStatus",
          );
          if (connStatus) {
            connStatus.style.display = "block";
          }
        }

        renderGraph() {
          const canvas = document.getElementById("temperatureChart");
          if (!canvas || this.dataBuffer.length === 0) return;

          const ctx = canvas.getContext("2d");
          const width = canvas.offsetWidth;
          const height = canvas.height;

          // Clear canvas
          ctx.fillStyle = "var(--bg-darker)";
          ctx.fillRect(0, 0, width, height);

          // Find min/max temps for scaling
          let minTemp = Math.min(...this.dataBuffer.map((p) => p.temp));
          let maxTemp = Math.max(...this.dataBuffer.map((p) => p.temp));
          const targetTemp = this.dataBuffer[0].target;

          // Add some padding
          const tempRange = maxTemp - minTemp || 1;
          minTemp = Math.floor(minTemp - tempRange * 0.1);
          maxTemp = Math.ceil(maxTemp + tempRange * 0.1);

          const tempScale = maxTemp - minTemp || 1;

          // Draw grid and labels
          ctx.strokeStyle = "rgba(100, 100, 100, 0.2)";
          ctx.lineWidth = 1;
          ctx.font = "10px sans-serif";
          ctx.fillStyle = "rgba(200, 200, 200, 0.5)";

          // Horizontal grid lines
          for (let t = Math.ceil(minTemp); t <= Math.floor(maxTemp); t++) {
            const y = height - ((t - minTemp) / tempScale) * height;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
            ctx.fillText(t.toFixed(1), 3, y - 2);
          }

          // Draw target line
          const targetY =
            height - ((targetTemp - minTemp) / tempScale) * height;
          ctx.strokeStyle = "rgba(0, 184, 148, 0.3)"; // Green dashed
          ctx.setLineDash([5, 5]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, targetY);
          ctx.lineTo(width, targetY);
          ctx.stroke();
          ctx.setLineDash([]);

          // Draw temperature line
          ctx.strokeStyle = "#74b9ff"; // Blue
          ctx.lineWidth = 2;
          ctx.beginPath();

          const pointSpacing = width / Math.max(this.dataBuffer.length - 1, 1);
          for (let i = 0; i < this.dataBuffer.length; i++) {
            const x = i * pointSpacing;
            const y =
              height -
              ((this.dataBuffer[i].temp - minTemp) / tempScale) * height;

            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();

          // Draw current point (larger)
          if (this.dataBuffer.length > 0) {
            const lastPoint = this.dataBuffer[this.dataBuffer.length - 1];
            const x = width - 2;
            const y =
              height - ((lastPoint.temp - minTemp) / tempScale) * height;

            ctx.fillStyle = lastPoint.relayOn ? "#ff7675" : "#00b894";
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        startPolling() {
          if (this.pollTask) return;
          console.log("Starting temperature polling...");
          this.pollTask = setInterval(
            () => this.pollTemperature(),
            this.pollInterval,
          );
        }

        stopPolling() {
          if (this.pollTask) {
            clearInterval(this.pollTask);
            this.pollTask = null;
            console.log("Temperature polling stopped");
          }
        }

        refreshDisplay() {
          // Called when CONTROL tab is shown and temperature is enabled
          if (this.enabled) {
            this.pollTemperature();
            this.renderGraph();
          }
        }
      }

      // Application State - Single Source of Truth Pattern
      // =====================================================
      // STATE MANAGEMENT ARCHITECTURE:
      //
      // 1. TRANSIENT UI STATE (appState.ui)
      //    - activeTab, timerStatus
      //    - Never persisted to localStorage
      //    - Reset on page reload
      //    - Updated during user interactions
      //
      // 2. RUNTIME STATE (appState.calculator, appState.timers)
      //    - Timer values, calculator state, countdown flags
      //    - Transient (not persisted)
      //    - Cleared/reset on page reload
      //    - Source of truth for current timer/calc display
      //
      // 3. PERSISTENT UI SELECTIONS (appState.persistent)
      //    - currentProfile, currentChemicalPreset
      //    - Persisted via StorageManager.save*()
      //    - Loaded on page start via SettingsManager/ChemicalManager constructors
      //    - SINGLE SOURCE OF TRUTH - accessed via helper methods:
      //      SettingsManager: getCurrentProfile(), setCurrentProfile()
      //      ChemicalManager: getCurrentPreset(), setCurrentPreset()
      //
      // 4. SETTINGS (appState.settings)
      //    - User preferences and configuration
      //    - Persisted via StorageManager.saveSettings()
      //    - Synced from StorageManager on init
      //    - Single copy kept in this.settings on SettingsManager
      //
      // REDUNDANCY PREVENTION:
      // - NO instance properties for currentProfile/currentPreset
      // - Use appState.persistent for truth instead
      // - Helper methods ensure consistency with StorageManager
      // - All reads go through appState, all writes sync to StorageManager
      //
      const appState = {
        // Calculator state (runtime/transient)
        calculator: {
          baseTime: 10.0,
          currentStop: 0,
          currentTotalTime: 10.0,
          thisExposureTime: 10.0,
          accumulatedTime: 0,
          isRunning: false,
          isPaused: false,
          isCountdown: false,
          currentTime: 10.0,
          lastExposureTime: 10.0,
          displayedExposureTime: null,
          // Split-grade data (stored when sent from SPLIT tab)
          splitGrade: {
            enabled: false,
            neutralTime: null,
            highlightsBase: null,
            shadowsBase: null,
            softTime: null,
            hardTime: null,
            totalTime: null,
            softFilter: null,
            hardFilter: null,
            paperBrand: null,
            fomaPaperType: null,
            burnPercent: null,
            softFactor: null,
            hardFactor: null,
            customFactors: null,
          },
        },

        // Timer states (runtime/transient)
        timers: {
          Dev: {
            timeLeft: 60,
            totalTime: 60,
            isRunning: false,
            isEnabled: true,
          },
          Stop: {
            timeLeft: 30,
            totalTime: 30,
            isRunning: false,
            isEnabled: true,
          },
          Fix: {
            timeLeft: 60,
            totalTime: 60,
            isRunning: false,
            isEnabled: true,
          },
          Flo: {
            timeLeft: 30,
            totalTime: 30,
            isRunning: false,
            isEnabled: true,
          },
        },

        // Settings state (persisted + synced from StorageManager)
        settings: {
          colorScheme: "dark",
          calcWarningBeep: true,
          calcEndBeep: true,
          timerWarningBeep: true,
          timerEndBeep: true,
          countdownDelay: 5,
          countdownBeep: true,
          countdownPattern: "every-second",
          autoAdvance: false,
          autoAdvanceDelay: 1,
          safelightAutoOff: true,
          stopDenominator: 3,
          testTransferDestination: "calc",
        },

        // Persistent UI selections (loaded from StorageManager)
        persistent: {
          currentProfile: null, // Currently loaded timer profile
          currentChemicalPreset: null, // Currently loaded chemical preset
          currentTestStripProfile: null, // Currently loaded test strip profile
        },

        // Transient UI state (not persisted)
        ui: {
          activeTab: "calculator",
          timerStatus: "READY FOR EXPOSURE",
        },

        // Logging tool state (runtime/transient)
        logging: {
          activeSession: null, // Current session ID
          tempSessions: [], // Temporary sessions (max 6)
          permanentSessions: [], // Permanent sessions
          currentStepNotes: "", // Notes for current step
          sessionNotes: "", // Notes for entire session
          autoSessionActive: false, // Flag for test strip auto-session
        },
      };

      // ===== RENDER FUNCTIONS =====

      // Calculator render functions
      /**
       * @function renderCalculatorDisplay
       * @description Renders the calculator display with current state values.
       * Updates base time, stop value, result time, result details, and timer display.
       * @returns {void}
       * @fires appState.calculator - Reads calculator state
       * @fires Element.textContent - Updates display elements
       * @fires formatStop - Formats stop value for display
       * @example
       * renderCalculatorDisplay(); // Update calculator UI
       */
      function renderCalculatorDisplay() {
        const state = appState.calculator;
        document.getElementById("baseTimeValue").textContent =
          `${state.baseTime.toFixed(1)}s`;
        document.getElementById("stopValue").textContent = formatStop(
          appState.calculator.currentStop,
        );
        document.getElementById("resultTime").textContent =
          state.currentTotalTime.toFixed(2);
        document.getElementById("resultDetails").textContent = `${formatStop(
          state.currentStop,
        )} STOPS`;
        document.getElementById("calcTimerDisplay").textContent =
          state.currentTime.toFixed(2);
      }

      /**
       * @function renderCalculatorExposureDetails
       * @description Renders detailed exposure information for the calculator.
       * Updates selected stop display and other exposure-related details.
       * @returns {void}
       * @fires appState.calculator - Reads calculator state
       * @fires Element.textContent - Updates display elements
       * @fires formatStop - Formats stop value for display
       * @example
       * renderCalculatorExposureDetails(); // Update exposure details UI
       */
      function renderCalculatorExposureDetails() {
        const state = appState.calculator;
        document.getElementById("selectedStopDisplay").textContent = formatStop(
          state.currentStop,
        );
        document.getElementById("previousTotalDisplay").textContent =
          state.accumulatedTime.toFixed(2);
        document.getElementById("currentTotalDisplay").textContent =
          state.currentTotalTime.toFixed(2);
        document.getElementById("thisExposureDisplay").textContent =
          state.thisExposureTime.toFixed(2);
      }

      /**
       * @function renderCalculatorTimerStatus
       * @description Renders the calculator timer status, button states, and display styling.
       * Updates status text, button text/disabled states, and warning styling based on calculator state
       * (countdown, running, paused, or ready).
       * @returns {void}
       * @fires appState.calculator - Reads calculator state
       * @fires appState.ui.timerStatus - Reads UI status text
       * @fires Element.textContent - Updates button and status text
       * @fires Element.disabled - Updates button disabled states
       * @fires Element.classList - Adds/removes warning class
       * @example
       * renderCalculatorTimerStatus(); // Update timer status UI
       */
      function renderCalculatorTimerStatus() {
        const state = appState.calculator;
        const statusElement = document.getElementById("timerStatus");
        const startBtn = document.getElementById("startExposure");
        const stopBtn = document.getElementById("stopCalcTimer");
        const resetBtn = document.getElementById("resetCalcTimer");
        const repeatBtn = document.getElementById("repeatExposure");
        const displayElement = document.getElementById("calcTimerDisplay");

        statusElement.textContent = appState.ui.timerStatus;

        if (state.isCountdown) {
          startBtn.textContent = "Start Exposure";
          startBtn.disabled = true;
          stopBtn.disabled = false;
          resetBtn.disabled = true;
          repeatBtn.disabled = true;
        } else if (state.isRunning) {
          startBtn.textContent = "Pause";
          startBtn.disabled = false;
          stopBtn.disabled = false;
          resetBtn.disabled = true;
          repeatBtn.disabled = true;
        } else if (state.isPaused) {
          startBtn.textContent = "Resume";
          startBtn.disabled = false;
          stopBtn.disabled = false;
          resetBtn.disabled = false;
          repeatBtn.disabled = true;
        } else {
          startBtn.textContent =
            state.accumulatedTime > 0 ? "Start Next" : "Start Exposure";
          startBtn.disabled = false;
          stopBtn.disabled = true;
          resetBtn.disabled = false;
          repeatBtn.disabled = state.lastExposureTime <= 0;
        }

        if (state.currentTime <= 3 && state.isRunning) {
          displayElement.classList.add("warning");
        } else {
          displayElement.classList.remove("warning");
        }
      }

      /**
       * @function renderTimer
       * @description Renders a single timer's display and UI state.
       * Updates timer display, status text, button states, and styling based on timer state.
       * @param {string} timerName - Name of the timer to render (Dev, Stop, Fix, Flo)
       * @returns {void}
       * @throws {Error} If timer state not found
       * @fires appState.timers - Reads timer state
       * @fires Element.textContent - Updates display and status text
       * @fires Element.disabled - Updates button disabled states
       * @fires Element.classList - Adds/removes timer state classes
       * @fires Element.style - Updates styling
       * @example
       * renderTimer("Dev"); // Render Dev timer UI
       */
      function renderTimer(timerName) {
        const state = appState.timers[timerName];
        if (!state) return;

        const display = document.getElementById(`display${timerName}`);
        const button = document.getElementById(`btn${timerName}`);
        const box = document.getElementById(`timer${timerName}`);
        const resetButton = document.querySelector(
          `button[data-timer="${timerName}"][data-action="reset"]`,
        );
        const plusButton = document.querySelector(
          `button[data-timer="${timerName}"][data-action="plus"]`,
        );
        const minusButton = document.querySelector(
          `button[data-timer="${timerName}"][data-action="minus"]`,
        );

        // Update display
        if (display) {
          const roundedTime = Math.round(state.timeLeft);
          const minutes = Math.floor(roundedTime / 60);
          const seconds = roundedTime % 60;
          display.textContent = `${minutes
            .toString()
            .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }

        // Update button states
        if (!state.isEnabled) {
          if (button) button.disabled = true;
          if (resetButton) resetButton.disabled = true;
          if (plusButton) plusButton.disabled = true;
          if (minusButton) minusButton.disabled = true;
          if (box) box.classList.add("disabled");
          return;
        }

        if (button) {
          button.disabled = false;
          button.textContent = state.isRunning ? "Pause" : "Start";
          button.classList.toggle("active", state.isRunning);
        }

        if (resetButton) resetButton.disabled = state.isRunning;
        if (plusButton) plusButton.disabled = state.isRunning;
        if (minusButton) minusButton.disabled = state.isRunning;

        // Update box state
        if (box) {
          box.classList.remove("running", "warning", "complete", "disabled");
          if (state.isRunning) box.classList.add("running");
          if (state.timeLeft === 0) box.classList.add("complete");
          if (!state.isEnabled) box.classList.add("disabled");
        }
      }

      /**
       * @function renderAllTimers
       * @description Renders all timer displays by iterating through appState.timers.
       * Calls renderTimer() for each timer name to update their UI states.
       * @returns {void}
       * @fires appState.timers - Reads all timer states
       * @fires renderTimer - Renders each individual timer
       * @example
       * renderAllTimers(); // Update all timer displays
       */
      function renderAllTimers() {
        Object.keys(appState.timers).forEach((timerName) =>
          renderTimer(timerName),
        );
      }

      /**
       * @function renderSoundSettings
       * @description Renders sound settings checkboxes from appState.
       * Updates all sound-related checkbox states based on current settings.
       * @returns {void}
       * @fires appState.settings - Reads sound settings
       * @fires Element.checked - Updates checkbox states
       * @example
       * renderSoundSettings(); // Update sound settings UI
       */
      function renderSoundSettings() {
        const settings = appState.settings;
        // Only update elements that exist (CALC tab switches removed)
        const calcWarningEl = document.getElementById("calcWarningBeep");
        const calcEndEl = document.getElementById("calcEndBeep");

        if (calcWarningEl) calcWarningEl.checked = settings.calcWarningBeep;
        if (calcEndEl) calcEndEl.checked = settings.calcEndBeep;
      }

      // Tab management - Updated for collapsible navigation
      const tabDropdownItems = document.querySelectorAll(".tab-dropdown-item");
      const tabContents = document.querySelectorAll(".tab-content");
      const menuButton = document.getElementById("menuButton");
      const tabDropdown = document.getElementById("tabDropdown");
      const activeTabName = document.getElementById("activeTabName");

      // Generic feedback display helper - consolidates showAllProfilesFeedback and showShelfLifeFeedback
      function showFeedback(elementId, message, type = "info") {
        const feedbackElement = document.getElementById(elementId);
        if (feedbackElement) {
          feedbackElement.textContent = message;
          feedbackElement.className = `feedback ${type}`;
          feedbackElement.style.display = "block";
          setTimeout(() => {
            feedbackElement.style.display = "none";
          }, CONFIG.AUDIO.FEEDBACK_TIMEOUT_MS);
        }
      }

      function refreshCollapsibleHeights(container = document) {
        const sections = container.querySelectorAll(".collapsible");
        sections.forEach((sec) => {
          const header = sec.querySelector(".collapsible-header");
          const content = sec.querySelector(".collapsible-content");
          if (!header || !content) return;

          const expanded = header.getAttribute("aria-expanded") === "true";
          content.style.maxHeight = expanded
            ? content.scrollHeight + "px"
            : "0px";
        });
      }

      /**
       * @function switchTab
       * @description Switches the active tab and updates related UI components.
       * Removes active class from all dropdown items, adds it to selected item, and triggers
       * tab-specific updates (chart, test strip, chemical, timer, relay).
       * Also updates the active tab name display and closes the dropdown.
       * @param {string} tabId - ID of the tab to activate
       * @returns {void}
       * @fires Element.classList.remove - Removes active class from all dropdown items
       * @fires Element.classList.add - Adds active class to selected dropdown item
       * @fires refreshCollapsibleHeights - Updates collapsible sections
       * @fires updateChart - Updates chart tab
       * @fires fstopTestGenerator.updateDisplay - Updates test strip display
       * @fires chemicalManager.updateDisplay - Updates chemical display
       * @fires settingsManager.updateTimerProfileListUI - Updates timer profiles
       * @fires relayManager.updateRelayButtons - Updates relay controls
       * @example
       * switchTab("calc"); // Switch to calculator tab
       */
      function switchTab(tabId) {
        // Update dropdown items
        tabDropdownItems.forEach((item) => item.classList.remove("active"));
        tabContents.forEach((content) => content.classList.remove("active"));

        tabDropdownItems.forEach((item) => {
          if (item.getAttribute("data-tab") === tabId) {
            item.classList.add("active");
            // Update the active tab name display
            if (activeTabName) {
              activeTabName.textContent = item.textContent;
            }
          }
        });

        const activeTab = document.getElementById(tabId);
        if (activeTab) {
          activeTab.classList.add("active");
          refreshCollapsibleHeights(activeTab);
        }

        // Close the dropdown after selection
        closeMenu();

        // Update tab-specific content
        if (tabId === "chart") {
          updateChart();
        } else if (tabId === "fstop-test") {
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.updateDisplay();
            window.fstopTestGenerator.updateInstructions();
          }
        } else if (tabId === "chemical") {
          if (window.chemicalManager) {
            window.chemicalManager.updateDisplay();
            // Specifically update shelf life list
            window.chemicalManager.updateShelfLifeList();
          }
        } else if (tabId === "timer") {
          if (settingsManager) {
            settingsManager.updateTimerProfileListUI();
          }
        } else if (tabId === "relay") {
          if (window.relayManager) {
            window.relayManager.updateRelayButtons();
          }
          // Update temperature display if enabled
          if (
            window.temperatureManager &&
            window.temperatureManager.isEnabled()
          ) {
            window.temperatureManager.refreshDisplay();
          }
        }
      }

      /**
       * @function openMenu
       * @description Opens the tab dropdown menu.
       * @returns {void}
       * @fires Element.classList.add - Adds 'open' class to dropdown
       * @fires Element.setAttribute - Updates aria attributes
       * @fires Element.focus - Focuses on menu button
       */
      function openMenu() {
        if (tabDropdown && menuButton) {
          tabDropdown.classList.add("open");
          menuButton.setAttribute("aria-expanded", "true");
          tabDropdown.setAttribute("aria-hidden", "false");
          // Focus first dropdown item for keyboard navigation
          const firstItem = tabDropdown.querySelector(".tab-dropdown-item");
          if (firstItem) {
            setTimeout(() => firstItem.focus(), 100);
          }
        }
      }

      /**
       * @function closeMenu
       * @description Closes the tab dropdown menu.
       * @returns {void}
       * @fires Element.classList.remove - Removes 'open' class from dropdown
       * @fires Element.setAttribute - Updates aria attributes
       */
      function closeMenu() {
        if (tabDropdown && menuButton) {
          tabDropdown.classList.remove("open");
          menuButton.setAttribute("aria-expanded", "false");
          tabDropdown.setAttribute("aria-hidden", "true");
        }
      }

      /**
       * @function toggleMenu
       * @description Toggles the tab dropdown menu open/closed state.
       * @returns {void}
       * @fires openMenu - If menu is closed
       * @fires closeMenu - If menu is open
       */
      function toggleMenu() {
        if (tabDropdown && tabDropdown.classList.contains("open")) {
          closeMenu();
        } else {
          openMenu();
        }
      }

      // Event delegation for dropdown items - handles both existing and future tab buttons
      document.addEventListener("click", (e) => {
        const dropdownItem = e.target.closest(".tab-dropdown-item[data-tab]");
        if (dropdownItem) {
          e.preventDefault();
          switchTab(dropdownItem.getAttribute("data-tab"));
        }
      });

      // Menu button click handler
      if (menuButton) {
        menuButton.addEventListener("click", (e) => {
          e.preventDefault();
          toggleMenu();
        });
      }

      // Close dropdown when clicking outside
      document.addEventListener("click", (e) => {
        if (tabDropdown && menuButton) {
          if (
            !tabDropdown.contains(e.target) &&
            !menuButton.contains(e.target)
          ) {
            closeMenu();
          }
        }
      });

      // Keyboard navigation for dropdown
      document.addEventListener("keydown", (e) => {
        if (tabDropdown && tabDropdown.classList.contains("open")) {
          const items = Array.from(
            tabDropdown.querySelectorAll(".tab-dropdown-item"),
          );
          const currentIndex = items.findIndex(
            (item) => item === document.activeElement,
          );

          if (e.key === "Escape") {
            closeMenu();
            menuButton.focus();
          } else if (e.key === "ArrowDown") {
            e.preventDefault();
            const nextIndex = (currentIndex + 1) % items.length;
            items[nextIndex].focus();
          } else if (e.key === "ArrowUp") {
            e.preventDefault();
            const prevIndex = (currentIndex - 1 + items.length) % items.length;
            items[prevIndex].focus();
          } else if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            if (
              document.activeElement.classList.contains("tab-dropdown-item")
            ) {
              const tabId = document.activeElement.getAttribute("data-tab");
              if (tabId) {
                switchTab(tabId);
              }
            }
          }
        }
      });

      // Add event listeners for base time limit inputs
      document.addEventListener("DOMContentLoaded", () => {
        const baseTimeMinInput = document.getElementById("baseTimeMin");
        const baseTimeMaxInput = document.getElementById("baseTimeMax");

        if (baseTimeMinInput && baseTimeMaxInput) {
          baseTimeMinInput.addEventListener("change", () => {
            const minVal = parseFloat(baseTimeMinInput.value);
            const maxVal = parseFloat(baseTimeMaxInput.value);
            if (minVal >= maxVal) {
              baseTimeMinInput.value = (maxVal - 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });

          baseTimeMaxInput.addEventListener("change", () => {
            const minVal = parseFloat(baseTimeMinInput.value);
            const maxVal = parseFloat(baseTimeMaxInput.value);
            if (maxVal <= minVal) {
              baseTimeMaxInput.value = (minVal + 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });
        }

        // Add event listeners for test base time limit inputs
        const testBaseTimeMinInput = document.getElementById("testBaseTimeMin");
        const testBaseTimeMaxInput = document.getElementById("testBaseTimeMax");

        if (testBaseTimeMinInput && testBaseTimeMaxInput) {
          testBaseTimeMinInput.addEventListener("change", () => {
            const minVal = parseFloat(testBaseTimeMinInput.value);
            const maxVal = parseFloat(testBaseTimeMaxInput.value);
            if (minVal >= maxVal) {
              testBaseTimeMinInput.value = (maxVal - 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });

          testBaseTimeMaxInput.addEventListener("change", () => {
            const minVal = parseFloat(testBaseTimeMinInput.value);
            const maxVal = parseFloat(testBaseTimeMaxInput.value);
            if (maxVal <= minVal) {
              testBaseTimeMaxInput.value = (minVal + 1).toFixed(1);
            }
            if (settingsManager) {
              settingsManager.applyLiveSettings();
            }
          });
        }

        // Transfer to TIMER tab button
        const transferBtn = document.getElementById("transferToTimer");
        if (transferBtn) {
          transferBtn.addEventListener("click", () => {
            switchTab("timer");

            // Scroll to top using container (same as SPLIT tab's "Send to CALC" button)
            const container = document.querySelector(".container");
            if (container) {
              container.scrollTop = 0;
            }
            // Also scroll window as fallback
            window.scrollTo(0, 0);

            // Provide visual feedback
            const statusEl = document.getElementById("settingsLiveStatus");
            if (statusEl) {
              statusEl.textContent = "Transferred to TIMER tab";
            }
          });
        }
      });

      // Legacy audio wrapper for backward compatibility

      function initAudioContext() {
        // Deprecated - AudioService handles this now
        if (audioService) {
          audioService.init();
          return audioService.audioContext;
        }
        return null;
      }

      // Legacy playBeep wrapper - redirects to AudioService
      /**
       * @function playBeep
       * @description Plays a beep sound using the audio service.
       * Wrapper for AudioService.playBeep with default parameters from CONFIG.
       * @param {number} frequency - Frequency in Hz (default: CONFIG.AUDIO.BEEP_FREQUENCY_HZ)
       * @param {number} duration - Duration in seconds (default: CONFIG.AUDIO.BEEP_DURATION_SEC)
       * @param {number} volume - Volume 0-1 (default: CONFIG.AUDIO.BEEP_VOLUME)
       * @returns {void}
       * @fires audioService.playBeep - Plays the beep sound
       * @example
       * playBeep(800, 0.1, 0.5); // Play 800Hz beep for 0.1s at 50% volume
       */
      function playBeep(
        frequency = CONFIG.AUDIO.BEEP_FREQUENCY_HZ,
        duration = CONFIG.AUDIO.BEEP_DURATION_SEC,
        volume = CONFIG.AUDIO.BEEP_VOLUME,
      ) {
        if (audioService) {
          audioService.playBeep(frequency, duration, volume);
        }
      }

      /**
       * @function playPreset
       * @description Plays a named audio preset using the audio service.
       * Wrapper for AudioService.playPreset for standardized sound patterns.
       * @param {string} presetName - Name of the preset to play
       * @returns {void}
       * @fires audioService.playPreset - Plays the preset sound
       * @example
       * playPreset("timerComplete"); // Play timer completion sound
       */
      function playPreset(presetName) {
        if (audioService) {
          audioService.playPreset(presetName);
        }
      }

      /**
       * @function playCountdownBeep
       * @description Plays countdown beep pattern based on seconds remaining.
       * Wrapper for AudioService.playCountdownBeep for countdown audio feedback.
       * @param {number} secondsRemaining - Seconds remaining in countdown
       * @returns {void}
       * @fires audioService.playCountdownBeep - Plays countdown pattern
       * @example
       * playCountdownBeep(3); // Play beep for 3 seconds remaining
       */
      function playCountdownBeep(secondsRemaining) {
        if (audioService) {
          audioService.playCountdownBeep(secondsRemaining);
        }
      }

      /**
       * StorageManager - Centralized localStorage handler with error handling
       *
       * Provides a unified interface for all localStorage operations with
       * consistent error handling and key management. All persistence flows
       * through this class to ensure data integrity.
       *
       * @class
       * @example
       * StorageManager.saveSettings({ baseTime: 10.0 });
       * const settings = StorageManager.loadSettings();
       */
      class StorageManager {
        /**
         * Save data as JSON string
         * @static
         * @param {string} key - Storage key
         * @param {*} value - Data to save (will be JSON stringified)
         * @returns {boolean} Success status
         * @description Handles serialization errors and logs failures
         */
        static saveJSON(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
          } catch (e) {
            console.error(`Failed to save ${key}:`, e);
            return false;
          }
        }

        /**
         * Load and parse JSON data
         * @static
         * @param {string} key - Storage key
         * @param {*} fallback - Value to return if load fails or key doesn't exist
         * @returns {*} Parsed data or fallback
         * @description Handles parsing errors and provides fallback values
         */
        static loadJSON(key, fallback) {
          try {
            const saved = localStorage.getItem(key);
            return saved ? JSON.parse(saved) : fallback;
          } catch (e) {
            console.error(`Failed to load ${key}:`, e);
            return fallback;
          }
        }

        /**
         * Remove multiple storage keys
         * @static
         * @param {string[]} keys - Array of keys to remove
         * @returns {boolean} Success status
         * @description Clears all specified keys from localStorage
         */
        static removeKeys(keys) {
          try {
            keys.forEach((k) => localStorage.removeItem(k));
            return true;
          } catch (e) {
            console.error("Failed to clear storage:", e);
            return false;
          }
        }

        /**
         * Save user settings
         * @static
         * @param {Object} settings - Settings object
         * @returns {boolean} Success status
         */
        static saveSettings(settings) {
          return this.saveJSON(STORAGE_KEYS.SETTINGS, settings);
        }

        /**
         * Load user settings
         * @static
         * @returns {Object} Settings object with defaults
         */
        static loadSettings() {
          return this.loadJSON(STORAGE_KEYS.SETTINGS, { ...DEFAULT_SETTINGS });
        }

        /**
         * Save timer profiles
         * @static
         * @param {Array} profiles - Array of profile objects
         * @returns {boolean} Success status
         */
        static saveProfiles(profiles) {
          return this.saveJSON(STORAGE_KEYS.PROFILES, profiles);
        }

        /**
         * Load timer profiles
         * @static
         * @returns {Array} Array of profile objects
         */
        static loadProfiles() {
          return this.loadJSON(STORAGE_KEYS.PROFILES, []);
        }

        /**
         * Save currently loaded profile name
         * @static
         * @param {string|null} profileName - Name of current profile or null
         * @returns {boolean} Success status
         */
        static saveCurrentProfile(profileName) {
          return this.saveJSON(STORAGE_KEYS.CURRENT_PROFILE, profileName);
        }

        /**
         * Load currently loaded profile name
         * @static
         * @returns {string|null} Profile name or null
         */
        static loadCurrentProfile() {
          return this.loadJSON(STORAGE_KEYS.CURRENT_PROFILE, null);
        }

        /**
         * Save color scheme preference
         * @static
         * @param {string} scheme - Color scheme name ('dark', 'light', 'day')
         * @returns {boolean} Success status
         */
        static saveColorScheme(scheme) {
          return this.saveJSON(STORAGE_KEYS.COLOR_SCHEME, scheme);
        }

        /**
         * Load color scheme preference
         * @static
         * @returns {string} Color scheme name
         */
        static loadColorScheme() {
          return this.loadJSON(STORAGE_KEYS.COLOR_SCHEME, "dark");
        }

        /**
         * Save chemical presets
         * @static
         * @param {Array} presets - Array of chemical preset objects
         * @returns {boolean} Success status
         */
        static saveChemicalPresets(presets) {
          return this.saveJSON(STORAGE_KEYS.CHEMICAL_PRESETS, presets);
        }

        /**
         * Load chemical presets
         * @static
         * @returns {Array} Array of chemical preset objects
         */
        static loadChemicalPresets() {
          return this.loadJSON(STORAGE_KEYS.CHEMICAL_PRESETS, []);
        }

        /**
         * Save developer capacity tracker data
         * @static
         * @param {Object} data - Capacity data object
         * @returns {boolean} Success status
         */
        static saveCapacityTracker(data) {
          return this.saveJSON(STORAGE_KEYS.CAPACITY_TRACKER, data);
        }

        /**
         * Load developer capacity tracker data
         * @static
         * @returns {Object} Capacity data with defaults
         */
        static loadCapacityTracker() {
          return this.loadJSON(STORAGE_KEYS.CAPACITY_TRACKER, {
            printsDone: 0,
            areaUsed: 0,
            paperSize: 0.052,
            lastReset: new Date().toISOString(),
          });
        }

        /**
         * Save shelf life tracking data
         * @static
         * @param {Array} chemicals - Array of chemical objects
         * @returns {boolean} Success status
         */
        static saveShelfLife(chemicals) {
          return this.saveJSON(STORAGE_KEYS.SHELF_LIFE, chemicals);
        }

        /**
         * Load shelf life tracking data
         * @static
         * @returns {Array} Array of chemical objects
         */
        static loadShelfLife() {
          return this.loadJSON(STORAGE_KEYS.SHELF_LIFE, []);
        }

        /**
         * Save custom filter banks
         * @static
         * @param {Array} banks - Array of filter bank objects
         * @returns {boolean} Success status
         */
        static saveCustomFilterBanks(banks) {
          return this.saveJSON(STORAGE_KEYS.CUSTOM_FILTER_BANKS, banks);
        }

        /**
         * Load custom filter banks
         * @static
         * @returns {Array} Array of filter bank objects with defaults
         */
        static loadCustomFilterBanks() {
          return this.loadJSON(
            STORAGE_KEYS.CUSTOM_FILTER_BANKS,
            getDefaultCustomFilterBanks(),
          );
        }

        /**
         * Save test strip profiles
         * @static
         * @param {Array} profiles - Array of test strip profile objects
         * @returns {boolean} Success status
         */
        static saveTestStripProfiles(profiles) {
          return this.saveJSON(STORAGE_KEYS.TEST_STRIP_PROFILES, profiles);
        }

        /**
         * Load test strip profiles
         * @static
         * @returns {Array} Array of test strip profile objects
         */
        static loadTestStripProfiles() {
          return this.loadJSON(STORAGE_KEYS.TEST_STRIP_PROFILES, []);
        }

        /**
         * Save currently loaded test strip profile name
         * @static
         * @param {string|null} profileName - Profile name or null
         * @returns {boolean} Success status
         */
        static saveCurrentTestStripProfile(profileName) {
          return this.saveJSON(
            STORAGE_KEYS.CURRENT_TEST_STRIP_PROFILE,
            profileName,
          );
        }

        /**
         * Load currently loaded test strip profile name
         * @static
         * @returns {string|null} Profile name or null
         */
        static loadCurrentTestStripProfile() {
          return this.loadJSON(STORAGE_KEYS.CURRENT_TEST_STRIP_PROFILE, null);
        }

        /**
         * Save split-grade presets
         * @static
         * @param {Array} presets - Array of split-grade preset objects
         * @returns {boolean} Success status
         */
        static saveSplitPresets(presets) {
          return this.saveJSON(STORAGE_KEYS.SPLIT_GRADE_PRESETS, presets);
        }

        /**
         * Load split-grade presets
         * @static
         * @returns {Array} Array of split-grade preset objects
         */
        static loadSplitPresets() {
          return this.loadJSON(STORAGE_KEYS.SPLIT_GRADE_PRESETS, []);
        }

        /**
         * Save currently loaded split-grade preset name
         * @static
         * @param {string|null} presetName - Preset name or null
         * @returns {boolean} Success status
         */
        static saveCurrentSplitPreset(presetName) {
          return this.saveJSON(STORAGE_KEYS.CURRENT_SPLIT_PRESET, presetName);
        }

        /**
         * Load currently loaded split-grade preset name
         * @static
         * @returns {string|null} Preset name or null
         */
        static loadCurrentSplitPreset() {
          return this.loadJSON(STORAGE_KEYS.CURRENT_SPLIT_PRESET, null);
        }

        /**
         * Save test strip transfer destination preference
         * @static
         * @param {string} destination - 'calc' or 'split'
         * @returns {boolean} Success status
         */
        static saveTestTransferDestination(destination) {
          return this.saveJSON(
            STORAGE_KEYS.TEST_TRANSFER_DESTINATION,
            destination,
          );
        }

        /**
         * Load test strip transfer destination preference
         * @static
         * @returns {string} 'calc' or 'split' (defaults to 'calc')
         */
        static loadTestTransferDestination() {
          return this.loadJSON(STORAGE_KEYS.TEST_TRANSFER_DESTINATION, "calc");
        }

        /**
         * Clear all stored data
         * @static
         * @returns {boolean} Success status
         * @description Removes ALL application data from localStorage
         */
        static clearAll() {
          return this.removeKeys([
            STORAGE_KEYS.SETTINGS,
            STORAGE_KEYS.PROFILES,
            STORAGE_KEYS.CURRENT_PROFILE,
            STORAGE_KEYS.COLOR_SCHEME,
            STORAGE_KEYS.CHEMICAL_PRESETS,
            STORAGE_KEYS.CAPACITY_TRACKER,
            STORAGE_KEYS.SHELF_LIFE,
            STORAGE_KEYS.CUSTOM_FILTER_BANKS,
            STORAGE_KEYS.TEST_STRIP_PROFILES,
            STORAGE_KEYS.CURRENT_TEST_STRIP_PROFILE,
            STORAGE_KEYS.SPLIT_GRADE_PRESETS,
            STORAGE_KEYS.CURRENT_SPLIT_PRESET,
            STORAGE_KEYS.TEST_TRANSFER_DESTINATION,
          ]);
        }
      }

      /**
       * Timer - Individual timer instance for darkroom processes
       *
       * Manages a single countdown timer with drift-corrected precision.
       * Supports auto-sequencing between timers and provides visual feedback.
       * Four instances are typically used: Dev, Stop, Fix, Flo.
       *
       * @class
       * @example
       * const devTimer = new Timer('Dev');
       * devTimer.setTime(60);
       * devTimer.start();
       */
      class Timer {
        /**
         * Creates a Timer instance
         * @constructor
         * @param {string} name - Timer identifier ('Dev', 'Stop', 'Fix', or 'Flo')
         * @property {string} name - Timer identifier
         * @property {DriftCorrectedTimer|null} driftTimer - High-precision timer instance
         * @property {boolean} warningPlayed - Whether 10-second warning has played
         * @property {boolean} isPartOfSequence - Whether timer is part of auto-chain
         */
        constructor(name) {
          this.name = name;
          this.driftTimer = null; // Using drift-corrected timer
          this.warningPlayed = false;
          this.isPartOfSequence = false; // NEW: Track if timer is part of a sequence

          // Initialize state if not exists
          if (!appState.timers[name]) {
            appState.timers[name] = {
              timeLeft: DEFAULT_TIMER_TIMES[name] || 60,
              totalTime: DEFAULT_TIMER_TIMES[name] || 60,
              isRunning: false,
              isEnabled: true,
            };
          }

          // Initialize display immediately
          this.render();
        }

        /**
         * Get current timer state from appState
         * @returns {Object} Timer state object
         */
        get state() {
          return appState.timers[this.name];
        }

        /**
         * Render timer display
         * @returns {void}
         * @description Updates UI elements for this timer
         */
        render() {
          renderTimer(this.name);
        }

        /**
         * Update display (deprecated - use render instead)
         * @deprecated Use render() instead
         * @returns {void}
         */
        updateDisplay() {
          // Deprecated - use render() instead
          this.render();
        }

        /**
         * Update button states (deprecated - use render instead)
         * @deprecated Use render() instead
         * @returns {void}
         */
        updateButtonStates() {
          // Deprecated - use render() instead
          this.render();
        }

        /**
         * Set timer duration
         * @param {number} seconds - Duration in seconds (5-600)
         * @returns {void}
         * @description Stops timer if running and sets new duration
         */
        setTime(seconds) {
          // Stop if running
          if (this.state.isRunning) {
            if (this.driftTimer) {
              this.driftTimer.stop();
            }
            this.state.isRunning = false;
          }

          // Round to whole seconds
          const roundedSeconds = Math.round(seconds);

          // Set new time in state
          this.state.totalTime = roundedSeconds;
          this.state.timeLeft = roundedSeconds;
          this.warningPlayed = false;

          // Update display
          this.render();
        }

        /**
         * Adjust timer duration
         * @param {number} seconds - Amount to adjust (+/-)
         * @returns {void}
         * @description Adds/subtracts from current duration (5-600s range)
         * Supports hold-to-adjust for continuous increments
         */
        adjustTime(seconds) {
          if (this.state.isRunning || !this.state.isEnabled) return;

          const newTime = Math.round(this.state.totalTime + seconds);
          if (newTime >= 5 && newTime <= 600) {
            this.state.totalTime = newTime;
            this.state.timeLeft = newTime;
            this.render();
          }
        }

        /**
         * Start the timer
         * @param {boolean} [isSequence=false] - Whether this is part of an auto-chain
         * @returns {void}
         * @description Begins countdown with drift-corrected timing
         */
        start(isSequence = false) {
          if (
            this.state.isRunning ||
            !this.state.isEnabled ||
            this.state.timeLeft <= 0
          )
            return;

          // Log timer start and end current session
          if (window.exposureLogManager && !isSequence) {
            const timerData = {
              dev: appState.timers.Dev.timeLeft,
              stop: appState.timers.Stop.timeLeft,
              fix: appState.timers.Fix.timeLeft,
              flo: appState.timers.Flo.timeLeft,
            };
            window.exposureLogManager.addTimerPhaseAndEnd(timerData);
          }

          this.state.isRunning = true;
          this.warningPlayed = false;
          this.isPartOfSequence = isSequence; // NEW: Store sequence flag
          this.render();

          // Use drift-corrected timer
          this.driftTimer = new DriftCorrectedTimer(() => {
            this.state.timeLeft--;
            this.render();

            // 10-second warning
            if (
              this.state.timeLeft === 10 &&
              appState.settings.timerWarningBeep &&
              this.state.isEnabled
            ) {
              const box = document.getElementById(`timer${this.name}`);
              if (box) box.classList.add("warning");
              playPreset("timerWarning");
              this.warningPlayed = true;
            }

            // Timer ended
            if (this.state.timeLeft <= 0) {
              this.complete();
            }
          }, 1000);

          this.driftTimer.start();
        }

        /**
         * Stop the timer
         * @returns {void}
         * @description Halts countdown and resets sequence flag
         */
        stop() {
          if (!this.state.isRunning) return;

          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.state.isRunning = false;
          this.isPartOfSequence = false; // NEW: Reset sequence flag
          this.render();
        }

        /**
         * Reset timer to initial duration
         * @returns {void}
         * @description Stops timer and resets time to total duration
         */
        reset() {
          if (this.state.isRunning || !this.state.isEnabled) return;

          this.stop();
          this.state.timeLeft = this.state.totalTime;
          this.warningPlayed = false;
          this.render();
        }

        /**
         * Handle timer completion
         * @returns {void}
         * @description Plays completion sound and starts next timer in sequence
         */
        complete() {
          this.state.isRunning = false;
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.state.timeLeft = 0;
          this.render();

          if (appState.settings.timerEndBeep && this.state.isEnabled) {
            playPreset("timerComplete");
          }

          // NEW: Only auto-start next timer if this was part of a sequence
          if (this.isPartOfSequence) {
            const nextTimer = this.startNextTimer();
            // If no next timer was started, the sequence is complete
            if (!nextTimer) {
              // Reset the start all state
              if (window.startAllState) {
                window.startAllState.isRunning = false;
                window.startAllState.isPaused = false;
                // Update the button
                const btn = document.getElementById("startAll");
                if (btn) {
                  btn.textContent = "Start All";
                  btn.disabled = false;
                }
              }
            }
          }
          // Reset the flag after completion
          this.isPartOfSequence = false;
        }

        /**
         * Toggle timer start/stop
         * @returns {void}
         * @description Starts if stopped, stops if running
         */
        toggle() {
          if (!this.state.isEnabled) return;

          if (this.state.isRunning) {
            this.stop();
          } else {
            if (this.state.timeLeft <= 0) {
              this.reset();
            }
            // NEW: Individual start is NOT part of a sequence
            this.start(false);
          }
        }

        /**
         * Enable or disable timer
         * @param {boolean} enabled - Whether timer should be enabled
         * @returns {void}
         * @description Updates enabled state and visual appearance
         */
        updateEnabledState(enabled) {
          this.state.isEnabled = enabled;
          const box = document.getElementById(`timer${this.name}`);
          if (box) {
            if (enabled) {
              box.classList.remove("disabled");
            } else {
              box.classList.add("disabled");
              this.stop();
            }
          }
          this.render();
        }

        /**
         * Start next timer in sequence
         * @returns {Timer|null} The next timer that was started, or null
         * @description Finds and starts the next enabled timer after this one
         */
        startNextTimer() {
          const timerOrder = ["Dev", "Stop", "Fix", "Flo"];
          const currentIndex = timerOrder.indexOf(this.name);

          for (let i = currentIndex + 1; i < timerOrder.length; i++) {
            const nextTimerName = timerOrder[i];
            const nextTimer = timerManager.timers.find(
              (t) => t.name === nextTimerName,
            );

            if (nextTimer && nextTimer.state.isEnabled) {
              setTimeout(() => {
                nextTimer.reset();
                // NEW: Start next timer as part of sequence
                nextTimer.start(true);
              }, 1000);
              return nextTimer; // Return the next timer that was started
            }
          }
          return null; // No next timer found
        }

        /**
         * Get current timer duration
         * @returns {number} Total duration in seconds
         */
        getCurrentTime() {
          return this.state.totalTime;
        }
      }

      /**
       * CountdownManager - Visual and audio countdown before exposure
       *
       * Provides a configurable countdown delay with visual feedback and
       * audible beeps. Supports multiple beep patterns and theme-aware styling.
       * Used before starting any exposure timer.
       *
       * @class
       * @example
       * const countdown = new CountdownManager();
       * await countdown.startCountdown(displayElement, () => {
       *   // Start exposure after countdown
       * });
       */
      class CountdownManager {
        /**
         * Creates a CountdownManager instance
         * @constructor
         * @property {boolean} isActive - Whether countdown is currently running
         * @property {number} countdownValue - Current countdown number
         * @property {number|null} countdownInterval - Interval identifier
         * @property {Function|null} onCompleteCallback - Callback when countdown completes
         * @property {HTMLElement|null} displayElement - Element to update display
         * @property {boolean} beepEnabled - Whether audio feedback is enabled
         * @property {string} beepPattern - Beep pattern: 'every-second', 'last3', 'last5', 'none'
         * @property {string} originalDisplay - Original text content of display
         * @property {string} originalBackground - Original background color
         * @property {string} originalColor - Original text color
         */
        constructor() {
          this.isActive = false;
          this.countdownValue = 5;
          this.countdownInterval = null;
          this.onCompleteCallback = null;
          this.displayElement = null;
          this.beepEnabled = true;
        }

        /**
         * Start the countdown
         * @async
         * @param {HTMLElement} displayElement - Element to show countdown
         * @param {Function} onComplete - Callback to execute when countdown finishes
         * @returns {Promise<void>}
         * @description Loads settings, saves original display state, and begins countdown
         */
        startCountdown(displayElement, onComplete) {
          if (this.isActive) return;

          this.isActive = true;
          this.displayElement = displayElement;
          this.onCompleteCallback = onComplete;

          // Get settings
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
            this.beepEnabled = settingsManager.settings.countdownBeep !== false;
            this.beepPattern =
              settingsManager.settings.countdownPattern || "every-second";
          }

          // Save original display value
          this.originalDisplay = displayElement.textContent;
          this.originalBackground = displayElement.style.backgroundColor;
          this.originalColor = displayElement.style.color;

          // Start countdown with initial beep (if pattern allows)
          if (this.beepEnabled && this.beepPattern !== "none") {
            // Check if pattern allows initial beep
            const pattern = this.beepPattern || "every-second";
            const shouldBeep =
              pattern === "every-second" ||
              (pattern === "last3" && this.countdownValue <= 3) ||
              (pattern === "last5" && this.countdownValue <= 5);

            if (shouldBeep) {
              playCountdownBeep(this.countdownValue);
            }
          }

          this.updateCountdown();
        }

        /**
         * Update countdown display and schedule next tick
         * @private
         * @returns {void}
         * @description Updates visual display, plays beeps, and decrements counter
         */
        updateCountdown() {
          if (this.countdownValue <= 0) {
            this.complete();
            return;
          }

          // Update display
          if (this.displayElement) {
            this.displayElement.textContent = this.countdownValue;
            this.displayElement.style.fontWeight = "bold";

            // Flash effect for last 3 seconds
            if (this.countdownValue <= 3) {
              this.displayElement.style.backgroundColor = "#400";
              this.displayElement.style.color = "#fff";

              if (this.countdownValue <= 1) {
                this.displayElement.style.backgroundColor = "#f00";
              }
            } else {
              this.displayElement.style.backgroundColor = "#300";
              this.displayElement.style.color = "#f00";
            }

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              if (this.countdownValue <= 3) {
                this.displayElement.style.backgroundColor = "#0066cc";
                this.displayElement.style.color = "#fff";
              } else {
                this.displayElement.style.backgroundColor = "#cce5ff";
                this.displayElement.style.color = "#0066cc";
              }
            } else if (document.body.classList.contains("day-scheme")) {
              if (this.countdownValue <= 3) {
                this.displayElement.style.backgroundColor = "#ffcc00";
                this.displayElement.style.color = "#000";
              } else {
                this.displayElement.style.backgroundColor = "#ffdd66";
                this.displayElement.style.color = "#ffcc00";
              }
            }
          }

          // Play beep based on pattern
          if (this.beepEnabled) {
            const pattern = this.beepPattern || "every-second";
            let shouldBeep = false;

            switch (pattern) {
              case "every-second":
                shouldBeep = true;
                break;
              case "last3":
                shouldBeep = this.countdownValue <= 3;
                break;
              case "last5":
                shouldBeep = this.countdownValue <= 5;
                break;
              case "none":
                shouldBeep = false;
                break;
              default:
                shouldBeep = true;
            }

            if (shouldBeep) {
              // Use countdown beep with time-based patterns
              playCountdownBeep(this.countdownValue);
            }
          }

          this.countdownValue--;

          // Schedule next update
          this.countdownInterval = setTimeout(
            () => this.updateCountdown(),
            1000,
          );
        }

        /**
         * Complete the countdown
         * @returns {void}
         * @description Restores display, plays final beep, and executes callback
         */
        complete() {
          this.isActive = false;
          clearTimeout(this.countdownInterval);

          // Final beep
          if (this.beepEnabled) {
            playPreset("countdownComplete");
          }

          // Restore display
          if (this.displayElement) {
            this.displayElement.textContent = this.originalDisplay;
            this.displayElement.style.backgroundColor =
              this.originalBackground || "";
            this.displayElement.style.color = this.originalColor || "";
            this.displayElement.style.fontWeight = "";
          }

          // Reset countdown value for next use
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
          } else {
            this.countdownValue = 5;
          }

          // Call completion callback
          if (this.onCompleteCallback) {
            this.onCompleteCallback();
          }
        }

        /**
         * Cancel the countdown
         * @returns {void}
         * @description Stops countdown and restores display without executing callback
         */
        cancel() {
          this.isActive = false;
          clearTimeout(this.countdownInterval);

          // Restore display
          if (this.displayElement) {
            this.displayElement.textContent = this.originalDisplay;
            this.displayElement.style.backgroundColor =
              this.originalBackground || "";
            this.displayElement.style.color = this.originalColor || "";
            this.displayElement.style.fontWeight = "";
          }

          // Reset countdown value
          if (settingsManager) {
            this.countdownValue = settingsManager.settings.countdownDelay || 5;
          } else {
            this.countdownValue = 5;
          }
        }
      }

      /**
       * SettingsManager - Manages user preferences and application configuration
       *
       * Handles loading, saving, and applying all user settings including:
       * - Timer defaults and durations
       * - Sound preferences
       * - Color scheme
       * - Countdown settings
       * - Test strip auto-advance
       * - Safelight auto-off
       * - F-stop denominator
       * - Base time slider limits
       *
       * @class
       * @example
       * const settings = new SettingsManager();
       * settings.saveGlobalSettings();
       */
      class SettingsManager {
        /**
         * Creates a SettingsManager instance
         * @constructor
         * @property {Object} settings - Current settings object
         * @property {Array} profiles - Timer profiles array
         * @property {string} colorScheme - Current color scheme
         * @description Loads settings from storage and applies them to UI and appState
         */
        constructor() {
          this.settings = StorageManager.loadSettings();
          this.profiles = StorageManager.loadProfiles();
          this.colorScheme = StorageManager.loadColorScheme();

          // Load persistent UI state into appState (single source of truth)
          appState.persistent.currentProfile =
            StorageManager.loadCurrentProfile();

          // Sync loaded settings to appState
          Object.assign(appState.settings, this.settings);

          this.applyColorScheme();
          this.applySoundSettings();

          // Apply auto advance setting to F-Stop Test generator
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.setAutoAdvance(
              this.settings.autoAdvance || false,
            );
            // Apply transfer destination setting
            window.fstopTestGenerator.setTransferDestination(
              this.settings.testTransferDestination || "calc",
            );
          }

          // Ensure chemical manager is available
          if (window.chemicalManager) {
            // Load any existing chemical data
            window.chemicalManager.chemicalPresets =
              StorageManager.loadChemicalPresets();
            window.chemicalManager.capacityData =
              StorageManager.loadCapacityTracker();
            window.chemicalManager.shelfLifeData =
              StorageManager.loadShelfLife();
          }

          // Clear button listener is set up via global delegation in DOMContentLoaded
        }

        /**
         * Apply sound settings to appState and UI
         * @returns {void}
         * @description Syncs sound preferences from settings to appState and updates UI
         */
        applySoundSettings() {
          // Apply sound settings from saved settings and sync to appState
          if (this.settings.calcWarningBeep !== undefined) {
            appState.settings.calcWarningBeep = this.settings.calcWarningBeep;
          }
          if (this.settings.calcEndBeep !== undefined) {
            appState.settings.calcEndBeep = this.settings.calcEndBeep;
          }
          if (this.settings.timerWarningBeep !== undefined) {
            appState.settings.timerWarningBeep = this.settings.timerWarningBeep;
          }
          if (this.settings.timerEndBeep !== undefined) {
            appState.settings.timerEndBeep = this.settings.timerEndBeep;
          }

          // Update UI to reflect state
          renderSoundSettings();
        }

        /**
         * Apply color scheme to document body
         * @returns {void}
         * @description Updates CSS classes and saves scheme preference
         */
        applyColorScheme() {
          document.body.classList.remove(
            "dark-scheme",
            "light-scheme",
            "day-scheme",
          );
          document.body.classList.add(`${this.colorScheme}-scheme`);

          document
            .querySelectorAll(".toggle-btn[data-scheme]")
            .forEach((btn) => {
              btn.classList.remove("active");
              if (btn.getAttribute("data-scheme") === this.colorScheme) {
                btn.classList.add("active");
              }
            });

          this.settings.colorScheme = this.colorScheme;
          StorageManager.saveSettings(this.settings);
        }

        /**
         * Set and apply color scheme
         * @param {string} scheme - Color scheme name ('dark', 'light', or 'day')
         * @returns {void}
         */
        setColorScheme(scheme) {
          if (["dark", "light", "day"].includes(scheme)) {
            this.colorScheme = scheme;
            StorageManager.saveColorScheme(scheme);
            this.applyColorScheme();
          }
        }

        /**
         * Get currently loaded profile name
         * @returns {string|null} Current profile name or null
         * @description Uses appState as single source of truth
         */
        getCurrentProfile() {
          return appState.persistent.currentProfile;
        }

        /**
         * Set currently loaded profile name
         * @param {string|null} profileName - Profile name or null
         * @description Updates appState and persists to storage
         */
        setCurrentProfile(profileName) {
          appState.persistent.currentProfile = profileName;
          StorageManager.saveCurrentProfile(profileName);
        }

        /**
         * Read current UI values into settings object
         * @returns {void}
         * @description Collects all settings from UI controls
         */
        readSettingsFromUI() {
          this.settings = {
            baseTime: parseFloat(
              document.getElementById("settingBaseTime").value,
            ),
            devTime: parseInt(document.getElementById("settingDevTime").value),
            stopTime: parseInt(
              document.getElementById("settingStopTime").value,
            ),
            fixTime: parseInt(document.getElementById("settingFixTime").value),
            floTime: parseInt(document.getElementById("settingFloTime").value),
            calcWarningBeep: document.getElementById("settingCalcWarningBeep")
              .checked,
            calcEndBeep: document.getElementById("settingCalcEndBeep").checked,
            timerWarningBeep: document.getElementById("settingTimerWarningBeep")
              .checked,
            timerEndBeep: document.getElementById("settingTimerEndBeep")
              .checked,
            colorScheme: this.colorScheme,
            countdownDelay: parseInt(
              document.getElementById("settingCountdownDelay").value,
            ),
            countdownBeep: document.getElementById("settingCountdownBeep")
              .checked,
            countdownPattern: document.getElementById("settingCountdownPattern")
              .value,
            autoAdvance: document.getElementById("settingAutoAdvance").checked,
            autoAdvanceDelay: parseInt(
              document.getElementById("settingAutoAdvanceDelay").value,
            ),
            safelightAutoOff:
              document.getElementById("safelightAutoOff").checked, // NEW
            proofStabilityEnabled: document.getElementById(
              "proofStabilityEnabled",
            )?.checked,
            proofStabilityBeep: document.getElementById(
              "proofStabilityBeep",
            )?.checked,
            proofStabilityTolerance: parseFloat(
              document.getElementById("proofStabilityTolerance")?.value ||
                DEFAULT_SETTINGS.proofStabilityTolerance,
            ),
            proofStabilityMinStable: parseInt(
              document.getElementById("proofStabilityMinStable")?.value ||
                DEFAULT_SETTINGS.proofStabilityMinStable,
              10,
            ),
            proofStabilityMaxWait: parseInt(
              document.getElementById("proofStabilityMaxWait")?.value ||
                DEFAULT_SETTINGS.proofStabilityMaxWait,
              10,
            ),
            proofStabilityMinDelta: parseFloat(
              document.getElementById("proofStabilityMinDelta")?.value ||
                DEFAULT_SETTINGS.proofStabilityMinDelta,
            ),
            // Base time slider limits
            baseTimeMin: parseFloat(
              document.getElementById("baseTimeMin")?.value || 0.4,
            ),
            baseTimeMax: parseFloat(
              document.getElementById("baseTimeMax")?.value || 50,
            ),
            // Test base time slider limits
            testBaseTimeMin: parseFloat(
              document.getElementById("testBaseTimeMin")?.value || 1,
            ),
            testBaseTimeMax: parseFloat(
              document.getElementById("testBaseTimeMax")?.value || 50,
            ),
            // Test strip transfer destination (from segmented control in TEST tab)
            testTransferDestination: (function () {
              // Check if fstopTestGenerator exists and has a transfer destination
              if (window.fstopTestGenerator) {
                return window.fstopTestGenerator.transferDestination || "calc";
              }
              // Fallback to storage or default
              return StorageManager.loadTestTransferDestination();
            })(),
            // F-stop denominator setting (2, 3, or 4) - Settings select takes precedence, then segmented controls, then legacy selects
            stopDenominator: (function () {
              const settingsSel = document.getElementById(
                "settingStopIncrement",
              );
              if (settingsSel && settingsSel.value)
                return parseInt(settingsSel.value, 10) || 3;
              function fromSeg(id) {
                const s = document.getElementById(id);
                if (!s) return null;
                const active =
                  s.querySelector(".segmented-btn.active") ||
                  s.querySelector('.segmented-btn[aria-pressed="true"]');
                if (active) return parseInt(active.dataset.denom, 10);
                return null;
              }
              const cs = fromSeg("calcIncrementSeg");
              if (cs) return cs;
              const ts = fromSeg("testIncrementSeg");
              if (ts) return ts;
              // backward compatibility with legacy <select>
              const c = document.getElementById("calcIncrementDenom");
              const t = document.getElementById("testIncrementDenom");
              if (c) return parseInt(c.value, 10) || 3;
              if (t) return parseInt(t.value, 10) || 3;
              return 3;
            })(),
          };
        }

        /**
         * Apply settings to runtime and UI
         * @returns {void}
         * @description Updates all components with current settings values
         */
        applySettingsToRuntime() {
          // Apply to UI
          this.applySoundSettings();

          // Apply auto advance to F-Stop Test generator
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.setAutoAdvance(this.settings.autoAdvance);
            window.fstopTestGenerator.setAutoAdvanceDelay(
              this.settings.autoAdvanceDelay * 1000,
            ); // Convert to ms
          }

          // Apply base time slider limits
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            const newMin = parseFloat(this.settings.baseTimeMin) || 0.4;
            const newMax = parseFloat(this.settings.baseTimeMax) || 50;
            baseSlider.min = newMin;
            baseSlider.max = newMax;
            // Ensure current value is within new range
            const currentValue = parseFloat(baseSlider.value);
            if (currentValue < newMin) baseSlider.value = newMin;
            if (currentValue > newMax) baseSlider.value = newMax;
          }

          // Apply test base time slider limits
          const testBaseSlider = document.getElementById("testBaseSlider");
          if (testBaseSlider) {
            const newMin = parseFloat(this.settings.testBaseTimeMin) || 1;
            const newMax = parseFloat(this.settings.testBaseTimeMax) || 50;
            testBaseSlider.min = newMin;
            testBaseSlider.max = newMax;
            // Ensure current value is within new range
            const currentValue = parseFloat(testBaseSlider.value);
            if (currentValue < newMin) testBaseSlider.value = newMin;
            if (currentValue > newMax) testBaseSlider.value = newMax;
          }

          // Apply base time to calculators and test generator so UI updates immediately
          const newBase = parseFloat(this.settings.baseTime);
          const baseSliderEl = document.getElementById("baseTimeSlider");
          if (baseSliderEl) {
            baseSliderEl.value = newBase;
            baseSliderEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
          const testBaseEl = document.getElementById("testBaseSlider");
          if (testBaseEl) {
            testBaseEl.value = newBase;
            testBaseEl.dispatchEvent(new Event("input", { bubbles: true }));
          }
          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = newBase;
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }
          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.baseTime = newBase;
            if (window.fstopTestGenerator.testBaseSlider) {
              window.fstopTestGenerator.testBaseSlider.value = newBase;
            }
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }

          // Apply saved timer default times to Timer instances and DEFAULT_TIMER_TIMES
          if (
            typeof DEFAULT_TIMER_TIMES !== "undefined" &&
            timerManager &&
            timerManager.timers
          ) {
            const mapping = {
              Dev: parseInt(this.settings.devTime, 10),
              Stop: parseInt(this.settings.stopTime, 10),
              Fix: parseInt(this.settings.fixTime, 10),
              Flo: parseInt(this.settings.floTime, 10),
            };

            // Update DEFAULT_TIMER_TIMES so newly created timers use the saved defaults
            Object.keys(mapping).forEach((k) => {
              if (typeof mapping[k] === "number" && !isNaN(mapping[k])) {
                DEFAULT_TIMER_TIMES[k] = mapping[k];
              }
            });

            // Update existing timer instances
            timerManager.timers.forEach((timer) => {
              const newTime = mapping[timer.name];
              if (typeof newTime === "number" && !isNaN(newTime)) {
                const roundedTime = Math.round(newTime);
                if (!timer.isRunning) {
                  // Reset to new default
                  timer.setTime(roundedTime);
                } else {
                  // If running, update total and remaining time without interrupting display logic
                  timer.totalTime = roundedTime;
                  timer.timeLeft = roundedTime;
                  timer.warningPlayed = false;
                  timer.updateDisplay();
                  timer.updateButtonStates();
                }
              }
            });
          }

          // Apply f-stop denominator setting (2, 3, 4)
          (function applyDenominator() {
            const denom = parseInt(this.settings.stopDenominator, 10) || 3;
            window.stopDenominator = denom;
            // Apply to segmented controls if present
            function setSeg(containerId, d) {
              const cont = document.getElementById(containerId);
              if (!cont) return;
              Array.from(cont.querySelectorAll(".segmented-btn")).forEach(
                (b) => {
                  if (parseInt(b.dataset.denom, 10) === d) {
                    b.classList.add("active");
                    b.setAttribute("aria-pressed", "true");
                  } else {
                    b.classList.remove("active");
                    b.setAttribute("aria-pressed", "false");
                  }
                },
              );
            }
            setSeg("calcIncrementSeg", denom);
            setSeg("testIncrementSeg", denom);
            // Legacy selects (back-compat)
            const c = document.getElementById("calcIncrementDenom");
            const t = document.getElementById("testIncrementDenom");
            if (c) c.value = denom;
            if (t) t.value = denom;
            const settingsSel = document.getElementById("settingStopIncrement");
            if (settingsSel) settingsSel.value = denom;
            if (window.incrementalTimer) {
              window.incrementalTimer.updateCalculations();
              window.incrementalTimer.updateAllDisplays();
            }
            if (window.fstopTestGenerator) {
              window.fstopTestGenerator.generateSteps();
              window.fstopTestGenerator.updateDisplay();
            }
            try {
              updateAllRulers();
            } catch (e) {
              /* ignore if not yet defined */
            }
            try {
              updateChart();
            } catch (e) {}
          }).call(this);

          if (window.lightMeterManager) {
            const stability = window.lightMeterManager.proof.stability;
            stability.enabled = this.settings.proofStabilityEnabled !== false;
            stability.beepOnStable =
              this.settings.proofStabilityBeep !== false;
            stability.tolerancePct =
              parseFloat(this.settings.proofStabilityTolerance) ||
              DEFAULT_SETTINGS.proofStabilityTolerance;
            stability.minStableCount =
              parseInt(this.settings.proofStabilityMinStable, 10) ||
              DEFAULT_SETTINGS.proofStabilityMinStable;
            stability.maxWaitMs =
              parseInt(this.settings.proofStabilityMaxWait, 10) ||
              DEFAULT_SETTINGS.proofStabilityMaxWait;
            stability.minDeltaLux =
              parseFloat(this.settings.proofStabilityMinDelta) ||
              DEFAULT_SETTINGS.proofStabilityMinDelta;
          }
        }

        /**
         * Save global settings from UI
         * @returns {void}
         * @description Reads UI, saves to storage, and applies to runtime
         */
        saveGlobalSettings() {
          this.readSettingsFromUI();
          // Sync to appState
          Object.assign(appState.settings, this.settings);

          if (StorageManager.saveSettings(this.settings)) {
            this.applySettingsToRuntime();
            this.showAllProfilesFeedback("Global settings saved!", "success");
          }
        }

        /**
         * Apply settings live without feedback
         * @returns {void}
         * @description Reads UI, saves to storage, applies to runtime (debounced)
         */
        applyLiveSettings() {
          this.readSettingsFromUI();
          // Sync to appState
          Object.assign(appState.settings, this.settings);

          // Save immediately for persistence but don't show the save feedback
          StorageManager.saveSettings(this.settings);
          this.applySettingsToRuntime();
          // Announce setting change to assistive tech
          try {
            const live = document.getElementById("settingsLiveStatus");
            if (live) {
              const denom = this.settings.stopDenominator || 3;
              live.textContent = `Default stop increment set to ${denomLabel(
                denom,
              )}`;
            }
          } catch (e) {}
        }

        // Generic save preset/profile helper
        savePreset(config) {
          const {
            name,
            dataObject,
            collection,
            storageMethod,
            updateListMethod,
            feedbackMethod,
            feedbackButton,
            successMessage,
          } = config;

          if (!name || name.trim() === "") {
            if (feedbackMethod) {
              feedbackMethod("Please enter a name", "error");
            } else {
              alert("Please enter a name");
            }
            return false;
          }

          const preset = {
            name: name.trim(),
            ...dataObject,
            date: new Date().toISOString(),
          };

          const existingIndex = collection.findIndex(
            (p) => p.name === preset.name,
          );
          if (existingIndex >= 0) {
            collection[existingIndex] = preset;
          } else {
            collection.push(preset);
          }

          if (storageMethod(collection)) {
            if (updateListMethod) updateListMethod();

            // Feedback handling
            if (feedbackMethod) {
              feedbackMethod(
                successMessage || `"${preset.name}" saved!`,
                "success",
              );
            } else if (feedbackButton) {
              playBeep(800, 0.3, 0.3);
              const originalText = feedbackButton.textContent;
              feedbackButton.textContent = "Saved!";
              feedbackButton.classList.add("active");
              setTimeout(() => {
                feedbackButton.textContent = originalText;
                feedbackButton.classList.remove("active");
              }, 1000);
            }
            return true;
          }
          return false;
        }

        // Generic delete preset/profile helper
        deletePreset(config) {
          const {
            name,
            collection,
            storageMethod,
            updateListMethod,
            feedbackMethod,
            confirmMessage,
            successMessage,
            onDeleteCallback,
          } = config;

          if (confirm(confirmMessage || `Delete "${name}"?`)) {
            const newCollection = collection.filter((p) => p.name !== name);
            collection.length = 0;
            collection.push(...newCollection);

            if (onDeleteCallback) onDeleteCallback();

            if (storageMethod(collection)) {
              if (updateListMethod) updateListMethod();
              if (feedbackMethod) {
                feedbackMethod(
                  successMessage || `"${name}" deleted!`,
                  "success",
                );
              }
              playBeep(400, 0.3, 0.3);
              return true;
            }
          }
          return false;
        }

        // Generic render preset list helper
        renderPresetList(config) {
          const { listElement, collection, currentItem, renderItemContent } =
            config;

          if (!listElement) return;

          listElement.innerHTML = "";

          collection.forEach((item) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = `shelf-life-item ${
              currentItem === item.name ? "active" : ""
            }`;

            itemDiv.innerHTML = renderItemContent(item);
            listElement.appendChild(itemDiv);
          });
        }

        // Generic clear all presets helper
        clearAllPresets(config) {
          const {
            collection,
            storageMethod,
            updateListMethod,
            feedbackMethod,
            confirmMessage,
            successMessage,
            onClearCallback,
          } = config;

          if (
            confirm(
              confirmMessage || "Delete ALL items? This cannot be undone!",
            )
          ) {
            collection.length = 0;

            if (onClearCallback) onClearCallback();

            if (storageMethod(collection)) {
              if (updateListMethod) updateListMethod();
              if (feedbackMethod) {
                feedbackMethod(
                  successMessage || "All items deleted!",
                  "success",
                );
              } else {
                playBeep(600, 0.5, 0.3);
              }
              return true;
            }
          }
          return false;
        }

        saveCurrentProfile(name) {
          // Get current timer times from timer objects
          const currentTimes = {};
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              currentTimes[timer.name] = timer.getCurrentTime();
            });
          }

          // Get factorial development state if available
          const factorialState = window.realTimeAutoFactorial
            ? window.realTimeAutoFactorial.getFactorialState()
            : null;

          // Build profile data with optional factorial state
          const profileData = { times: currentTimes };
          if (factorialState && factorialState.multiplier) {
            profileData.factorial = factorialState;
          }

          const result = this.savePreset({
            name,
            dataObject: profileData,
            collection: this.profiles,
            storageMethod: (profiles) => StorageManager.saveProfiles(profiles),
            updateListMethod: () => this.updateTimerProfileListUI(),
            feedbackMethod: (msg, type) =>
              this.showAllProfilesFeedback(msg, type),
            successMessage: `Profile "${name}" saved!`,
          });

          if (result) {
            this.setCurrentProfile(name.trim());
          }
          return result;
        }

        loadProfile(profile) {
          if (!profile || !profile.times) {
            this.showAllProfilesFeedback("Invalid profile format", "error");
            return false;
          }

          // Stop all running timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              if (timer.isRunning) {
                timer.stop();
              }
            });
          }

          // Apply profile times to timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              if (profile.times[timer.name] !== undefined) {
                timer.setTime(profile.times[timer.name]);
              }
            });
          }

          // Restore factorial development state if available, otherwise reset it
          if (window.realTimeAutoFactorial) {
            if (profile.factorial) {
              window.realTimeAutoFactorial.setFactorialState(profile.factorial);
            } else {
              window.realTimeAutoFactorial.resetMultiplier();
            }
          }

          this.setCurrentProfile(profile.name);
          this.updateTimerProfileListUI();

          playBeep(600, 0.3, 0.3);
          this.showAllProfilesFeedback(
            `Profile "${profile.name}" loaded!`,
            "success",
          );
          return true;
        }

        deleteProfile(profileName) {
          return this.deletePreset({
            name: profileName,
            collection: this.profiles,
            storageMethod: (profiles) => StorageManager.saveProfiles(profiles),
            updateListMethod: () => this.updateTimerProfileListUI(),
            feedbackMethod: (msg, type) =>
              this.showAllProfilesFeedback(msg, type),
            confirmMessage: `Delete profile "${profileName}"?`,
            successMessage: `Profile "${profileName}" deleted!`,
            onDeleteCallback: () => {
              if (this.getCurrentProfile() === profileName) {
                this.setCurrentProfile(null);
              }
            },
          });
        }

        clearAllProfiles() {
          return this.clearAllPresets({
            collection: this.profiles,
            storageMethod: () => StorageManager.saveProfiles([]),
            updateListMethod: () => this.updateTimerProfileListUI(),
            feedbackMethod: (msg, type) =>
              this.showAllProfilesFeedback(msg, type),
            confirmMessage: "Delete ALL timer profiles? This cannot be undone!",
            successMessage: "All timer profiles deleted!",
            onClearCallback: () => {
              this.setCurrentProfile(null);
            },
          });
        }

        resetAllSettings() {
          if (
            confirm(
              "Reset all settings to defaults? This will delete all profiles and settings!",
            )
          ) {
            StorageManager.clearAll();
            this.settings = { ...DEFAULT_SETTINGS };
            this.profiles = [];
            this.setCurrentProfile(null);
            this.colorScheme = "dark";
            this.applyColorScheme();
            this.applySoundSettings();
            loadSettingsToUI();
            this.updateTimerProfileListUI();
            this.showAllProfilesFeedback(
              "All settings reset to defaults!",
              "success",
            );
            location.reload();
          }
        }

        exportAllData() {
          // Ensure we export the latest UI state
          this.readSettingsFromUI();

          // Normalize settings to guarantee stop increment is present and numeric
          const settingsToExport = {
            ...DEFAULT_SETTINGS,
            ...this.settings,
            stopDenominator:
              parseInt(this.settings.stopDenominator, 10) ||
              DEFAULT_SETTINGS.stopDenominator,
          };

          const exportData = {
            app: "Darkroom Timer",
            version: "3.0.0",
            exportDate: new Date().toISOString(),
            settings: settingsToExport,
            timerProfiles: this.profiles,
            chemicalPresets: window.chemicalManager
              ? window.chemicalManager.chemicalPresets
              : [],
            capacityTracker: StorageManager.loadCapacityTracker(),
            shelfLifeData: StorageManager.loadShelfLife(),
            customFilterBanks: StorageManager.loadCustomFilterBanks(),
            splitGradePresets: window.splitGradeCalculator
              ? window.splitGradeCalculator.splitPresets
              : [],
            lightMeterCalibrations: window.lightMeterManager
              ? window.lightMeterManager.calibrations
              : JSON.parse(
                  localStorage.getItem(STORAGE_KEYS.LIGHT_METER_CALIBRATIONS) ||
                    "{}",
                ),
          };

          const jsonStr = JSON.stringify(exportData, null, 2);
          const blob = new Blob([jsonStr], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `darkroom-timer-data-${new Date()
            .toISOString()
            .slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          this.showAllProfilesFeedback(
            "All data exported successfully!",
            "success",
          );
        }

        importAllData(jsonData) {
          try {
            const data = JSON.parse(jsonData);
            let importedCount = 0;

            // Import global settings
            if (data.settings && typeof data.settings === "object") {
              this.settings = { ...DEFAULT_SETTINGS, ...data.settings };
              this.colorScheme = this.settings.colorScheme || "dark";
              StorageManager.saveSettings(this.settings);
              StorageManager.saveColorScheme(this.colorScheme);
              this.applyColorScheme();
              this.applySoundSettings();
              this.applySettingsToRuntime();
              if (typeof loadSettingsToUI === "function") {
                loadSettingsToUI();
              }
              importedCount++;
            }

            // Import timer profiles
            if (data.timerProfiles && Array.isArray(data.timerProfiles)) {
              const validProfiles = data.timerProfiles.filter((profile) => {
                return (
                  profile &&
                  typeof profile.name === "string" &&
                  profile.name.trim() !== "" &&
                  profile.times &&
                  typeof profile.times === "object"
                );
              });

              if (validProfiles.length > 0) {
                const existingNames = this.profiles.map((p) => p.name);
                const newNames = validProfiles.map((p) => p.name);
                const duplicates = newNames.filter((name) =>
                  existingNames.includes(name),
                );

                let mergeStrategy = "skip";
                if (duplicates.length > 0) {
                  mergeStrategy =
                    prompt(
                      `Found ${
                        duplicates.length
                      } duplicate timer profile(s): ${duplicates.join(
                        ", ",
                      )}\n\n` +
                        `Enter 'overwrite' to replace duplicates, or 'skip' to keep existing:`,
                      "skip",
                    )?.toLowerCase() || "skip";

                  if (!["overwrite", "skip"].includes(mergeStrategy)) {
                    mergeStrategy = "skip";
                  }
                }

                validProfiles.forEach((newProfile) => {
                  const existingIndex = this.profiles.findIndex(
                    (p) => p.name === newProfile.name,
                  );

                  if (existingIndex >= 0) {
                    if (mergeStrategy === "overwrite") {
                      this.profiles[existingIndex] = {
                        ...newProfile,
                        date: newProfile.date || new Date().toISOString(),
                      };
                    }
                  } else {
                    this.profiles.push({
                      ...newProfile,
                      date: newProfile.date || new Date().toISOString(),
                    });
                  }
                });

                StorageManager.saveProfiles(this.profiles);
                importedCount += validProfiles.length;
              }
            }

            // Import chemical presets
            if (
              data.chemicalPresets &&
              Array.isArray(data.chemicalPresets) &&
              window.chemicalManager
            ) {
              const validChemicalPresets = data.chemicalPresets.filter(
                (preset) => {
                  return (
                    preset &&
                    typeof preset.name === "string" &&
                    preset.name.trim() !== "" &&
                    preset.totalVolume &&
                    preset.dilutionRatio
                  );
                },
              );

              if (validChemicalPresets.length > 0) {
                validChemicalPresets.forEach((newPreset) => {
                  const existingIndex =
                    window.chemicalManager.chemicalPresets.findIndex(
                      (p) => p.name === newPreset.name,
                    );
                  if (existingIndex >= 0) {
                    window.chemicalManager.chemicalPresets[existingIndex] =
                      newPreset;
                  } else {
                    window.chemicalManager.chemicalPresets.push(newPreset);
                  }
                });

                StorageManager.saveChemicalPresets(
                  window.chemicalManager.chemicalPresets,
                );
                window.chemicalManager.updateChemicalPresetList();
                importedCount += validChemicalPresets.length;
              }
            }

            // Import capacity tracker
            if (data.capacityTracker && window.chemicalManager) {
              window.chemicalManager.capacityData = {
                ...window.chemicalManager.capacityData,
                ...data.capacityTracker,
              };
              StorageManager.saveCapacityTracker(
                window.chemicalManager.capacityData,
              );
              window.chemicalManager.updateCapacityDisplay();
              importedCount++;
            }

            // Import shelf life data (ACTIVE CHEMICALS)
            if (
              data.shelfLifeData &&
              Array.isArray(data.shelfLifeData) &&
              window.chemicalManager
            ) {
              // First, clear existing shelf life data
              window.chemicalManager.shelfLifeData = [];

              // Validate and import each chemical
              data.shelfLifeData.forEach((chemical) => {
                // Validate required fields
                if (
                  chemical &&
                  chemical.name &&
                  chemical.dateMixed &&
                  chemical.shelfLifeDays
                ) {
                  // Add the chemical to shelf life data
                  window.chemicalManager.shelfLifeData.push({
                    id: chemical.id || Date.now() + Math.random(),
                    type: chemical.type || "custom",
                    name: chemical.name,
                    dateMixed: chemical.dateMixed,
                    shelfLifeDays: chemical.shelfLifeDays,
                    dateAdded: chemical.dateAdded || new Date().toISOString(),
                  });
                }
              });

              // Save to storage
              StorageManager.saveShelfLife(
                window.chemicalManager.shelfLifeData,
              );

              // Update the shelf life list in the UI
              if (window.chemicalManager.shelfLifeList) {
                window.chemicalManager.updateShelfLifeList();
              }

              importedCount += window.chemicalManager.shelfLifeData.length;

              // Show notification if we're currently on the chemical tab
              const currentTab = document
                .querySelector(".tab-button.active")
                .getAttribute("data-tab");
              if (currentTab === "chemical") {
                this.showAllProfilesFeedback(
                  `Loaded ${window.chemicalManager.shelfLifeData.length} active chemicals`,
                  "success",
                );
              }
            }

            // Update all UIs
            this.updateTimerProfileListUI();

            // Import custom filter banks
            if (data.customFilterBanks) {
              const banks = Array.isArray(data.customFilterBanks)
                ? data.customFilterBanks
                : getDefaultCustomFilterBanks();
              StorageManager.saveCustomFilterBanks(banks);
              if (window.customFilterBankManager) {
                window.customFilterBankManager.replaceData(banks);
              }
              importedCount++;
            }

            // Import split-grade presets
            if (
              data.splitGradePresets &&
              Array.isArray(data.splitGradePresets)
            ) {
              const validPresets = data.splitGradePresets
                .filter((preset) => {
                  return (
                    preset &&
                    typeof preset.name === "string" &&
                    preset.name.trim() !== "" &&
                    typeof preset.neutralTime === "number" &&
                    typeof preset.softFilter === "string" &&
                    typeof preset.hardFilter === "string" &&
                    typeof preset.burnPercent === "number"
                  );
                })
                .map((preset) => ({
                  // Ensure all new properties have defaults for backward compatibility
                  ...preset,
                  fomaPaperType: preset.fomaPaperType || "fomaspeed",
                  customFactors: preset.customFactors || {
                    "00": preset.customSoftFactor || 1.0,
                    0: preset.customSoftFactor || 1.0,
                    1: preset.customSoftFactor || 1.0,
                    2: preset.customSoftFactor || 1.0,
                    3: preset.customSoftFactor || 1.0,
                    4: preset.customSoftFactor || 1.0,
                    5: preset.customHardFactor || 1.0,
                  },
                }));

              if (validPresets.length > 0) {
                // Merge or overwrite based on strategy
                validPresets.forEach((newPreset) => {
                  const existingIndex =
                    window.splitGradeCalculator.splitPresets.findIndex(
                      (p) => p.name === newPreset.name,
                    );

                  if (existingIndex >= 0) {
                    if (mergeStrategy === "overwrite") {
                      window.splitGradeCalculator.splitPresets[existingIndex] =
                        {
                          ...newPreset,
                          date: newPreset.date || new Date().toISOString(),
                        };
                    }
                  } else {
                    window.splitGradeCalculator.splitPresets.push({
                      ...newPreset,
                      date: newPreset.date || new Date().toISOString(),
                    });
                  }
                });

                StorageManager.saveSplitPresets(
                  window.splitGradeCalculator.splitPresets,
                );
                window.splitGradeCalculator.updatePresetList();
                importedCount += validPresets.length;
              }
            }

            // Import light meter calibrations
            if (
              data.lightMeterCalibrations &&
              typeof data.lightMeterCalibrations === "object"
            ) {
              // Merge with existing calibrations
              if (window.lightMeterManager) {
                window.lightMeterManager.calibrations = {
                  ...window.lightMeterManager.calibrations,
                  ...data.lightMeterCalibrations,
                };
                window.lightMeterManager.saveAllCalibrations();
                window.lightMeterManager.loadCalibrationForCurrentPaper();
                window.lightMeterManager.updateCalibrationDisplay();
              } else {
                // Direct save to localStorage if manager not loaded yet
                const existing = JSON.parse(
                  localStorage.getItem(STORAGE_KEYS.LIGHT_METER_CALIBRATIONS) ||
                    "{}",
                );
                const merged = { ...existing, ...data.lightMeterCalibrations };
                localStorage.setItem(
                  STORAGE_KEYS.LIGHT_METER_CALIBRATIONS,
                  JSON.stringify(merged),
                );
              }
              importedCount++;
            }

            // Refresh the chemical tab if it's currently active
            const currentTab = document
              .querySelector(".tab-button.active")
              .getAttribute("data-tab");
            if (currentTab === "chemical" && window.chemicalManager) {
              window.chemicalManager.updateDisplay();
            }

            // Visual feedback for chemical data
            if (window.chemicalManager) {
              // Briefly highlight the chemical tab if we imported chemical data
              const chemicalTabBtn = document.querySelector(
                '.tab-button[data-tab="chemical"]',
              );
              if (chemicalTabBtn) {
                chemicalTabBtn.style.backgroundColor = "#400";
                setTimeout(() => {
                  chemicalTabBtn.style.backgroundColor = "";
                }, 1000);
              }
            }

            this.showAllProfilesFeedback(
              `Successfully imported ${importedCount} items!`,
              "success",
            );

            return true;
          } catch (error) {
            this.showAllProfilesFeedback(
              `Import failed: ${error.message}`,
              "error",
            );
            return false;
          }
        }

        showAllProfilesFeedback(message, type = "info") {
          showFeedback("allProfilesFeedback", message, type);
        }

        updateTimerProfileListUI() {
          const profileList = document.getElementById("timerProfileList");
          if (!profileList) return;

          this.renderPresetList({
            listElement: profileList,
            collection: this.profiles,
            currentItem: this.getCurrentProfile(),
            renderItemContent: (profile) => {
              let timeStr = "";
              if (profile.times) {
                const devTime = profile.times.Dev || DEFAULT_TIMER_TIMES.Dev;
                const stopTime = profile.times.Stop || DEFAULT_TIMER_TIMES.Stop;
                const fixTime = profile.times.Fix || DEFAULT_TIMER_TIMES.Fix;

                const devMin = Math.floor(devTime / 60);
                const devSec = devTime % 60;
                const fixMin = Math.floor(fixTime / 60);
                const fixSec = fixTime % 60;

                timeStr = `Dev:${devMin}:${devSec
                  .toString()
                  .padStart(2, "0")} Stop:${stopTime}s Fix:${fixMin}:${fixSec
                  .toString()
                  .padStart(2, "0")}`;
              } else {
                timeStr = "No times saved";
              }

              // Add factorial indicator if profile has factorial data
              const factorialIndicator =
                profile.factorial && profile.factorial.multiplier
                  ? `<div style="font-size: 0.6rem; color: var(--warning); margin-top: 2px;">⚙ Factorial: ${profile.factorial.multiplier.toFixed(
                      2,
                    )}×</div>`
                  : "";

              return `
                        <div>
                            <strong>${profile.name}</strong>
                            <div style="font-size: 0.65rem; color: var(--text-secondary);">${new Date(
                              profile.date,
                            ).toLocaleDateString()}</div>
                            <div style="font-size: 0.6rem; color: var(--accent);">${timeStr}</div>
                            ${factorialIndicator}
                        </div>
                        <div class="shelf-life-actions">
                            <button class="btn-action load-btn" data-context="profile" data-name="${
                              profile.name
                            }">Load</button>
                            <button class="btn-action delete-btn" data-context="profile" data-name="${
                              profile.name
                            }">Delete</button>
                        </div>
                    `;
            },
          });
        }
      }

      /**
       * ExposureLogManager - Manages automatic session logging for all exposure workflows
       *
       * Automatically tracks sessions from TEST, SPLIT, CALC, and TIMER tabs.
       * Sessions start on first exposure and end when TIMER starts.
       * Temporary sessions auto-save (max 6). Permanent sessions require user action.
       *
       * @class
       * @example
       * exposureLogManager.startSession('calc', 'manual');
       * exposureLogManager.addCalcStep({ baseTime: 10.0, stop: 1.5, finalTime: 28.28 });
       * exposureLogManager.endSession();
       */
      class ExposureLogManager {
        constructor() {
          this.loadSessions();
          this.updateUI();
        }

        // ===== SESSION MANAGEMENT =====

        /**
         * Start a new session
         * @param {string} source - 'test', 'split', 'calc', 'manual'
         * @param {string} type - 'test-strip', 'split-grade', 'exposure', 'manual'
         */
        startSession(source, type) {
          // If session already active, don't start new one
          if (appState.logging.activeSession) return;

          const sessionId = `temp-${Date.now()}`;
          appState.logging.activeSession = sessionId;
          appState.logging.autoSessionActive =
            source === "test" || source === "split";

          const session = {
            id: sessionId,
            name: this.generateSessionName(source, type),
            created: new Date().toISOString(),
            source: source,
            type: type,
            phases: {
              test: null,
              split: null,
              calc: null,
              timer: null,
            },
            notes: "",
            isTemporary: true,
          };

          // Add to temp sessions
          appState.logging.tempSessions.unshift(session);
          this.saveSessions();
          this.updateUI();
        }

        /**
         * Add TEST phase to current session
         * @param {Object} data - Test strip data
         */
        addTestPhase(data) {
          if (!appState.logging.activeSession) {
            this.startSession("test", "test-strip");
          }

          const session = this.getActiveSession();
          if (session) {
            session.phases.test = {
              baseTime: data.baseTime,
              method: data.method,
              steps: data.steps,
              selectedStep: data.selectedStep,
              selectedStop: data.selectedStop,
              transferDestination: data.transferDestination,
              notes: data.notes || "",
            };

            // Update session name based on selected step
            if (data.selectedStep) {
              session.name = `Test Strip: ${data.selectedStep}s`;
            }

            // Add notes to session if provided
            if (data.notes) {
              session.notes = data.notes;
            }

            this.saveSessions();
            this.updateUI();
          }
        }

        /**
         * Add SPLIT phase to current session
         * @param {Object} data - Split-grade data
         */
        addSplitPhase(data) {
          if (!appState.logging.activeSession) {
            this.startSession("split", "split-grade");
          }

          const session = this.getActiveSession();
          if (session) {
            session.phases.split = {
              neutralTime: data.neutralTime,
              paperBrand: data.paperBrand,
              softFilter: data.softFilter,
              hardFilter: data.hardFilter,
              filterBrand: data.filterBrand,
              highlightsBase: data.highlightsBase,
              shadowsBase: data.shadowsBase,
              softTime: data.softTime,
              hardTime: data.hardTime,
              totalTime: data.totalTime,
              burnPercent: data.burnPercent,
            };

            // Update session name
            session.name = `Split: ${data.softFilter}/${data.hardFilter}`;

            this.saveSessions();
            this.updateUI();
          }
        }

        /**
         * Add CALC phase to current session
         * @param {Object} data - Calculator exposure data
         */
        addCalcPhase(data) {
          if (!appState.logging.activeSession) {
            this.startSession("calc", "exposure");
          }

          const session = this.getActiveSession();
          if (session) {
            if (!session.phases.calc) {
              session.phases.calc = [];
            }

            session.phases.calc.push({
              baseTime: data.baseTime,
              stopAdjustment: data.stopAdjustment,
              finalTime: data.finalTime,
              filterContext: data.filterContext,
              timestamp: new Date().toISOString(),
              notes: data.notes || "",
            });

            // Update session name based on first CALC exposure
            if (session.phases.calc.length === 1) {
              session.name = `Exposure: ${data.finalTime}s`;
            }

            this.saveSessions();
            this.updateUI();
          }
        }

        /**
         * Add TIMER phase and end session
         * @param {Object} data - Timer data
         */
        addTimerPhaseAndEnd(data) {
          const session = this.getActiveSession();
          if (session) {
            session.phases.timer = {
              dev: data.dev,
              stop: data.stop,
              fix: data.fix,
              flo: data.flo,
            };

            // End the session
            this.endSession();
          }
        }

        /**
         * End current session
         */
        endSession() {
          const session = this.getActiveSession();
          if (!session) return;

          session.ended = new Date().toISOString();
          appState.logging.activeSession = null;
          appState.logging.autoSessionActive = false;
          appState.logging.currentStepNotes = "";
          appState.logging.sessionNotes = "";

          // Enforce max 6 temporary sessions
          if (appState.logging.tempSessions.length > 6) {
            appState.logging.tempSessions = appState.logging.tempSessions.slice(
              0,
              6,
            );
          }

          this.saveSessions();
          this.updateUI();

          // Show notification
          this.showNotification(
            `Session "${session.name}" saved to temporary list`,
          );

          // Automatically start a new session
          setTimeout(() => {
            this.startSession("manual", "session");
            this.showNotification("New session started automatically");
          }, 500);
        }

        /**
         * Save temporary session to permanent
         * @param {string} sessionId - Session ID to save
         * @param {string} notes - Optional session notes
         * @param {string} name - Optional custom name
         */
        saveToPermanent(sessionId, notes = "", name = "") {
          const tempIndex = appState.logging.tempSessions.findIndex(
            (s) => s.id === sessionId,
          );
          if (tempIndex === -1) return;

          const session = appState.logging.tempSessions[tempIndex];

          // Create permanent copy
          const permanentSession = {
            ...session,
            id: `perm-${Date.now()}`,
            isTemporary: false,
            savedAt: new Date().toISOString(),
            notes: notes || session.notes,
          };

          if (name) {
            permanentSession.name = name;
          }

          appState.logging.permanentSessions.unshift(permanentSession);

          // Remove from temp
          appState.logging.tempSessions.splice(tempIndex, 1);

          this.saveSessions();
          this.updateUI();

          this.showNotification(`Session saved permanently`);
        }

        /**
         * Delete a session
         * @param {string} sessionId - Session ID to delete
         * @param {boolean} isPermanent - Whether it's a permanent session
         */
        deleteSession(sessionId, isPermanent) {
          if (isPermanent) {
            const index = appState.logging.permanentSessions.findIndex(
              (s) => s.id === sessionId,
            );
            if (index !== -1) {
              appState.logging.permanentSessions.splice(index, 1);
            }
          } else {
            const index = appState.logging.tempSessions.findIndex(
              (s) => s.id === sessionId,
            );
            if (index !== -1) {
              appState.logging.tempSessions.splice(index, 1);
            }
          }

          this.saveSessions();
          this.updateUI();
        }

        /**
         * Clear all sessions
         */
        clearAll() {
          if (!confirm("Delete ALL sessions? This cannot be undone.")) return;

          appState.logging.tempSessions = [];
          appState.logging.permanentSessions = [];
          appState.logging.activeSession = null;

          this.saveSessions();
          this.updateUI();

          this.showNotification("All sessions cleared");
        }

        // ===== EXPORT/IMPORT =====

        /**
         * Export sessions as CSV
         */
        exportCSV() {
          const allSessions = appState.logging.permanentSessions;

          if (allSessions.length === 0) {
            alert("No permanent sessions to export");
            return;
          }

          let csv =
            "Session,Date,Time,Phase,BaseTime,Stop,FinalTime,SoftFilter,HardFilter,FilterBrand,Notes\n";

          allSessions.forEach((session) => {
            const sessionName = session.name.replace(/,/g, ";");
            const sessionDate = new Date(session.created).toLocaleDateString();
            const sessionTime = new Date(session.created).toLocaleTimeString();

            // TEST phase
            if (session.phases.test) {
              csv += `${sessionName},${sessionDate},${sessionTime},TEST,${session.phases.test.baseTime},N/A,N/A,N/A,N/A,N/A,"${session.phases.test.transferDestination}"\n`;
            }

            // SPLIT phase
            if (session.phases.split) {
              csv += `${sessionName},${sessionDate},${sessionTime},SPLIT,${session.phases.split.neutralTime},N/A,${session.phases.split.totalTime},${session.phases.split.softFilter},${session.phases.split.hardFilter},${session.phases.split.filterBrand},N/A\n`;
            }

            // CALC phases
            if (session.phases.calc && session.phases.calc.length > 0) {
              session.phases.calc.forEach((calc) => {
                const filterContext = calc.filterContext || "N/A";
                csv += `${sessionName},${sessionDate},${sessionTime},CALC,${
                  calc.baseTime
                },${calc.stopAdjustment},${
                  calc.finalTime
                },${filterContext},N/A,N/A,"${calc.notes.replace(
                  /,/g,
                  ";",
                )}"\n`;
              });
            }

            // TIMER phase
            if (session.phases.timer) {
              csv += `${sessionName},${sessionDate},${sessionTime},TIMER,N/A,N/A,N/A,N/A,N/A,N/A,"Dev:${session.phases.timer.dev},Stop:${session.phases.timer.stop},Fix:${session.phases.timer.fix},Flo:${session.phases.timer.flo}"\n`;
            }
          });

          // Download
          const blob = new Blob([csv], { type: "text/csv" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `darkroom_sessions_${Date.now()}.csv`;
          a.click();
          URL.revokeObjectURL(url);

          this.showNotification("CSV exported successfully");
        }

        /**
         * Export sessions as JSON
         */
        exportJSON() {
          const data = {
            exported: new Date().toISOString(),
            permanentSessions: appState.logging.permanentSessions,
          };

          const json = JSON.stringify(data, null, 2);
          const blob = new Blob([json], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `darkroom_sessions_backup_${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(url);

          this.showNotification("JSON exported successfully");
        }

        /**
         * Import sessions from JSON
         */
        importJSON() {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json,application/json";

          input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
              try {
                const data = JSON.parse(event.target.result);

                if (data.permanentSessions) {
                  appState.logging.permanentSessions = [
                    ...data.permanentSessions,
                    ...appState.logging.permanentSessions,
                  ];
                }

                if (data.tempSessions) {
                  appState.logging.tempSessions = [
                    ...data.tempSessions,
                    ...appState.logging.tempSessions,
                  ];
                }

                // Enforce max temp sessions
                if (appState.logging.tempSessions.length > 6) {
                  appState.logging.tempSessions =
                    appState.logging.tempSessions.slice(0, 6);
                }

                this.saveSessions();
                this.updateUI();

                this.showNotification("Sessions imported successfully");
              } catch (error) {
                alert("Invalid JSON file");
              }
            };
            reader.readAsText(file);
          };

          input.click();
        }

        // ===== HELPER METHODS =====

        /**
         * Get active session
         */
        getActiveSession() {
          return appState.logging.tempSessions.find(
            (s) => s.id === appState.logging.activeSession,
          );
        }

        /**
         * Generate session name
         */
        generateSessionName(source, type) {
          const timestamp = new Date().toLocaleTimeString();
          const sourceNames = {
            test: "Test Strip",
            split: "Split Grade",
            calc: "Exposure",
            manual: "Session",
          };
          return `${sourceNames[source] || "Session"} - ${timestamp}`;
        }

        /**
         * Load sessions from storage
         */
        loadSessions() {
          const temp = StorageManager.loadJSON(STORAGE_KEYS.TEMP_SESSIONS, []);
          const perm = StorageManager.loadJSON(
            STORAGE_KEYS.PERMANENT_SESSIONS,
            [],
          );

          appState.logging.tempSessions = temp;
          appState.logging.permanentSessions = perm;
        }

        /**
         * Save sessions to storage
         */
        saveSessions() {
          StorageManager.saveJSON(
            STORAGE_KEYS.TEMP_SESSIONS,
            appState.logging.tempSessions,
          );
          StorageManager.saveJSON(
            STORAGE_KEYS.PERMANENT_SESSIONS,
            appState.logging.permanentSessions,
          );
        }

        /**
         * Update UI
         */
        updateUI() {
          this.renderTempSessions();
          this.renderPermanentSessions();
          this.renderStats();
        }

        /**
         * Render temporary sessions list
         */
        renderTempSessions() {
          const list = document.getElementById("tempSessionsList");
          if (!list) return;

          if (appState.logging.tempSessions.length === 0) {
            list.innerHTML =
              '<div class="shelf-life-item" style="justify-content: center; color: var(--text-secondary);">No temporary sessions yet</div>';
            return;
          }

          list.innerHTML = appState.logging.tempSessions
            .map((session) => {
              const date = new Date(session.created).toLocaleString();
              const calcTotal = this.calculateCalcTotal(session);
              const isActive = session.id === appState.logging.activeSession;

              return `
              <div class="shelf-life-item ${
                isActive ? "active" : ""
              }" style="flex-direction: column; align-items: flex-start;">
                <div style="display: flex; justify-content: space-between; width: 100%; align-items: center;">
                  <div>
                    <strong>${session.name}</strong>
                    <div style="font-size: 0.65rem; color: var(--text-secondary);">${date}</div>
                    <div style="font-size: 0.65rem; color: var(--accent);">CALC Total: ${calcTotal}s</div>
                  </div>
                  <div class="shelf-life-actions">
                    <button class="btn-action" onclick="exposureLogManager.viewSession('${
                      session.id
                    }', false)">View</button>
                    <button class="btn-action" onclick="exposureLogManager.saveToPermanentPrompt('${
                      session.id
                    }')">Save</button>
                    <button class="btn-action delete" onclick="exposureLogManager.deleteSession('${
                      session.id
                    }', false)">Delete</button>
                  </div>
                </div>
              </div>
            `;
            })
            .join("");
        }

        /**
         * Render permanent sessions list
         */
        renderPermanentSessions() {
          const list = document.getElementById("permanentSessionsList");
          if (!list) return;

          if (appState.logging.permanentSessions.length === 0) {
            list.innerHTML =
              '<div class="shelf-life-item" style="justify-content: center; color: var(--text-secondary);">No permanent sessions saved</div>';
            return;
          }

          list.innerHTML = appState.logging.permanentSessions
            .map((session) => {
              const date = new Date(session.created).toLocaleString();
              const savedDate = new Date(session.savedAt).toLocaleString();
              const calcTotal = this.calculateCalcTotal(session);

              return `
              <div class="shelf-life-item" style="flex-direction: column; align-items: flex-start;">
                <div style="display: flex; justify-content: space-between; width: 100%; align-items: center;">
                  <div>
                    <strong>${session.name}</strong>
                    <div style="font-size: 0.65rem; color: var(--text-secondary);">${date}</div>
                    <div style="font-size: 0.65rem; color: var(--accent);">CALC Total: ${calcTotal}s</div>
                    ${
                      session.notes
                        ? `<div style="font-size: 0.65rem; color: var(--text); margin-top: 2px;">${session.notes}</div>`
                        : ""
                    }
                    <div style="font-size: 0.6rem; color: var(--text-secondary); margin-top: 2px;">Saved: ${savedDate}</div>
                  </div>
                  <div class="shelf-life-actions">
                    <button class="btn-action" onclick="exposureLogManager.viewSession('${
                      session.id
                    }', true)">View</button>
                    <button class="btn-action delete" onclick="exposureLogManager.deleteSession('${
                      session.id
                    }', true)">Delete</button>
                  </div>
                </div>
              </div>
            `;
            })
            .join("");
        }

        /**
         * Calculate CALC total (only CALC exposures)
         */
        calculateCalcTotal(session) {
          if (!session.phases.calc || session.phases.calc.length === 0)
            return 0;
          return session.phases.calc
            .reduce((sum, calc) => sum + calc.finalTime, 0)
            .toFixed(2);
        }

        /**
         * Render statistics
         */
        renderStats() {
          const stats = document.getElementById("logStats");
          if (!stats) return;

          const tempCount = appState.logging.tempSessions.length;
          const permCount = appState.logging.permanentSessions.length;
          const totalExposures = appState.logging.permanentSessions.reduce(
            (sum, s) => {
              return sum + (s.phases.calc ? s.phases.calc.length : 0);
            },
            0,
          );

          stats.textContent = `${tempCount} Temp | ${permCount} Perm | ${totalExposures} Total Exposures`;
        }

        /**
         * View session details
         */
        viewSession(sessionId, isPermanent) {
          const sessions = isPermanent
            ? appState.logging.permanentSessions
            : appState.logging.tempSessions;
          const session = sessions.find((s) => s.id === sessionId);
          if (!session) return;

          let details = `Session: ${session.name}\n`;
          details += `Created: ${new Date(session.created).toLocaleString()}\n`;
          details += `Source: ${session.source}\n\n`;

          if (session.phases.test) {
            details += `TEST PHASE:\n`;
            details += `  Base Time: ${session.phases.test.baseTime}s\n`;
            details += `  Method: ${session.phases.test.method}\n`;
            details += `  Selected: ${session.phases.test.selectedStep}s (${session.phases.test.selectedStop} stops)\n`;
            details += `  Transfer: ${session.phases.test.transferDestination}\n\n`;
          }

          if (session.phases.split) {
            details += `SPLIT PHASE:\n`;
            details += `  Neutral: ${session.phases.split.neutralTime}s\n`;
            details += `  Paper: ${session.phases.split.paperBrand}\n`;
            details += `  Soft Filter: ${session.phases.split.softFilter} (${session.phases.split.filterBrand})\n`;
            details += `  Hard Filter: ${session.phases.split.hardFilter} (${session.phases.split.filterBrand})\n`;
            details += `  Highlights: ${session.phases.split.softTime}s\n`;
            details += `  Shadows: ${session.phases.split.hardTime}s\n`;
            details += `  Total: ${session.phases.split.totalTime}s\n\n`;
          }

          if (session.phases.calc && session.phases.calc.length > 0) {
            details += `CALC PHASE:\n`;
            session.phases.calc.forEach((calc, i) => {
              // Format the stop adjustment for display
              const stopDisplay = formatStop(calc.stopAdjustment);
              details += `  Exposure ${i + 1}: ${
                calc.baseTime
              }s + ${stopDisplay} = ${calc.finalTime}s`;
              if (calc.filterContext) details += ` [${calc.filterContext}]`;
              if (calc.notes) details += ` - ${calc.notes}`;
              details += `\n`;
            });
            details += `  CALC Total: ${this.calculateCalcTotal(session)}s\n\n`;
          }

          if (session.phases.timer) {
            details += `TIMER PHASE:\n`;
            details += `  Dev: ${session.phases.timer.dev}s\n`;
            details += `  Stop: ${session.phases.timer.stop}s\n`;
            details += `  Fix: ${session.phases.timer.fix}s\n`;
            details += `  Flo: ${session.phases.timer.flo}s\n\n`;
          }

          if (session.notes) {
            details += `NOTES: ${session.notes}\n`;
          }

          if (session.ended) {
            details += `\nEnded: ${new Date(session.ended).toLocaleString()}`;
          }

          alert(details);
        }

        /**
         * Save to permanent with prompt
         */
        saveToPermanentPrompt(sessionId) {
          const session = appState.logging.tempSessions.find(
            (s) => s.id === sessionId,
          );
          if (!session) return;

          const name = prompt("Enter custom name (optional):", session.name);
          if (name === null) return;

          const notes = prompt(
            "Enter session notes (optional):",
            session.notes || "",
          );
          if (notes === null) return;

          this.saveToPermanent(sessionId, notes, name);
        }

        /**
         * Show notification
         */
        showNotification(message) {
          const status = document.getElementById("settingsLiveStatus");
          if (status) {
            status.textContent = message;
            setTimeout(() => {
              status.textContent = "";
            }, 3000);
          }
        }
      }

      /**
       * UpdateStatusManager - Manages application updates from GitHub
       *
       * Handles version checking, update notifications, progress tracking,
       * and automatic restart after successful updates
       */
      class UpdateStatusManager {
        constructor() {
          this.currentVersion = "0.0.0";
          this.latestVersion = "0.0.0";
          this.isChecking = false;
          this.isUpdating = false;
          this.init();
        }

        init() {
          // Load version on startup
          this.loadVersion();
          this.updateVersionDisplay();

          // Set up update button listener
          const checkUpdatesBtn = document.getElementById("checkUpdatesBtn");
          if (checkUpdatesBtn) {
            checkUpdatesBtn.addEventListener("click", () => this.checkForUpdates());
          }
        }

        loadVersion() {
          // For now, version will come from server after first check
          // This could also be stored in localStorage
          try {
            const stored = localStorage.getItem("appVersion");
            if (stored) {
              this.currentVersion = stored;
            }
          } catch (e) {
            console.log("[UpdateStatusManager] Could not load version from localStorage");
          }
        }

        saveVersion(version) {
          try {
            localStorage.setItem("appVersion", version);
            this.currentVersion = version;
          } catch (e) {
            console.log("[UpdateStatusManager] Could not save version to localStorage");
          }
        }

        updateVersionDisplay() {
          const currentVersionEl = document.getElementById("currentAppVersion");
          const latestVersionEl = document.getElementById("latestAppVersion");

          if (currentVersionEl) {
            currentVersionEl.textContent = this.currentVersion || "Unknown";
          }
          if (latestVersionEl) {
            latestVersionEl.textContent = this.latestVersion || "Checking...";
          }
        }

        setUpdateStatus(message, type = "info") {
          const statusEl = document.getElementById("updateStatus");
          if (statusEl) {
            statusEl.textContent = message;
            statusEl.style.color = this.getStatusColor(type);
          }
        }

        getStatusColor(type) {
          const colors = {
            info: "var(--text-secondary)",
            success: "#4caf50",
            error: "#f44336",
            warning: "#ff9800",
          };
          return colors[type] || colors.info;
        }

        showProgress(show = true) {
          const progressEl = document.getElementById("updateProgress");
          if (progressEl) {
            progressEl.style.display = show ? "block" : "none";
          }
        }

        updateProgress(percentage) {
          const progressBar = document.getElementById("updateProgressBar");
          const progressText = document.getElementById("updateProgressText");

          if (progressBar) {
            progressBar.style.width = Math.min(100, Math.max(0, percentage)) + "%";
          }
          if (progressText) {
            progressText.textContent = Math.round(percentage) + "%";
          }
        }

        async checkForUpdates() {
          if (this.isChecking || this.isUpdating) {
            this.setUpdateStatus("Already checking/updating...", "warning");
            return;
          }

          this.isChecking = true;
          const btnEl = document.getElementById("checkUpdatesBtn");
          if (btnEl) {
            btnEl.disabled = true;
            btnEl.textContent = "Checking...";
          }

          this.setUpdateStatus("Checking for updates...", "info");
          this.showProgress(false);

          try {
            const response = await fetch("/update-check", {
              method: "GET",
              headers: {
                "Content-Type": "application/json",
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const result = await response.json();

            if (!result.success) {
              this.setUpdateStatus(`Error: ${result.error || "Unknown error"}`, "error");
              console.error("[UpdateStatusManager] Update check failed:", result.error);
              return;
            }

            // Update version display
            this.latestVersion = result.latest_version || result.version || "Unknown";
            this.updateVersionDisplay();

            // Check if update available
            if (!result.available) {
              this.setUpdateStatus("Already on latest version", "success");
              return;
            }

            // Update available
            this.setUpdateStatus(`Update available: ${this.latestVersion}`, "success");
            this.showProgress(true);
            this.updateProgress(50);

            // Download and install
            this.setUpdateStatus("Downloading and installing update...", "info");
            this.updateProgress(75);

            // Update complete, display results
            if (result.updated_files && result.updated_files.length > 0) {
              this.setUpdateStatus(
                `✓ Updated ${result.updated_files.length} files. Restarting...`,
                "success"
              );
              this.updateProgress(100);

              // Save new version
              this.saveVersion(this.latestVersion);

              // Wait before restart
              setTimeout(() => {
                window.location.reload();
              }, 3000);
            } else if (result.failed_files && result.failed_files.length > 0) {
              this.setUpdateStatus(
                `⚠ Partial update: ${result.failed_files.length} files failed`,
                "warning"
              );
              console.warn("[UpdateStatusManager] Failed files:", result.failed_files);
            }
          } catch (error) {
            console.error("[UpdateStatusManager] Check failed:", error);
            this.setUpdateStatus(
              `Error: ${error.message || "Failed to check for updates"}`,
              "error"
            );
          } finally {
            this.isChecking = false;
            const btnEl = document.getElementById("checkUpdatesBtn");
            if (btnEl) {
              btnEl.disabled = false;
              btnEl.textContent = "Check for Updates";
            }
            this.showProgress(false);
          }
        }
      }

      /**
       * ChemicalManager - Manages chemical calculations and tracking
       *
       * Handles chemical mix calculations, capacity tracking, shelf life management,
       * and chemical presets. Integrates with StorageManager for persistence.
       *
       * @class
       * @example
       * const chemManager = new ChemicalManager();
       * chemManager.updateMixCalculator();
       */
      class ChemicalManager {
        /**
         * Creates a ChemicalManager instance
         * @constructor
         * @property {number} totalVolume - Total volume in ml
         * @property {string} dilutionRatio - Current dilution ratio
         * @property {number} customStockParts - Custom stock parts
         * @property {number} customWaterParts - Custom water parts
         * @property {Object} capacityData - Developer capacity tracking data
         * @property {Array} shelfLifeData - Active chemicals array
         * @property {Array} chemicalPresets - Saved chemical presets
         * @property {number} currentPaperSize - Current paper size in m²
         */
        constructor() {
          this.totalVolume = 1000;
          this.dilutionRatio = "1+9";
          this.customStockParts = 1;
          this.customWaterParts = 9;
          // Note: currentPreset is now stored in appState.persistent.currentChemicalPreset
          this.capacityData = StorageManager.loadCapacityTracker();
          this.shelfLifeData = StorageManager.loadShelfLife();
          this.chemicalPresets = StorageManager.loadChemicalPresets();
          this.currentPaperSize = this.capacityData.paperSize || 0.08;

          this.init();
          this.updateMixCalculator();
          this.updateCapacityDisplay();
          this.updateShelfLifeList();
          this.updateChemicalPresetList();

          // Set up custom chemical name visibility
          this.chemicalTypeSelect.addEventListener("change", () => {
            if (this.chemicalTypeSelect.value === "custom") {
              this.customChemicalNameContainer.style.display = "block";
            } else {
              this.customChemicalNameContainer.style.display = "none";
            }
          });
        }

        /**
         * Get currently loaded chemical preset name
         * @returns {string|null} Current preset name or null
         * @description Uses appState as single source of truth
         */
        getCurrentPreset() {
          return appState.persistent.currentChemicalPreset;
        }

        /**
         * Set currently loaded chemical preset name
         * @param {string|null} presetName - Preset name or null
         * @description Updates appState
         */
        setCurrentPreset(presetName) {
          appState.persistent.currentChemicalPreset = presetName;
        }

        /**
         * Initialize ChemicalManager - get DOM elements and set up event listeners
         * @private
         * @returns {void}
         */
        init() {
          // Get elements
          this.totalVolumeSlider = document.getElementById("totalVolumeSlider");
          this.totalVolumeValue = document.getElementById("totalVolumeValue");
          this.dilutionBtns = document.querySelectorAll(
            ".toggle-btn[data-ratio]",
          );
          this.customStockPartsInput =
            document.getElementById("customStockParts");
          this.customWaterPartsInput =
            document.getElementById("customWaterParts");
          this.stockVolumeElement = document.getElementById("stockVolume");
          this.waterVolumeElement = document.getElementById("waterVolume");

          // Chemical preset elements
          this.chemicalPresetNameInput =
            document.getElementById("chemicalPresetName");
          this.saveChemicalPresetBtn =
            document.getElementById("saveChemicalPreset");
          this.chemicalPresetList =
            document.getElementById("chemicalPresetList");
          this.clearChemicalPresetsBtn = document.getElementById(
            "clearChemicalPresets",
          );

          // Capacity tracker elements - UPDATED
          this.capacitySlider = document.getElementById("capacitySlider");
          this.capacityValue = document.getElementById("capacityValue");
          this.trayVolumeSlider = document.getElementById("trayVolumeSlider");
          this.trayVolumeValue = document.getElementById("trayVolumeValue");
          this.maxPrintsValue = document.getElementById("maxPrintsValue");
          this.printsRemaining = document.getElementById("printsRemaining");
          this.capacityProgressBar = document.getElementById(
            "capacityProgressBar",
          );
          this.capacityMiddleLabel = document.getElementById(
            "capacityMiddleLabel",
          );
          this.capacityMaxLabel = document.getElementById("capacityMaxLabel");
          this.addPrintBtn = document.getElementById("addPrint");
          this.add5PrintsBtn = document.getElementById("add5Prints");
          this.resetPrintsBtn = document.getElementById("resetPrints");
          this.printsDoneValue = document.getElementById("printsDoneValue");
          this.areaUsedValue = document.getElementById("areaUsedValue");
          this.percentUsedValue = document.getElementById("percentUsedValue");
          this.capacityStatus = document.getElementById("capacityStatus");

          // Paper size elements - NEW
          this.paperSizeBtns = document.querySelectorAll(
            ".toggle-btn[data-size]",
          );
          this.customPaperSizeInput =
            document.getElementById("customPaperSize");
          this.useCustomSizeBtn = document.getElementById("useCustomSize");

          // Shelf life elements - UPDATED
          this.chemicalTypeSelect = document.getElementById("chemicalType");
          this.customChemicalNameContainer = document.getElementById(
            "customChemicalNameContainer",
          );
          this.customChemicalNameInput =
            document.getElementById("customChemicalName");
          this.shelfLifeDaysInput = document.getElementById("shelfLifeDays");
          this.chemicalDateInput = document.getElementById("chemicalDate");
          this.addChemicalBtn = document.getElementById("addChemical");
          this.shelfLifeList = document.getElementById("shelfLifeList");
          this.clearExpiredBtn = document.getElementById("clearExpired");

          // Set current date as default
          const today = new Date().toISOString().split("T")[0];
          this.chemicalDateInput.value = today;

          // Add event listeners for inputs/sliders (not buttons - those use delegation)
          this.totalVolumeSlider.addEventListener("input", () =>
            this.updateMixCalculator(),
          );

          // FIX: Allow typing in custom inputs
          this.customStockPartsInput.addEventListener("input", () => {
            this.customStockParts =
              parseInt(this.customStockPartsInput.value) || 1;
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.updateMixCalculator();
          });

          this.customWaterPartsInput.addEventListener("input", () => {
            this.customWaterParts =
              parseInt(this.customWaterPartsInput.value) || 1;
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.updateMixCalculator();
          });

          // Capacity tracker slider events
          this.capacitySlider.addEventListener("input", () =>
            this.updateCapacityDisplay(),
          );
          this.trayVolumeSlider.addEventListener("input", () =>
            this.updateCapacityDisplay(),
          );

          // Button click events now handled via delegation
          this.addPrintBtn.addEventListener("click", () => this.addPrints(1));
          this.add5PrintsBtn.addEventListener("click", () => this.addPrints(5));
          this.resetPrintsBtn.addEventListener("click", () =>
            this.resetPrints(),
          );
          this.saveChemicalPresetBtn.addEventListener("click", () =>
            this.saveChemicalPreset(),
          );
          this.clearChemicalPresetsBtn.addEventListener("click", () =>
            this.clearChemicalPresets(),
          );
          this.addChemicalBtn.addEventListener("click", () =>
            this.addChemical(),
          );
          this.clearExpiredBtn.addEventListener("click", () =>
            this.clearExpired(),
          );

          // Custom paper size button
          this.useCustomSizeBtn.addEventListener("click", () => {
            const customSize = parseFloat(this.customPaperSizeInput.value);
            if (customSize && customSize > 0) {
              this.setPaperSize(customSize);
              // Show visual feedback
              this.useCustomSizeBtn.textContent = "✓ Used";
              this.useCustomSizeBtn.classList.add("active");
              setTimeout(() => {
                this.useCustomSizeBtn.textContent = "Use";
                this.useCustomSizeBtn.classList.remove("active");
              }, 1000);
            }
          });
        }

        /**
         * Update mix calculator calculations
         * @returns {void}
         * @description Calculates stock and water volumes based on total volume and dilution ratio
         */
        updateMixCalculator() {
          this.totalVolume = parseInt(this.totalVolumeSlider.value);
          this.totalVolumeValue.textContent = `${this.totalVolume}ml`;

          let stockParts, waterParts;

          // Check if a preset button is active
          const activeBtn = document.querySelector(
            ".toggle-btn[data-ratio].active",
          );
          if (activeBtn) {
            const parts = activeBtn.getAttribute("data-ratio").split("+");
            stockParts = parseInt(parts[0]);
            waterParts = parseInt(parts[1]);
          } else {
            // Use custom values
            stockParts = this.customStockParts;
            waterParts = this.customWaterParts;
          }

          const totalParts = stockParts + waterParts;
          const stockVolume = Math.round(
            (this.totalVolume / totalParts) * stockParts,
          );
          const waterVolume = Math.round(
            (this.totalVolume / totalParts) * waterParts,
          );

          // Adjust for rounding errors
          const adjustedStockVolume = Math.min(stockVolume, this.totalVolume);
          const adjustedWaterVolume = this.totalVolume - adjustedStockVolume;

          this.stockVolumeElement.textContent = `${adjustedStockVolume}ml`;
          this.waterVolumeElement.textContent = `${adjustedWaterVolume}ml`;
        }

        /**
         * Save current chemical mix as a preset
         * @returns {boolean} Success status
         */
        saveChemicalPreset() {
          const name = this.chemicalPresetNameInput.value.trim();

          const result = settingsManager.savePreset({
            name,
            dataObject: {
              totalVolume: this.totalVolume,
              dilutionRatio: this.dilutionRatio,
              customStockParts: this.customStockParts,
              customWaterParts: this.customWaterParts,
            },
            collection: this.chemicalPresets,
            storageMethod: (presets) =>
              StorageManager.saveChemicalPresets(presets),
            updateListMethod: () => this.updateChemicalPresetList(),
            feedbackMethod: (msg, type) =>
              settingsManager.showAllProfilesFeedback(msg, type),
            successMessage: `Preset "${name}" saved!`,
          });

          if (result) {
            this.chemicalPresetNameInput.value = "";
          }
        }

        loadChemicalPreset(preset) {
          this.setCurrentPreset(preset.name);
          this.totalVolumeSlider.value = preset.totalVolume;
          this.totalVolume = preset.totalVolume;

          // Try to find matching dilution button
          const matchingBtn = Array.from(this.dilutionBtns).find(
            (btn) => btn.getAttribute("data-ratio") === preset.dilutionRatio,
          );

          if (matchingBtn) {
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            matchingBtn.classList.add("active");
            this.dilutionRatio = preset.dilutionRatio;
          } else {
            // Use custom values
            this.dilutionBtns.forEach((b) => b.classList.remove("active"));
            this.customStockParts = preset.customStockParts;
            this.customWaterParts = preset.customWaterParts;
            this.customStockPartsInput.value = preset.customStockParts;
            this.customWaterPartsInput.value = preset.customWaterParts;
          }

          this.updateMixCalculator();
          this.updateChemicalPresetList();
          playBeep(600, 0.3, 0.3);
          settingsManager.showAllProfilesFeedback(
            `Preset "${preset.name}" loaded!`,
            "success",
          );
          return true;
        }

        deleteChemicalPreset(presetName) {
          return settingsManager.deletePreset({
            name: presetName,
            collection: this.chemicalPresets,
            storageMethod: (presets) =>
              StorageManager.saveChemicalPresets(presets),
            updateListMethod: () => this.updateChemicalPresetList(),
            confirmMessage: `Delete preset "${presetName}"?`,
            successMessage: `Preset "${presetName}" deleted!`,
            onDeleteCallback: () => {
              if (this.getCurrentPreset() === presetName) {
                this.setCurrentPreset(null);
              }
            },
          });
        }

        updateChemicalPresetList() {
          settingsManager.renderPresetList({
            listElement: this.chemicalPresetList,
            collection: this.chemicalPresets,
            currentItem: this.getCurrentPreset(),
            renderItemContent: (preset) => {
              const ratio = preset.dilutionRatio
                ? `Ratio: ${preset.dilutionRatio}`
                : `Custom: ${preset.customStockParts}+${preset.customWaterParts}`;

              return `
                        <div>
                            <strong>${preset.name}</strong>
                            <div style="font-size: 0.65rem; color: var(--text-secondary);">${new Date(
                              preset.date,
                            ).toLocaleDateString()}</div>
                            <div style="font-size: 0.6rem; color: var(--accent);">${ratio} • ${
                              preset.totalVolume
                            }ml</div>
                        </div>
                        <div class="shelf-life-actions">
                            <button class="btn-action load-btn" data-context="preset" data-name="${
                              preset.name
                            }">Load</button>
                            <button class="btn-action delete-btn" data-context="preset" data-name="${
                              preset.name
                            }">Delete</button>
                        </div>
                    `;
            },
          });
        }

        clearChemicalPresets() {
          return settingsManager.clearAllPresets({
            collection: this.chemicalPresets,
            storageMethod: (presets) =>
              StorageManager.saveChemicalPresets(presets),
            updateListMethod: () => this.updateChemicalPresetList(),
            feedbackMethod: (msg, type) =>
              settingsManager.showAllProfilesFeedback(msg, type),
            confirmMessage:
              "Delete ALL chemical presets? This cannot be undone!",
            successMessage: "All chemical presets deleted!",
            onClearCallback: () => {
              this.setCurrentPreset(null);
            },
          });
        }

        // UPDATED: Paper area based capacity calculations
        setPaperSize(size) {
          this.currentPaperSize = size;
          this.capacityData.paperSize = size;

          // Update button states
          this.paperSizeBtns.forEach((btn) => {
            btn.classList.remove("active");
            const btnSize = parseFloat(btn.getAttribute("data-size"));
            if (Math.abs(btnSize - size) < 0.001) {
              btn.classList.add("active");
            }
          });

          this.updateCapacityDisplay();
          StorageManager.saveCapacityTracker(this.capacityData);
        }

        updateCapacityDisplay() {
          const capacityPerLiter = parseFloat(this.capacitySlider.value); // m² per liter
          const trayVolume = parseInt(this.trayVolumeSlider.value); // ml
          const trayVolumeLiters = trayVolume / 1000;

          this.capacityValue.textContent = capacityPerLiter.toFixed(1);
          this.trayVolumeValue.textContent = trayVolume;

          // Calculate maximum area and prints
          const maxArea = capacityPerLiter * trayVolumeLiters; // m²
          const areaUsed = this.capacityData.areaUsed || 0;
          const printsDone = this.capacityData.printsDone || 0;

          const maxPrints = Math.floor(maxArea / this.currentPaperSize);
          const remainingArea = Math.max(0, maxArea - areaUsed);
          const remainingPrints = Math.floor(
            remainingArea / this.currentPaperSize,
          );

          this.maxPrintsValue.textContent = maxPrints;
          this.printsRemaining.textContent = `${remainingPrints} prints remaining (${remainingArea.toFixed(
            3,
          )} m²)`;

          const percentUsed =
            maxArea > 0 ? Math.min(100, (areaUsed / maxArea) * 100) : 0;

          this.printsDoneValue.textContent = printsDone;
          this.areaUsedValue.textContent = `${areaUsed.toFixed(3)} m²`;
          this.percentUsedValue.textContent = `${percentUsed.toFixed(0)}%`;

          // Update progress bar
          this.capacityProgressBar.style.width = `${percentUsed}%`;
          const middlePrints = Math.round(maxPrints / 2);
          this.capacityMiddleLabel.textContent = middlePrints;
          this.capacityMaxLabel.textContent = maxPrints;

          // Update status based on area usage
          if (percentUsed >= 100) {
            this.capacityStatus.textContent = "Exhausted";
            this.capacityStatus.style.color = "#f00";
          } else if (percentUsed >= 85) {
            this.capacityStatus.textContent = "Nearly Used";
            this.capacityStatus.style.color = "#ff5500";
          } else if (percentUsed >= 60) {
            this.capacityStatus.textContent = "Well Used";
            this.capacityStatus.style.color = "#ffaa00";
          } else if (percentUsed >= 30) {
            this.capacityStatus.textContent = "Partially Used";
            this.capacityStatus.style.color = "#ffff00";
          } else {
            this.capacityStatus.textContent = "Fresh";
            this.capacityStatus.style.color = "#0a0";
          }

          // Update theme colors
          if (document.body.classList.contains("light-scheme")) {
            const colors = {
              Exhausted: "#cc0000",
              "Nearly Used": "#ff6600",
              "Well Used": "#ff9900",
              "Partially Used": "#ffcc00",
              Fresh: "#006600",
            };
            this.capacityStatus.style.color =
              colors[this.capacityStatus.textContent] || "#006600";
          } else if (document.body.classList.contains("day-scheme")) {
            const colors = {
              Exhausted: "#ff3333",
              "Nearly Used": "#ff9900",
              "Well Used": "#ffcc00",
              "Partially Used": "#ffff33",
              Fresh: "#33cc33",
            };
            this.capacityStatus.style.color =
              colors[this.capacityStatus.textContent] || "#33cc33";
          }
        }

        addPrints(count) {
          const areaToAdd = count * this.currentPaperSize;
          this.capacityData.printsDone =
            (this.capacityData.printsDone || 0) + count;
          this.capacityData.areaUsed =
            (this.capacityData.areaUsed || 0) + areaToAdd;
          StorageManager.saveCapacityTracker(this.capacityData);
          this.updateCapacityDisplay();
          playBeep(600, 0.2, 0.3);
        }

        resetPrints() {
          if (confirm("Reset print counter? This will start a fresh batch.")) {
            this.capacityData = {
              printsDone: 0,
              areaUsed: 0,
              paperSize: this.currentPaperSize,
              lastReset: new Date().toISOString(),
            };
            StorageManager.saveCapacityTracker(this.capacityData);
            this.updateCapacityDisplay();
            playBeep(800, 0.5, 0.3);
          }
        }

        // UPDATED: Add chemical with custom name support
        addChemical() {
          const type = this.chemicalTypeSelect.value;
          const shelfLifeDays = parseInt(this.shelfLifeDaysInput.value);
          const date = this.chemicalDateInput.value;

          if (!date) {
            alert("Please select a date");
            return;
          }

          let chemicalName;
          if (type === "custom") {
            chemicalName = this.customChemicalNameInput.value.trim();
            if (!chemicalName) {
              alert("Please enter a custom chemical name");
              return;
            }
          } else {
            chemicalName = this.getChemicalName(type);
          }

          const chemical = {
            id: Date.now(),
            type: type,
            name: chemicalName,
            dateMixed: date,
            shelfLifeDays: shelfLifeDays,
            dateAdded: new Date().toISOString(),
          };

          this.shelfLifeData.push(chemical);
          StorageManager.saveShelfLife(this.shelfLifeData);
          this.updateShelfLifeList();

          // Reset form
          this.chemicalDateInput.value = new Date().toISOString().split("T")[0];
          this.customChemicalNameInput.value = "";

          playBeep(800, 0.3, 0.3);
        }

        getChemicalName(type) {
          const names = {
            developer: "Developer",
            stopbath: "Stop Bath",
            fixer: "Fixer",
            hypoclear: "Hypo Clear",
            photof: "Photo Wash",
            custom: "Custom Chemical",
          };
          return names[type] || type;
        }

        loadShelfLifeData(data) {
          if (!data || !Array.isArray(data)) return;

          // Clear existing data
          this.shelfLifeData = [];

          // Load new data with validation
          data.forEach((chemical) => {
            if (
              chemical &&
              chemical.name &&
              chemical.dateMixed &&
              chemical.shelfLifeDays
            ) {
              this.shelfLifeData.push({
                id: chemical.id || Date.now() + Math.random(),
                type: chemical.type || "custom",
                name: chemical.name,
                dateMixed: chemical.dateMixed,
                shelfLifeDays: chemical.shelfLifeDays,
                dateAdded: chemical.dateAdded || new Date().toISOString(),
              });
            }
          });

          // Save to storage
          StorageManager.saveShelfLife(this.shelfLifeData);
          this.updateShelfLifeList();
        }

        updateShelfLifeList() {
          this.shelfLifeList.innerHTML = "";

          const today = new Date();
          this.shelfLifeData.forEach((chemical, index) => {
            const mixedDate = new Date(chemical.dateMixed);
            const expiryDate = new Date(mixedDate);
            expiryDate.setDate(expiryDate.getDate() + chemical.shelfLifeDays);

            const daysLeft = Math.ceil(
              (expiryDate - today) / (1000 * 60 * 60 * 24),
            );

            const item = document.createElement("div");
            item.className = "shelf-life-item";

            if (daysLeft < 0) {
              item.classList.add("expired");
            } else if (daysLeft <= 3) {
              item.classList.add("expiring");
            }

            let statusClass = "";
            let statusText = "";
            if (daysLeft < 0) {
              statusClass = "expired";
              statusText = "EXPIRED";
            } else if (daysLeft <= 3) {
              statusClass = "expiring";
              statusText = "EXPIRING";
            } else {
              statusText = `${daysLeft} days`;
            }

            item.innerHTML = `
                        <div>
                            <strong>${chemical.name}</strong>
                            <div style="font-size: 0.6rem; color: var(--accent);">
                                Mixed: ${new Date(
                                  chemical.dateMixed,
                                ).toLocaleDateString()}
                            </div>
                            <div style="font-size: 0.6rem; color: var(--accent);">
                                Expires: ${expiryDate.toLocaleDateString()}
                            </div>
                        </div>
                        <div style="text-align: right;">
                            <div class="shelf-life-days ${statusClass}">${statusText}</div>
                            <div class="shelf-life-actions">
                                <button class="btn-action renew-btn" data-context="chemical" data-id="${
                                  chemical.id
                                }">Renew</button>
                                <button class="btn-action delete-btn" data-context="chemical" data-id="${
                                  chemical.id
                                }">Delete</button>
                            </div>
                        </div>
                    `;

            this.shelfLifeList.appendChild(item);
          });

          // Event handlers now via delegation - no individual listeners needed
        }

        renewChemical(id) {
          if (
            confirm(
              "Renew this chemical? This will reset its shelf life from today.",
            )
          ) {
            const index = this.shelfLifeData.findIndex((c) => c.id === id);
            if (index !== -1) {
              this.shelfLifeData[index].dateMixed = new Date()
                .toISOString()
                .split("T")[0];
              StorageManager.saveShelfLife(this.shelfLifeData);
              this.updateShelfLifeList();
              playBeep(600, 0.3, 0.3);
            }
          }
        }

        deleteChemical(id) {
          if (confirm("Delete this chemical from tracking?")) {
            this.shelfLifeData = this.shelfLifeData.filter((c) => c.id !== id);
            StorageManager.saveShelfLife(this.shelfLifeData);
            this.updateShelfLifeList();
            playBeep(400, 0.3, 0.3);
          }
        }

        clearExpired() {
          if (confirm("Remove all expired chemicals?")) {
            const today = new Date();
            this.shelfLifeData = this.shelfLifeData.filter((chemical) => {
              const mixedDate = new Date(chemical.dateMixed);
              const expiryDate = new Date(mixedDate);
              expiryDate.setDate(expiryDate.getDate() + chemical.shelfLifeDays);
              const daysLeft = Math.ceil(
                (expiryDate - today) / (1000 * 60 * 60 * 24),
              );
              return daysLeft > 0;
            });

            StorageManager.saveShelfLife(this.shelfLifeData);
            this.updateShelfLifeList();
            playBeep(800, 0.5, 0.3);
          }
        }

        updateDisplay() {
          this.updateMixCalculator();
          this.updateCapacityDisplay();
          this.updateChemicalPresetList();
          this.updateShelfLifeList();
        }
      }

      /**
       * @class SplitGradeCalculator
       * @classdesc Split-grade printing calculator with filter factor compensation.
       * Calculates highlight and shadow exposure times based on base time,
       * paper brand, and filter selections.
       *
       * @property {number} baseTime - Base exposure time in seconds
       * @property {string} paperBrand - Paper brand ('Ilford', 'FOMA')
       * @property {string} fomaPaperType - FOMA paper type ('fomaspeed' or 'fomatonemg')
       * @property {string} softFilter - Soft filter number (e.g., '0', '4', '5')
       * @property {string} hardFilter - Hard filter number
       * @property {Object} splitPresets - Saved split-grade configurations
       * @property {string} currentSplitPreset - Currently loaded preset name
       */
      function applySplitGradeToCalc(splitData) {
        if (!splitData) return;

        const formatTime = (value) =>
          Number.isFinite(value) ? value.toFixed(2) : "--";

        appState.calculator.splitGrade = {
          enabled: true,
          neutralTime: splitData.neutralTime,
          highlightsBase: splitData.highlightsBase,
          shadowsBase: splitData.shadowsBase,
          softTime: splitData.softTime,
          hardTime: splitData.hardTime,
          totalTime: splitData.totalTime,
          softFilter: splitData.softFilter,
          hardFilter: splitData.hardFilter,
          paperBrand: splitData.paperBrand || null,
          fomaPaperType: splitData.fomaPaperType || null,
          burnPercent: splitData.burnPercent || null,
          softFactor: splitData.softFactor || null,
          hardFactor: splitData.hardFactor || null,
        };

        const display = document.getElementById("splitGradeDisplay");
        const neutralDisplay = document.getElementById("splitNeutralDisplay");
        const splitTimeDisplay = document.getElementById(
          "splitTimeDisplayCalc",
        );
        const totalDisplay = document.getElementById("splitTotalDisplay");
        const highlightsSpan = document.getElementById("highlightsTime");
        const shadowsSpan = document.getElementById("shadowsTime");

        if (display) display.style.display = "block";
        if (neutralDisplay)
          neutralDisplay.textContent = `${formatTime(splitData.neutralTime)}s`;
        if (splitTimeDisplay)
          splitTimeDisplay.textContent = `${formatTime(
            splitData.highlightsBase,
          )}s / ${formatTime(splitData.shadowsBase)}s`;
        if (totalDisplay)
          totalDisplay.textContent = `${formatTime(splitData.totalTime)}s`;
        if (highlightsSpan)
          highlightsSpan.textContent = `${formatTime(
            splitData.softTime,
          )}s (F${splitData.softFilter || "--"})`;
        if (shadowsSpan)
          shadowsSpan.textContent = `${formatTime(
            splitData.hardTime,
          )}s (F${splitData.hardFilter || "--"})`;

        switchTab("calc");

        const container = document.querySelector(".container");
        if (container) {
          container.scrollTop = 0;
        }
        window.scrollTo(0, 0);
      }

      class SplitGradeCalculator {
        /**
         * Creates a SplitGradeCalculator instance
         * @constructor
         */
        constructor() {
          this.neutralTime = 10.0; // Test strip result
          this.paperBrand = "FOMA";
          this.fomaPaperType = "fomaspeed"; // fomaspeed or fomatonemg
          this.ilfordPaperType = "cooltone"; // cooltone, portfolio, etc.
          this.softFilter = "00";
          this.hardFilter = "5";
          this.burnPercent = 50; // Shadow burn percentage

          this.splitPresets = StorageManager.loadSplitPresets();
          this.currentSplitPreset = StorageManager.loadCurrentSplitPreset();

          // Initialize UI
          this.initializeUI();
        }

        /**
         * Filter factor database
         * @static
         * @type {Object}
         * @description
         * Predefined filter factors for standard paper brands.
         * - Ilford: Standard Multigrade filter factors
         * - FOMA: Base factors (overridden by paper-specific when FOMA selected)
         * - FOMASPEED/FOMATONE: Paper-specific FOMA factors
         */
        static FILTER_FACTORS = {
          // Ilford paper-specific factors
          ILFORD_COOLTONE: {
            "00": 2.5,
            0: 2.5,
            1: 2.5,
            2: 2.5,
            3: 2.5,
            4: 5.0,
            5: 5.0,
          },
          ILFORD_PORTFOLIO: {
            "00": 2.5,
            0: 2.5,
            1: 2.5,
            2: 2.5,
            3: 2.5,
            4: 5.0,
            5: 5.0,
          },
          ILFORD_RC_DELUXE_NEW: {
            "00": 2.08,
            0: 2.08,
            1: 2.08,
            2: 2.08,
            3: 2.08,
            4: 2.27,
            5: 2.27,
          },
          ILFORD_RC_PORTFOLIO_NEW: {
            "00": 2.08,
            0: 2.08,
            1: 2.08,
            2: 2.08,
            3: 2.08,
            4: 2.27,
            5: 2.27,
          },
          ILFORD_FB_CLASSIC: {
            "00": 2.17,
            0: 2.17,
            1: 2.17,
            2: 2.17,
            3: 2.17,
            4: 2.38,
            5: 2.38,
          },
          ILFORD_FB_WARMTONE: {
            "00": 2.17,
            0: 2.17,
            1: 2.17,
            2: 2.17,
            3: 2.17,
            4: 2.38,
            5: 2.38,
          }, // Assuming same as FB Classic
          ILFORD_FB_COOLTONE: {
            "00": 2.17,
            0: 2.17,
            1: 2.17,
            2: 2.17,
            3: 2.17,
            4: 2.38,
            5: 2.38,
          }, // Assuming same as FB Classic

          // Legacy Ilford entry for backward compatibility
          Ilford: { "00": 2.5, 0: 2.5, 1: 2.5, 2: 2.5, 3: 2.5, 4: 5.0, 5: 5.0 },

          FOMA: { "00": 1.6, 0: 1.4, 1: 1.0, 2: 1.4, 3: 2.1, 4: 2.6, 5: 4.6 },
          // FOMA paper-specific factors (will override base FOMA when selected)
          FOMASPEED: {
            "00": 1.6,
            0: 1.4,
            1: 1.0,
            2: 1.4,
            3: 2.1,
            4: 2.6,
            5: 4.6,
          },
          FOMATONE: {
            "00": 2.0,
            0: 1.5,
            1: 1.0,
            2: 1.5,
            3: 1.8,
            4: 2.0,
            5: 3.0,
          },
          FOMAPASTEL_MG: {
            "2xY": 1.5,
            Y: 1.4,
            None: 1.0,
            M1: 1.4,
            "2xM1": 2.0,
            M2: 2.5,
            "2xM2": 4.5,
          },
          FOMATONE_MG_CLASSIC_VARIANT: {
            "2xY": 2.0,
            Y: 1.5,
            None: 1.0,
            M1: 1.5,
            "2xM1": 1.8,
            M2: 2.0,
            "2xM2": 3.0,
          },
          // Custom factors are stored in instance properties, not here
        };

        /**
         * Initialize UI event listeners
         */
        initializeUI() {
          // Neutral time slider (replaces base time)
          const neutralSlider = document.getElementById("neutralTimeSlider");
          if (neutralSlider) {
            neutralSlider.addEventListener("input", (e) => {
              this.neutralTime = parseFloat(e.target.value);
              document.getElementById("neutralTimeValue").textContent =
                `${this.neutralTime.toFixed(1)}s`;
              this.calculate();
            });
          }

          // Paper brand toggle buttons (replaces dropdown)
          const btnSplitFoma = document.getElementById("btnSplitFoma");
          const btnSplitIlford = document.getElementById("btnSplitIlford");

          if (btnSplitFoma && btnSplitIlford) {
            // Set initial active state
            btnSplitFoma.classList.toggle("active", this.paperBrand === "FOMA");
            btnSplitIlford.classList.toggle(
              "active",
              this.paperBrand === "Ilford",
            );

            btnSplitFoma.addEventListener("click", () => {
              this.setPaperBrand("FOMA");
            });

            btnSplitIlford.addEventListener("click", () => {
              this.setPaperBrand("Ilford");
            });
          }

          // FOMA paper type dropdown (replaces toggle buttons)
          const splitFomaPaperType =
            document.getElementById("splitFomaPaperType");
          if (splitFomaPaperType) {
            // Set initial value
            splitFomaPaperType.value = this.fomaPaperType;

            splitFomaPaperType.addEventListener("change", (e) => {
              this.fomaPaperType = e.target.value;
              this.calculate();
            });
          }

          // Ilford paper type dropdown (new)
          const splitIlfordPaperType = document.getElementById(
            "splitIlfordPaperType",
          );
          if (splitIlfordPaperType) {
            // Set initial value (default Ilford paper type)
            splitIlfordPaperType.value = this.ilfordPaperType;

            splitIlfordPaperType.addEventListener("change", (e) => {
              this.ilfordPaperType = e.target.value;
              this.calculate();
            });
          }

          // Burn percentage slider
          const burnSlider = document.getElementById("burnPercentSlider");
          if (burnSlider) {
            burnSlider.addEventListener("input", (e) => {
              this.burnPercent = parseInt(e.target.value);
              document.getElementById("burnPercentValue").textContent =
                `${this.burnPercent}%`;
              this.calculate();
            });
          }

          // Filter segmented controls
          this.initializeFilterControl("splitSoftFilter", "soft");
          this.initializeFilterControl("splitHardFilter", "hard");

          // Action buttons
          const sendBtn = document.getElementById("sendToCalc");
          if (sendBtn) {
            sendBtn.addEventListener("click", () => this.sendToCalc());
          }

          // Preset save/load buttons
          const savePresetBtn = document.getElementById("saveSplitPreset");
          if (savePresetBtn) {
            savePresetBtn.addEventListener("click", () => this.savePreset());
          }

          const clearPresetsBtn = document.getElementById("clearSplitPresets");
          if (clearPresetsBtn) {
            clearPresetsBtn.addEventListener("click", () =>
              this.clearAllPresets(),
            );
          }

          // Initial calculation
          this.updateBrandVisibility();
          this.updateFilterLabels();
          this.calculate();
          this.updatePresetList();
        }

        /**
         * Initialize filter segmented control
         */
        initializeFilterControl(containerId, type) {
          const container = document.getElementById(containerId);
          if (!container) return;

          container.addEventListener("click", (e) => {
            const btn = e.target.closest(".segmented-btn");
            if (!btn) return;

            // Remove active from all
            container
              .querySelectorAll(".segmented-btn")
              .forEach((b) => b.classList.remove("active"));

            // Add active to clicked
            btn.classList.add("active");

            // Update state
            const filter = btn.dataset.filter;
            if (type === "soft") {
              this.softFilter = filter;
            } else {
              this.hardFilter = filter;
            }

            this.calculate();
          });

          // Set initial active state
          const defaultFilter =
            type === "soft" ? this.softFilter : this.hardFilter;
          const defaultBtn = container.querySelector(
            `[data-filter="${defaultFilter}"]`,
          );
          if (defaultBtn) {
            defaultBtn.classList.add("active");
          }
        }

        /**
         * Set paper brand and update UI
         */
        setPaperBrand(brand) {
          this.paperBrand = brand;

          // Update toggle button states
          const btnSplitFoma = document.getElementById("btnSplitFoma");
          const btnSplitIlford = document.getElementById("btnSplitIlford");

          if (btnSplitFoma && btnSplitIlford) {
            btnSplitFoma.classList.toggle("active", brand === "FOMA");
            btnSplitIlford.classList.toggle("active", brand === "Ilford");
          }

          // Update brand visibility
          this.updateBrandVisibility();
          this.calculate();
        }

        /**
         * Update visibility of brand-specific sections
         */
        updateBrandVisibility() {
          const fomaSection = document.getElementById("fomaPaperSelection");
          const ilfordSection = document.getElementById("ilfordPaperSelection");

          if (this.paperBrand === "FOMA") {
            fomaSection.style.display = "block";
            if (ilfordSection) ilfordSection.style.display = "none";
          } else if (this.paperBrand === "Ilford") {
            if (fomaSection) fomaSection.style.display = "none";
            if (ilfordSection) ilfordSection.style.display = "block";
          } else {
            if (fomaSection) fomaSection.style.display = "none";
            if (ilfordSection) ilfordSection.style.display = "none";
          }

          // Update filter labels based on brand
          this.updateFilterLabels();
        }

        /**
         * Update filter button labels based on selected brand
         */
        updateFilterLabels() {
          const softContainer = document.getElementById("splitSoftFilter");
          const hardContainer = document.getElementById("splitHardFilter");

          if (!softContainer || !hardContainer) return;

          // Define filter labels for each brand
          const filterLabels = {
            FOMA: {
              "00": "2xY",
              0: "Y",
              1: "No filter",
              2: "M1",
              3: "2xM1",
              4: "M2",
              5: "2xM2",
            },
            Ilford: {
              "00": "00",
              0: "0",
              1: "1",
              2: "2",
              3: "3",
              4: "4",
              5: "5",
            },
          };

          // Get labels for current brand
          const labels = filterLabels[this.paperBrand] || filterLabels.Ilford;

          // Update both soft and hard filter containers
          [softContainer, hardContainer].forEach((container) => {
            const buttons = container.querySelectorAll(".segmented-btn");
            buttons.forEach((btn) => {
              const filterValue = btn.dataset.filter;
              if (labels[filterValue]) {
                btn.textContent = labels[filterValue];
              }
            });
          });
        }

        /**
         * Calculate split-grade times using user's burn method
         *
         * Formula:
         * Highlights = Neutral Time × (100% - burn%) / 100
         * Shadows = Neutral Time × burn% / 100
         * Then apply filter factors to each
         *
         * Filter factor selection:
         * - Ilford: Use predefined factors from FILTER_FACTORS
         * - FOMA: Use paper-specific factors (FOMASPEED or FOMATONE)
         */
        calculate() {
          let softFactor, hardFactor;

          if (this.paperBrand === "FOMA") {
            // Use paper-specific FOMA factors
            let fomaKey;
            if (
              this.fomaPaperType === "fomaspeed" ||
              this.fomaPaperType === "fomabrom"
            ) {
              fomaKey = "FOMASPEED";
            } else if (this.fomaPaperType === "fomapastel_mg") {
              fomaKey = "FOMAPASTEL_MG";
            } else if (this.fomaPaperType === "fomatone_mg_classic_variant") {
              fomaKey = "FOMATONE_MG_CLASSIC_VARIANT";
            } else {
              fomaKey = "FOMATONE"; // Fallback
            }

            // Get the factor object for this paper type
            const factorObj = SplitGradeCalculator.FILTER_FACTORS[fomaKey];
            if (!factorObj) {
              softFactor = 1.0;
              hardFactor = 1.0;
            } else {
              // Handle different key formats (Ilford numbers vs FOMA names)
              let softKey = this.softFilter;
              let hardKey = this.hardFilter;

              // For FOMA papers using FOMA filter names, we need to map Ilford numbers to FOMA names
              if (
                fomaKey === "FOMAPASTEL_MG" ||
                fomaKey === "FOMATONE_MG_CLASSIC_VARIANT"
              ) {
                // Map Ilford numbers to FOMA filter names
                const ilfordToFomaMap = {
                  "00": "2xY",
                  0: "Y",
                  1: "None",
                  2: "M1",
                  3: "2xM1",
                  4: "M2",
                  5: "2xM2",
                };
                softKey = ilfordToFomaMap[this.softFilter] || this.softFilter;
                hardKey = ilfordToFomaMap[this.hardFilter] || this.hardFilter;
              }

              softFactor = factorObj[softKey] || 1.0;
              hardFactor = factorObj[hardKey] || 1.0;
            }
          } else if (this.paperBrand === "Ilford") {
            // Use paper-specific Ilford factors
            let ilfordKey;
            if (this.ilfordPaperType === "cooltone") {
              ilfordKey = "ILFORD_COOLTONE";
            } else if (this.ilfordPaperType === "portfolio") {
              ilfordKey = "ILFORD_PORTFOLIO";
            } else if (this.ilfordPaperType === "rc_deluxe_new") {
              ilfordKey = "ILFORD_RC_DELUXE_NEW";
            } else if (this.ilfordPaperType === "rc_portfolio_new") {
              ilfordKey = "ILFORD_RC_PORTFOLIO_NEW";
            } else if (this.ilfordPaperType === "fb_classic") {
              ilfordKey = "ILFORD_FB_CLASSIC";
            } else if (this.ilfordPaperType === "fb_warmtone") {
              ilfordKey = "ILFORD_FB_WARMTONE";
            } else if (this.ilfordPaperType === "fb_cooltone") {
              ilfordKey = "ILFORD_FB_COOLTONE";
            } else {
              ilfordKey = "Ilford"; // Fallback to legacy entry
            }

            const factorObj = SplitGradeCalculator.FILTER_FACTORS[ilfordKey];
            softFactor = factorObj ? factorObj[this.softFilter] || 1.0 : 1.0;
            hardFactor = factorObj ? factorObj[this.hardFilter] || 1.0 : 1.0;
          } else {
            // Fallback for any other brand (should not happen)
            softFactor = 1.0;
            hardFactor = 1.0;
          }

          // Calculate base times based on burn percentage
          const highlightsBase =
            (this.neutralTime * (100 - this.burnPercent)) / 100;
          const shadowsBase = this.neutralTime * (this.burnPercent / 100);

          // Apply filter factors
          const softTime = highlightsBase * softFactor;
          const hardTime = shadowsBase * hardFactor;

          // Total exposure
          const totalTime = softTime + hardTime;

          // Update display
          const splitDisplay = document.getElementById("splitTimeDisplay");
          const softResult = document.getElementById("softResult");
          const hardResult = document.getElementById("hardResult");
          const totalResult = document.getElementById("totalResult");

          if (splitDisplay)
            splitDisplay.textContent = `${highlightsBase.toFixed(
              2,
            )}s / ${shadowsBase.toFixed(2)}s`;
          if (softResult) softResult.textContent = `${softTime.toFixed(2)} s`;
          if (hardResult) hardResult.textContent = `${hardTime.toFixed(2)} s`;
          if (totalResult)
            totalResult.textContent = `${totalTime.toFixed(2)} s`;

          return {
            highlightsBase,
            shadowsBase,
            softTime,
            hardTime,
            totalTime,
            softFactor,
            hardFactor,
            burnPercent: this.burnPercent,
          };
        }

        /**
         * Send calculated times to CALC tab
         */
        sendToCalc() {
          const result = this.calculate();

          applySplitGradeToCalc({
            neutralTime: this.neutralTime,
            highlightsBase: result.highlightsBase,
            shadowsBase: result.shadowsBase,
            softTime: result.softTime,
            hardTime: result.hardTime,
            totalTime: result.totalTime,
            softFilter: this.softFilter,
            hardFilter: this.hardFilter,
            paperBrand: this.paperBrand,
            fomaPaperType: this.fomaPaperType,
            burnPercent: this.burnPercent,
            softFactor: result.softFactor,
            hardFactor: result.hardFactor,
          });

          // Log split-grade session
          if (window.exposureLogManager) {
            window.exposureLogManager.addSplitPhase({
              neutralTime: this.neutralTime,
              paperBrand: this.paperBrand,
              softFilter: this.softFilter,
              hardFilter: this.hardFilter,
              filterBrand: this.paperBrand,
              highlightsBase: result.highlightsBase,
              shadowsBase: result.shadowsBase,
              softTime: result.softTime,
              hardTime: result.hardTime,
              totalTime: result.totalTime,
              burnPercent: this.burnPercent,
            });
          }

          // Show feedback
          playBeep(800, 0.3, 0.3);
          settingsManager.showAllProfilesFeedback(
            `Split-grade sent: ${result.softTime.toFixed(
              2,
            )}s + ${result.hardTime.toFixed(2)}s = ${result.totalTime.toFixed(
              2,
            )}s total`,
            "success",
          );
        }

        /**
         * Reset calculator
         */
        reset() {
          this.neutralTime = 10.0;
          this.paperBrand = "Ilford";
          this.fomaPaperType = "fomaspeed";
          this.ilfordPaperType = "cooltone";
          this.softFilter = "00";
          this.hardFilter = "5";
          this.burnPercent = 50;

          // Update UI
          document.getElementById("neutralTimeSlider").value = 10.0;
          document.getElementById("neutralTimeValue").textContent = "10.0s";

          // Update paper brand toggle buttons
          const btnSplitFoma = document.getElementById("btnSplitFoma");
          const btnSplitIlford = document.getElementById("btnSplitIlford");
          if (btnSplitFoma) btnSplitFoma.classList.remove("active");
          if (btnSplitIlford) btnSplitIlford.classList.add("active");

          document.getElementById("burnPercentSlider").value = 50;
          document.getElementById("burnPercentValue").textContent = "50%";

          // Reset custom inputs (all 7 grades)
          const gradeKeys = ["00", "0", "1", "2", "3", "4", "5"];
          gradeKeys.forEach((grade) => {
            const input = document.getElementById(`customFactor${grade}`);
            if (input) input.value = "1.0";
          });

          // Reset FOMA paper type dropdown
          const splitFomaPaperType =
            document.getElementById("splitFomaPaperType");
          if (splitFomaPaperType) splitFomaPaperType.value = "fomaspeed";

          // Reset Ilford paper type dropdown
          const splitIlfordPaperType = document.getElementById(
            "splitIlfordPaperType",
          );
          if (splitIlfordPaperType)
            splitIlfordPaperType.value = this.ilfordPaperType;

          // Reset filter controls
          document
            .querySelectorAll("#splitSoftFilter .segmented-btn")
            .forEach((b) => b.classList.remove("active"));
          document
            .querySelectorAll("#splitHardFilter .segmented-btn")
            .forEach((b) => b.classList.remove("active"));
          document
            .querySelector('#splitSoftFilter [data-filter="00"]')
            ?.classList.add("active");
          document
            .querySelector('#splitHardFilter [data-filter="5"]')
            ?.classList.add("active");

          // Hide brand-specific sections
          this.updateBrandVisibility();
          this.calculate();
        }

        /**
         * Save current configuration as preset
         */
        savePreset() {
          const nameInput = document.getElementById("splitPresetName");
          const name = nameInput.value.trim();

          if (!name) {
            settingsManager.showAllProfilesFeedback(
              "Please enter a preset name",
              "error",
            );
            return;
          }

          const preset = {
            name: name,
            neutralTime: this.neutralTime,
            paperBrand: this.paperBrand,
            fomaPaperType: this.fomaPaperType,
            ilfordPaperType: this.ilfordPaperType, // Added: Save Ilford paper type
            softFilter: this.softFilter,
            hardFilter: this.hardFilter,
            burnPercent: this.burnPercent,
            date: new Date().toISOString(),
          };

          // Check for existing
          const existingIndex = this.splitPresets.findIndex(
            (p) => p.name === name,
          );
          if (existingIndex >= 0) {
            this.splitPresets[existingIndex] = preset;
          } else {
            this.splitPresets.push(preset);
          }

          // Save
          if (StorageManager.saveSplitPresets(this.splitPresets)) {
            nameInput.value = "";
            this.currentSplitPreset = name;
            StorageManager.saveCurrentSplitPreset(name);
            this.updatePresetList();
            playBeep(800, 0.3, 0.3);
            settingsManager.showAllProfilesFeedback(
              `Split preset "${name}" saved!`,
              "success",
            );
          }
        }

        /**
         * Load a preset
         */
        loadPreset(preset) {
          this.neutralTime = preset.neutralTime || 10.0;
          this.paperBrand = preset.paperBrand || "Ilford";
          this.fomaPaperType = preset.fomaPaperType || "fomaspeed";
          this.ilfordPaperType = preset.ilfordPaperType || "cooltone"; // Added: Load Ilford paper type with default
          this.softFilter = preset.softFilter || "00";
          this.hardFilter = preset.hardFilter || "5";
          this.burnPercent = preset.burnPercent || 50;

          // Update UI
          document.getElementById("neutralTimeSlider").value = this.neutralTime;
          document.getElementById("neutralTimeValue").textContent =
            `${this.neutralTime.toFixed(1)}s`;

          // Update paper brand toggle buttons
          const btnSplitFoma = document.getElementById("btnSplitFoma");
          const btnSplitIlford = document.getElementById("btnSplitIlford");
          if (btnSplitFoma && btnSplitIlford) {
            btnSplitFoma.classList.toggle("active", this.paperBrand === "FOMA");
            btnSplitIlford.classList.toggle(
              "active",
              this.paperBrand === "Ilford",
            );
          }

          document.getElementById("burnPercentSlider").value = this.burnPercent;
          document.getElementById("burnPercentValue").textContent =
            `${this.burnPercent}%`;

          // Update FOMA paper type dropdown
          const splitFomaPaperType =
            document.getElementById("splitFomaPaperType");
          if (splitFomaPaperType) splitFomaPaperType.value = this.fomaPaperType;

          // Update Ilford paper type dropdown
          const splitIlfordPaperType = document.getElementById(
            "splitIlfordPaperType",
          );
          if (splitIlfordPaperType)
            splitIlfordPaperType.value = this.ilfordPaperType;

          // Update filter controls
          document
            .querySelectorAll("#splitSoftFilter .segmented-btn")
            .forEach((b) => b.classList.remove("active"));
          document
            .querySelectorAll("#splitHardFilter .segmented-btn")
            .forEach((b) => b.classList.remove("active"));
          document
            .querySelector(
              `#splitSoftFilter [data-filter="${this.softFilter}"]`,
            )
            ?.classList.add("active");
          document
            .querySelector(
              `#splitHardFilter [data-filter="${this.hardFilter}"]`,
            )
            ?.classList.add("active");

          // Update visibility of brand-specific sections
          this.updateBrandVisibility();

          this.currentSplitPreset = preset.name;
          StorageManager.saveCurrentSplitPreset(preset.name);
          this.updatePresetList();
          this.calculate();

          playBeep(600, 0.3, 0.3);
          settingsManager.showAllProfilesFeedback(
            `Split preset "${preset.name}" loaded!`,
            "success",
          );
        }

        /**
         * Delete a preset
         */
        deletePreset(name) {
          if (!confirm(`Delete split preset "${name}"?`)) return;

          this.splitPresets = this.splitPresets.filter((p) => p.name !== name);
          StorageManager.saveSplitPresets(this.splitPresets);

          if (this.currentSplitPreset === name) {
            this.currentSplitPreset = null;
            StorageManager.saveCurrentSplitPreset(null);
          }

          this.updatePresetList();
          playBeep(400, 0.3, 0.3);
          settingsManager.showAllProfilesFeedback(
            `Split preset "${name}" deleted!`,
            "success",
          );
        }

        /**
         * Clear all presets
         */
        clearAllPresets() {
          if (!confirm("Delete ALL split presets? This cannot be undone!"))
            return;

          this.splitPresets = [];
          this.currentSplitPreset = null;
          StorageManager.saveSplitPresets([]);
          StorageManager.saveCurrentSplitPreset(null);
          this.updatePresetList();

          playBeep(400, 0.3, 0.3);
          settingsManager.showAllProfilesFeedback(
            "All split presets deleted!",
            "success",
          );
        }

        /**
         * Update preset list UI
         */
        updatePresetList() {
          const listElement = document.getElementById("splitPresetList");
          if (!listElement) return;

          listElement.innerHTML = "";

          this.splitPresets.forEach((preset) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = `shelf-life-item ${
              this.currentSplitPreset === preset.name ? "active" : ""
            }`;

            const filterInfo = `F${preset.softFilter}→F${preset.hardFilter} ${preset.burnPercent}%`;
            const dateStr = new Date(preset.date).toLocaleDateString();

            // Build additional info string
            let additionalInfo = "";

            // Paper type display mappings
            const fomaPaperNames = {
              fomaspeed: "FOMASPEED",
              fomabrom: "FOMABROM",
              fomapastel_mg: "FOMAPASTEL MG",
              fomatone_mg_classic_variant: "FOMATONE MG",
            };

            const ilfordPaperNames = {
              cooltone: "RC Cooltone",
              portfolio: "RC Portfolio",
              rc_deluxe_new: "RC Deluxe",
              rc_portfolio_new: "RC Portfolio New",
              fb_classic: "FB Classic",
              fb_warmtone: "FB Warmtone",
              fb_cooltone: "FB Cooltone",
            };

            if (preset.paperBrand === "FOMA" && preset.fomaPaperType) {
              const paperName =
                fomaPaperNames[preset.fomaPaperType] || preset.fomaPaperType;
              additionalInfo = ` • ${paperName}`;
            } else if (
              preset.paperBrand === "Ilford" &&
              preset.ilfordPaperType
            ) {
              const paperName =
                ilfordPaperNames[preset.ilfordPaperType] ||
                preset.ilfordPaperType;
              additionalInfo = ` • ${paperName}`;
            }

            itemDiv.innerHTML = `
              <div>
                <strong>${preset.name}</strong>
                <div style="font-size: 0.65rem; color: var(--text-secondary);">${dateStr}</div>
                <div style="font-size: 0.6rem; color: var(--accent);">${preset.neutralTime}s • ${preset.paperBrand}${additionalInfo} • ${filterInfo}</div>
              </div>
              <div class="shelf-life-actions">
                <button class="btn-action load-btn" data-context="split" data-name="${preset.name}">Load</button>
                <button class="btn-action delete-btn" data-context="split" data-name="${preset.name}">Delete</button>
              </div>
            `;

            listElement.appendChild(itemDiv);
          });
        }
      }

      /**
       * @class RelayManager
       * @classdesc Central hub for managing relay control and server communication.
       * Handles all HTTP requests to Pico 2 W server, manages relay state tracking,
       * implements auto-trigger functionality for timer integration, and provides
       * safelight auto-off feature to prevent fogging during exposures.
       *
       * @property {string} serverIP - The IP address of the Pico 2 W server (default: "192.168.4.1")
       * @property {number} serverPort - The port number of the HTTP server (default: 80)
       * @property {boolean} autoTrigger - Whether to automatically trigger the enlarger relay when timers start
       * @property {boolean} safelightAutoOff - Whether to automatically turn off safelight when enlarger activates
       * @property {boolean} safelightWasOn - Tracks if safelight was on before enlarger started (for restoration)
       * @property {Object} relayStates - Current state of all 4 relays (1-4)
       * @property {HTMLElement} relayServerIP - Input element for server IP
       * @property {HTMLElement} relayServerPort - Input element for server port
       * @property {HTMLElement} testRelayConnectionBtn - Button to test server connection
       * @property {HTMLElement} relayStatus - Status display element
       * @property {HTMLElement} autoTriggerRelay - Checkbox for auto-trigger setting
       * @property {HTMLElement} testTimerRelayBtn - Button to test timer relay
       * @property {HTMLElement} testTimerSeconds - Input for test timer duration
       * @property {HTMLElement} allRelaysOnBtn - Button to turn all relays on
       * @property {HTMLElement} allRelaysOffBtn - Button to turn all relays off
       *
       * @description
       * Relay Mapping (Pico 2 W):
       * - Relay 1 → GP14 (Enlarger Timer) - Primary exposure control
       * - Relay 2 → GP15 (Safelight) - Auto-controlled during exposure
       * - Relay 3 → GP16 (Ventilation)
       * - Relay 4 → GP17 (White Light)
       *
       * Safelight Auto-Off Flow:
       * 1. User starts exposure (CALC, TEST, or TIMER with auto-trigger)
       * 2. If safelight is on, remember state and turn it OFF
       * 3. Server starts GP14 timer for specified duration
       * 4. After duration, safelight is automatically restored
       *
       * Triple-Fallback Fetch Strategy:
       * 1. CORS mode (Chrome/Safari) - preferred
       * 2. no-cors mode - fallback for restricted environments
       * 3. Image object - final fallback for GET requests
       *
       * @example
       * // Initialize relay manager
       * const relayManager = new RelayManager();
       *
       * // Trigger exposure with safelight handling
       * await relayManager.triggerTimerRelay(10.5);
       *
       * // Manual relay control
       * await relayManager.setRelay(1, true); // Turn on enlarger
       * await relayManager.setRelay(2, false); // Turn off safelight
       */
      class RelayManager {
        /**
         * @constructor
         * @description Creates a RelayManager instance with default settings and initializes the relay state tracking.
         * Auto-detects server IP from window.location for seamless AP/STA mode switching.
         * Loads saved settings from localStorage and sets up the initial UI state.
         */
        constructor() {
          // Auto-detect server IP from current page location
          // This ensures it works in both AP mode (192.168.4.1) and STA mode (router-assigned IP)
          this.serverIP = window.location.hostname || "192.168.4.1";
          this.serverPort = parseInt(window.location.port) || 80;
          this.autoTrigger = true;
          this.safelightAutoOff = true; // Default to enabled
          this.safelightWasOn = false; // Track if safelight was on before enlarger

          this.relayStates = {
            1: false, // GP14 - Enlarger Timer
            2: false, // GP15 - Safelight
            3: false, // GP16 - Ventilation
            4: false, // GP17 - White Light
          };

          this.init();
        }

        /**
         * @method init
         * @description Initializes the RelayManager by loading saved settings, binding UI elements,
         * and setting up event listeners. Also synchronizes with SettingsManager for safelight auto-off
         * and updates the UI display.
         * @returns {void}
         */
        init() {
          // Load saved settings
          this.loadSettings();

          // Get elements
          this.relayServerIP = document.getElementById("relayServerIP");
          this.relayServerPort = document.getElementById("relayServerPort");
          this.testRelayConnectionBtn = document.getElementById(
            "testRelayConnection",
          );
          this.relayStatus = document.getElementById("relayStatus");
          this.autoTriggerRelay = document.getElementById("autoTriggerRelay");
          this.testTimerRelayBtn = document.getElementById("testTimerRelay");
          this.testTimerSeconds = document.getElementById("testTimerSeconds");
          this.allRelaysOnBtn = document.getElementById("allRelaysOn");
          this.allRelaysOffBtn = document.getElementById("allRelaysOff");

          // Set initial values
          if (this.relayServerIP) this.relayServerIP.value = this.serverIP;
          if (this.relayServerPort)
            this.relayServerPort.value = this.serverPort;
          if (this.autoTriggerRelay)
            this.autoTriggerRelay.checked = this.autoTrigger;

          // Add event listeners for WiFi configuration (Pico 2 W)
          const connectWifiBtn = document.getElementById("connectWifi");
          if (connectWifiBtn) {
            connectWifiBtn.addEventListener("click", () => this.connectWifi());
          }

          // Force Hotspot Mode button
          const forceHotspotBtn = document.getElementById("forceHotspotMode");
          if (forceHotspotBtn) {
            forceHotspotBtn.addEventListener("click", () =>
              this.forceHotspotMode(),
            );
          }

          // Clear WiFi Credentials button
          const clearCredentialsBtn = document.getElementById(
            "clearWifiCredentials",
          );
          if (clearCredentialsBtn) {
            clearCredentialsBtn.addEventListener("click", () =>
              this.clearWifiCredentials(),
            );
          }

          // Load WiFi status on init
          this.updateWifiStatus();

          if (this.relayServerIP)
            this.relayServerIP.addEventListener("change", () =>
              this.saveSettings(),
            );
          if (this.relayServerPort)
            this.relayServerPort.addEventListener("change", () =>
              this.saveSettings(),
            );
          if (this.autoTriggerRelay)
            this.autoTriggerRelay.addEventListener("change", () =>
              this.saveSettings(),
            );
          if (this.testRelayConnectionBtn)
            this.testRelayConnectionBtn.addEventListener("click", () =>
              this.testConnection(),
            );
          if (this.testTimerRelayBtn)
            this.testTimerRelayBtn.addEventListener("click", () =>
              this.testTimerRelay(),
            );
          if (this.allRelaysOnBtn)
            this.allRelaysOnBtn.addEventListener("click", () =>
              this.allRelaysOn(),
            );
          if (this.allRelaysOffBtn)
            this.allRelaysOffBtn.addEventListener("click", () =>
              this.allRelaysOff(),
            );

          // Relay toggle buttons now use delegation - no init needed

          // Update UI
          this.updateRelayButtons();
          // Load safelight auto-off setting from settingsManager
          if (settingsManager) {
            this.safelightAutoOff =
              settingsManager.settings.safelightAutoOff !== false;
          }
          // Update safelight auto-off status display
          this.updateSafelightAutoOffStatus();

          // Add event listener for the toggle in settings
          document
            .getElementById("safelightAutoOff")
            ?.addEventListener("change", () => {
              this.safelightAutoOff =
                document.getElementById("safelightAutoOff").checked;
              this.saveSettings();
              this.updateSafelightAutoOffStatus();
            });
        }

        /**
         * @method shutdownPi
         * @description Initiates a graceful shutdown of the Raspberry Pi.
         * Sends a shutdown command to the server with user confirmation.
         * Provides visual feedback during the shutdown process.
         * @returns {Promise<void>} Resolves when shutdown command is sent (or fails)
         * @throws {Error} If shutdown command fails to send
         * @fires updateStatus - Updates UI with shutdown progress
         * @fires playBeep - Audio feedback on success
         * @example
         * await relayManager.connectWifi(); // Connects to configured WiFi
         */
        async connectWifi() {
          const ssidInput = document.getElementById("wifiSSID");
          const passwordInput = document.getElementById("wifiPassword");
          const statusElement = document.getElementById("wifiStatus");

          if (!ssidInput || !ssidInput.value.trim()) {
            if (statusElement)
              statusElement.textContent = "Please enter WiFi SSID";
            return;
          }

          const ssid = ssidInput.value.trim();
          const password = passwordInput ? passwordInput.value : "";

          if (statusElement) statusElement.textContent = "Connecting...";

          try {
            const response = await fetch(
              `http://${this.serverIP}:${this.serverPort}/wifi-config?ssid=${encodeURIComponent(ssid)}&password=${encodeURIComponent(password)}`,
              {
                method: "GET",
                mode: "cors",
                cache: "no-cache",
              },
            );

            if (response.ok) {
              const data = await response.json();
              if (data.status === "success") {
                if (statusElement) {
                  statusElement.textContent = `Connected! IP: ${data.ip || "pending"}`;
                  statusElement.style.color = "#0f0";
                }
                // Update server IP if we got a new one
                if (data.ip && data.ip !== "0.0.0.0") {
                  this.serverIP = data.ip;
                  if (this.relayServerIP) this.relayServerIP.value = data.ip;
                  this.saveSettings();
                }
              } else {
                if (statusElement) {
                  statusElement.textContent = `Failed: ${data.message || "Unknown error"}`;
                  statusElement.style.color = "#f00";
                }
              }
            } else {
              if (statusElement) {
                statusElement.textContent = "Connection failed";
                statusElement.style.color = "#f00";
              }
            }
          } catch (error) {
            console.error("WiFi connection error:", error);
            if (statusElement) {
              statusElement.textContent = "Request failed - check connection";
              statusElement.style.color = "#f00";
            }
          }
        }

        /**
         * @method updateWifiStatus
         * @description Queries the server for current WiFi connection status.
         * Updates the UI to show current connection mode and IP address.
         * @returns {Promise<void>}
         */
        async updateWifiStatus() {
          const statusElement = document.getElementById("wifiStatus");
          if (!statusElement) return;

          try {
            const response = await fetch(
              `http://${this.serverIP}:${this.serverPort}/wifi-status`,
              {
                method: "GET",
                mode: "cors",
                cache: "no-cache",
              },
            );

            if (response.ok) {
              const data = await response.json();
              if (data.sta_connected) {
                statusElement.textContent = `Connected: ${data.sta_ip} (${data.ssid || "WiFi"})`;
                statusElement.style.color = "#0f0";
              } else if (data.ap_active) {
                statusElement.textContent = `AP Mode: ${data.ap_ip}`;
                statusElement.style.color = "#ff0";
              } else {
                statusElement.textContent = "Disconnected";
                statusElement.style.color = "#f00";
              }
            }
          } catch (error) {
            // Silently fail on status check - might not be connected yet
            console.log("WiFi status check failed:", error);
          }
        }

        /**
         * @method forceHotspotMode
         * @description Forces the Pico to switch to AP (hotspot) mode.
         * Disconnects from any router WiFi and enables the access point.
         * @returns {Promise<void>}
         */
        async forceHotspotMode() {
          const statusElement = document.getElementById("wifiStatus");

          if (
            !confirm(
              "Switch to Hotspot mode? This will disconnect from the current WiFi network.",
            )
          ) {
            return;
          }

          if (statusElement) {
            statusElement.textContent = "Switching to Hotspot...";
            statusElement.style.color = "#ff0";
          }

          try {
            const response = await fetch(
              `http://${this.serverIP}:${this.serverPort}/wifi-ap-force`,
              {
                method: "GET",
                mode: "cors",
                cache: "no-cache",
              },
            );

            if (response.ok) {
              const data = await response.json();
              if (data.status === "success") {
                if (statusElement) {
                  statusElement.textContent = `Hotspot Mode: ${data.ap_ip || "192.168.4.1"}`;
                  statusElement.style.color = "#ff0";
                }
                // Update server IP to AP address
                this.serverIP = data.ap_ip || "192.168.4.1";
                if (this.relayServerIP)
                  this.relayServerIP.value = this.serverIP;
                this.saveSettings();

                alert(
                  `Switched to Hotspot mode!\nConnect to WiFi: DarkroomTimer\nPassword: darkroom123\nThen access: http://${this.serverIP}/`,
                );
              } else {
                if (statusElement) {
                  statusElement.textContent = `Failed: ${data.error || "Unknown error"}`;
                  statusElement.style.color = "#f00";
                }
              }
            } else {
              if (statusElement) {
                statusElement.textContent = "Switch failed";
                statusElement.style.color = "#f00";
              }
            }
          } catch (error) {
            console.error("Force hotspot error:", error);
            if (statusElement) {
              statusElement.textContent =
                "Request failed - may need to reconnect via hotspot";
              statusElement.style.color = "#f00";
            }
            // Provide instructions since connection likely dropped
            alert(
              "Connection lost. Connect to WiFi 'DarkroomTimer' (password: darkroom123) and access http://192.168.4.1/",
            );
          }
        }

        /**
         * @method clearWifiCredentials
         * @description Clears saved WiFi credentials from the Pico's storage.
         * After clearing, the Pico will only use hotspot mode on next boot.
         * @returns {Promise<void>}
         */
        async clearWifiCredentials() {
          const statusElement = document.getElementById("wifiStatus");

          if (
            !confirm(
              "Clear saved WiFi credentials? The Pico will start in Hotspot mode on next boot.",
            )
          ) {
            return;
          }

          try {
            const response = await fetch(
              `http://${this.serverIP}:${this.serverPort}/wifi-clear`,
              {
                method: "GET",
                mode: "cors",
                cache: "no-cache",
              },
            );

            if (response.ok) {
              const data = await response.json();
              if (data.status === "success") {
                if (statusElement) {
                  statusElement.textContent = "Credentials cleared";
                  statusElement.style.color = "#0f0";
                }
                // Clear the input fields
                const ssidInput = document.getElementById("wifiSSID");
                const passwordInput = document.getElementById("wifiPassword");
                if (ssidInput) ssidInput.value = "";
                if (passwordInput) passwordInput.value = "";

                alert(
                  "WiFi credentials cleared. The Pico will start in Hotspot mode on next reboot.",
                );
              } else {
                if (statusElement) {
                  statusElement.textContent = `Failed: ${data.error || "Unknown error"}`;
                  statusElement.style.color = "#f00";
                }
              }
            } else {
              if (statusElement) {
                statusElement.textContent = "Clear failed";
                statusElement.style.color = "#f00";
              }
            }
          } catch (error) {
            console.error("Clear credentials error:", error);
            if (statusElement) {
              statusElement.textContent = "Request failed";
              statusElement.style.color = "#f00";
            }
          }
        }

        /**
         * @method updateSafelightAutoOffStatus
         * @description Updates the visual display of safelight auto-off status in the UI.
         * Changes text content and color based on current setting and active theme.
         * @returns {void}
         * @fires document.getElementById - Updates "safelightAutoOffStatus" element
         * @theme-aware - Adapts colors for dark, light, and day schemes
         * @example
         * relayManager.updateSafelightAutoOffStatus(); // Updates UI display
         */
        updateSafelightAutoOffStatus() {
          const statusElement = document.getElementById(
            "safelightAutoOffStatus",
          );
          if (!statusElement) return;

          if (this.safelightAutoOff) {
            statusElement.textContent = "ENABLED";
            statusElement.style.color = "#f00";

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              statusElement.style.color = "#0066cc";
            } else if (document.body.classList.contains("day-scheme")) {
              statusElement.style.color = "#ffcc00";
            }
          } else {
            statusElement.textContent = "DISABLED";
            statusElement.style.color = "#900";

            // Theme adjustments
            if (document.body.classList.contains("light-scheme")) {
              statusElement.style.color = "#666";
            } else if (document.body.classList.contains("day-scheme")) {
              statusElement.style.color = "#ccc";
            }
          }
        }

        // initRelayToggleButtons removed - now using event delegation

        /**
         * @method saveSettings
         * @description Saves current relay manager settings to localStorage.
         * Reads values from UI elements and persists server configuration,
         * auto-trigger preference, and safelight auto-off setting.
         * @returns {void}
         * @fires localStorage.setItem - Saves "relaySettings" key
         * @throws {Error} Logs error if localStorage save fails
         * @example
         * relayManager.saveSettings(); // Persists current configuration
         */
        saveSettings() {
          this.serverIP = this.relayServerIP
            ? this.relayServerIP.value
            : "192.168.1.100";
          this.serverPort = this.relayServerPort
            ? parseInt(this.relayServerPort.value)
            : 5000;
          this.autoTrigger = this.autoTriggerRelay
            ? this.autoTriggerRelay.checked
            : true;

          // NEW: Get safelight auto-off setting
          this.safelightAutoOff = document.getElementById("safelightAutoOff")
            ? document.getElementById("safelightAutoOff").checked
            : true;

          try {
            localStorage.setItem(
              "relaySettings",
              JSON.stringify({
                serverIP: this.serverIP,
                serverPort: this.serverPort,
                autoTrigger: this.autoTrigger,
                safelightAutoOff: this.safelightAutoOff, // NEW
              }),
            );
          } catch (e) {
            console.error("Failed to save relay settings:", e);
          }
        }

        /**
         * @method loadSettings
         * @description Loads relay manager settings from localStorage.
         * Restores server configuration, auto-trigger preference, safelight auto-off setting,
         * and relay states. Uses default values if no saved settings exist.
         * @returns {void}
         * @fires localStorage.getItem - Retrieves "relaySettings" and "relayStates" keys
         * @throws {Error} Logs error if localStorage load or parse fails
         * @example
         * relayManager.loadSettings(); // Restores saved configuration
         */
        loadSettings() {
          try {
            const saved = localStorage.getItem("relaySettings");
            if (saved) {
              const settings = JSON.parse(saved);
              // Always use current page location for IP - ensures correct server in AP/STA modes
              // Only fall back to saved IP if page was opened from file:// or other non-HTTP source
              this.serverIP =
                window.location.hostname || settings.serverIP || "192.168.4.1";
              this.serverPort =
                parseInt(window.location.port) || settings.serverPort || 80;
              this.autoTrigger = settings.autoTrigger !== false;
              this.safelightAutoOff = settings.safelightAutoOff !== false;

              // Load relay states
              const savedStates = localStorage.getItem("relayStates");
              if (savedStates) {
                this.relayStates = JSON.parse(savedStates);
              }
            }
          } catch (e) {
            console.error("Failed to load relay settings:", e);
          }
        }

        /**
         * @method sendRequest
         * @description Sends an HTTP GET request to the Flask server with triple-fallback strategy.
         * Tries CORS mode first, then no-cors mode, then Image object for maximum compatibility.
         * @param {string} endpoint - The server endpoint to request (e.g., "ping", "relay", "timer")
         * @param {Object} [params={}] - Query parameters to include in the request
         * @returns {Promise<boolean>} Resolves to true if request succeeds, false otherwise
         * @throws {Error} May throw if CORS request fails with non-200 status
         * @description Triple-Fallback Strategy:
         * 1. CORS mode (Chrome/Safari) - preferred, allows reading response
         * 2. no-cors mode - fallback for restricted environments, can't read response
         * 3. Image object - final fallback for GET requests, no CORS requirements
         * @example
         * // Test connection
         * const success = await relayManager.sendRequest("ping");
         *
         * // Control relay
         * await relayManager.sendRequest("relay", { gpio: 25, state: "on" });
         *
         * // Start timer
         * await relayManager.sendRequest("timer", { gpio: 25, duration: 10.5 });
         */
        async sendRequest(endpoint, params = {}) {
          const url = `http://${this.serverIP}:${this.serverPort}/${endpoint}`;
          const queryString = Object.keys(params)
            .map(
              (key) =>
                `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`,
            )
            .join("&");

          const fullUrl = queryString ? `${url}?${queryString}` : url;

          try {
            // Try with CORS first (for Chrome/Safari)
            const response = await fetch(fullUrl, {
              method: "GET",
              mode: "cors",
              cache: "no-cache",
              headers: {
                Accept: "application/json",
              },
            });

            if (response.ok) {
              return true;
            } else {
              throw new Error(`HTTP ${response.status}`);
            }
          } catch (error) {
            console.warn(
              "CORS fetch failed, trying alternative methods:",
              error,
            );

            // Fallback 1: Try with no-cors mode
            try {
              await fetch(fullUrl, {
                method: "GET",
                mode: "no-cors",
                cache: "no-cache",
              });
              return true; // Assume success (we can't read response in no-cors mode)
            } catch (noCorsError) {
              console.warn("No-cors fetch failed:", noCorsError);

              // Fallback 2: Use Image object (works for GET requests, no CORS)
              return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);

                // Add cache-busting parameter
                const cacheBuster = `&_=${Date.now()}`;
                img.src =
                  fullUrl +
                  (fullUrl.includes("?") ? cacheBuster : "?" + cacheBuster);

                // Timeout after 3 seconds
                setTimeout(() => resolve(false), 3000);
              });
            }
          }
        }
        /**
         * @method handleSafelightAutoOff
         * @description Implements the safelight auto-off feature to prevent fogging during exposures.
         * Automatically turns off safelight when enlarger activates and restores it after exposure.
         * This is the core method that implements the critical safelight protection flow.
         * @param {number} relayNum - The relay number being controlled (1-4)
         * @param {boolean} newState - The intended new state of the relay (true=ON, false=OFF)
         * @returns {Promise<void>} Resolves when safelight control operations complete
         * @description Safelight Auto-Off Flow:
         * 1. If enlarger (relay 1) is turning ON:
         *    - Check if safelight (relay 2) is currently ON
         *    - If yes, remember state and turn safelight OFF
         * 2. If enlarger (relay 1) is turning OFF:
         *    - Check if safelight was previously turned off by this system
         *    - If yes, immediately restore safelight to previous state
         * @fires setRelay - Controls safelight relay (2) when needed
         * @fires setTimeout - Restores safelight immediately
         * @example
         * // Called automatically by setRelay and toggleRelay methods
         * await relayManager.handleSafelightAutoOff(1, true); // Enlarger turning on
         */
        async handleSafelightAutoOff(relayNum, newState) {
          // If safelight auto-off is disabled, do nothing
          if (!this.safelightAutoOff) return;

          // If enlarger (relay 1) is being turned ON
          if (relayNum === 1 && newState === true) {
            // Check if safelight (relay 2) is currently on
            if (this.relayStates[2]) {
              // Remember that safelight was on
              this.safelightWasOn = true;
              console.log(
                "Safelight was on, turning it off because enlarger is on",
              );

              // Turn off safelight
              await this.setRelay(2, false);
            } else {
              this.safelightWasOn = false;
            }
          }
          // If enlarger (relay 1) is being turned OFF
          else if (relayNum === 1 && newState === false) {
            // Check if we previously turned off the safelight
            if (this.safelightWasOn) {
              console.log("Enlarger turned off, restoring safelight");

              // Restore safelight immediately
              setTimeout(async () => {
                // Only restore if user hasn't manually turned it back on
                if (!this.relayStates[2]) {
                  await this.setRelay(2, true);
                }
                this.safelightWasOn = false;
              }, 0); // Immediate restoration
            }
          }
        }

        /**
         * @method toggleRelay
         * @description Toggles a specific relay between ON and OFF states.
         * Handles safelight auto-off logic before toggling, sends request to server,
         * updates local state, and provides audio/visual feedback.
         * @param {number} relayNum - The relay number to toggle (1-4)
         * @returns {Promise<void>} Resolves when toggle operation completes
         * @throws {Error} Logs error if server request fails
         * @fires handleSafelightAutoOff - Processes safelight protection before toggle
         * @fires sendRequest - Sends relay control command to server
         * @fires localStorage.setItem - Updates relay state persistence
         * @fires updateRelayButtons - Updates UI button states
         * @fires updateStatus - Updates status display
         * @fires playBeep - Audio feedback (800Hz for ON, 400Hz for OFF)
         * @example
         * // Toggle enlarger relay (relay 1)
         * await relayManager.toggleRelay(1);
         *
         * // Toggle safelight relay (relay 2)
         * await relayManager.toggleRelay(2);
         */
        async toggleRelay(relayNum) {
          const newState = !this.relayStates[relayNum];
          const gpioPin = this.getGPIOPin(relayNum);

          // Handle safelight auto-off logic BEFORE toggling
          await this.handleSafelightAutoOff(relayNum, newState);

          const success = await this.sendRequest("relay", {
            gpio: gpioPin,
            state: newState ? "on" : "off",
          });

          if (success) {
            this.relayStates[relayNum] = newState;
            localStorage.setItem(
              "relayStates",
              JSON.stringify(this.relayStates),
            );
            this.updateRelayButtons();
            this.updateStatus(
              `Relay ${relayNum} ${newState ? "ON" : "OFF"}`,
              "success",
            );
            playBeep(newState ? 800 : 400, 0.1, 0.3);
          }
        }

        /**
         * @method setRelay
         * @description Sets a specific relay to a specific state (ON/OFF).
         * Handles safelight auto-off logic, sends request to server, and updates local state.
         * Unlike toggleRelay, this method sets an explicit state rather than toggling.
         * @param {number} relayNum - The relay number to control (1-4)
         * @param {boolean} state - The desired state (true=ON, false=OFF)
         * @returns {Promise<void>} Resolves when set operation completes
         * @throws {Error} Logs error if server request fails
         * @fires handleSafelightAutoOff - Processes safelight protection before setting
         * @fires sendRequest - Sends relay control command to server
         * @fires localStorage.setItem - Updates relay state persistence
         * @fires updateRelayButtons - Updates UI button states
         * @example
         * // Turn on enlarger
         * await relayManager.setRelay(1, true);
         *
         * // Turn off safelight
         * await relayManager.setRelay(2, false);
         *
         * // Turn on ventilation
         * await relayManager.setRelay(3, true);
         */
        async setRelay(relayNum, state) {
          const gpioPin = this.getGPIOPin(relayNum);
          const stateStr = state ? "on" : "off";

          // Handle safelight auto-off logic
          await this.handleSafelightAutoOff(relayNum, state);

          const success = await this.sendRequest("relay", {
            gpio: gpioPin,
            state: stateStr,
          });

          if (success) {
            this.relayStates[relayNum] = state;
            localStorage.setItem(
              "relayStates",
              JSON.stringify(this.relayStates),
            );
            this.updateRelayButtons();
          }
        }

        /**
         * @method getGPIOPin
         * @description Maps relay numbers to their corresponding GPIO pin numbers.
         * Provides the hardware pin mapping for relay control.
         * @param {number} relayNum - The relay number (1-4)
         * @returns {number} The GPIO pin number for the specified relay
         * @constant {Object} pinMap - Static mapping of relay to GPIO pins
         * @example
         * const pin = relayManager.getGPIOPin(1); // Returns 14 (Enlarger)
         * const pin = relayManager.getGPIOPin(2); // Returns 15 (Safelight)
         */
        getGPIOPin(relayNum) {
          const pinMap = {
            1: 14, // Enlarger Timer (GP14)
            2: 15, // Safelight (GP15)
            3: 16, // Ventilation (GP16)
            4: 17, // White Light (GP17)
          };
          return pinMap[relayNum] || 14;
        }

        /**
         * @method triggerTimerRelay
         * @description Triggers the enlarger relay with a timed duration.
         * This is the primary method used by CALC, TEST, and TIMER tabs for exposures.
         * Implements the complete safelight auto-off flow with immediate restoration.
         * @param {number} durationSeconds - The exposure duration in seconds
         * @returns {Promise<void>} Resolves when timer trigger completes
         * @throws {Error} Logs error if timer request fails
         * @fires console.log - Logs safelight state changes for debugging
         * @fires sendRequest - Sends timer command to server (gpio=25, duration=durationSeconds)
         * @fires updateStatus - Updates UI with timer status
         * @fires setTimeout - Schedules safelight restoration after exposure
         * @fires setRelay - Controls safelight (relay 2) before and after exposure
         * @description Critical Safelight Flow:
         * 1. Check if auto-trigger is enabled (required for this method)
         * 2. If safelight auto-off is enabled and safelight is on:
         *    - Remember safelight was on
         *    - Turn off safelight (relay 2)
         * 3. Send timer request to server (gpio=25, duration=durationSeconds)
         * 4. After duration:
         *    - Restore safelight if it was on
         *    - Reset safelightWasOn flag
         * @example
         * // From CALC tab with 10.5 second exposure
         * await relayManager.triggerTimerRelay(10.5);
         *
         * // From TEST tab with 2.5 second step
         * await relayManager.triggerTimerRelay(2.5);
         *
         * // From TIMER tab (Dev timer)
         * await relayManager.triggerTimerRelay(60.0);
         */
        async triggerTimerRelay(durationSeconds) {
          if (!this.autoTrigger) {
            console.log("Auto-trigger disabled");
            return;
          }

          // NEW: Handle safelight auto-off when timer starts
          if (this.safelightAutoOff && this.relayStates[2]) {
            console.log("Timer starting - turning off safelight");
            this.safelightWasOn = true;
            await this.setRelay(2, false);
          }

          // Send single request with duration parameter
          const success = await this.sendRequest("timer", {
            gpio: 14,
            duration: durationSeconds.toFixed(3),
          });

          if (success) {
            this.updateStatus(
              `Timer relay triggered for ${durationSeconds}s`,
              "success",
            );

            // NEW: Restore safelight after timer completes
            if (this.safelightAutoOff && this.safelightWasOn) {
              setTimeout(async () => {
                console.log("Timer completed - restoring safelight");
                if (!this.relayStates[2]) {
                  await this.setRelay(2, true);
                }
                this.safelightWasOn = false;
              }, durationSeconds * 1000); // Immediate restoration
            }
          } else {
            this.updateStatus("Timer relay failed", "error");
          }
        }

        /**
         * @method testConnection
         * @description Tests the connection to the Flask server.
         * Sends a ping request to verify server is reachable and responsive.
         * Provides audio and visual feedback based on connection result.
         * @returns {Promise<void>} Resolves when connection test completes
         * @fires updateStatus - Updates UI with connection status
         * @fires sendRequest - Sends "ping" request to server
         * @fires playBeep - Audio feedback (600Hz for success)
         * @example
         * // Test connection before starting exposure
         * await relayManager.testConnection();
         */
        async testConnection() {
          this.updateStatus("Testing connection...", "info");

          // Try to ping the server
          const success = await this.sendRequest("ping");

          if (success) {
            this.updateStatus("Connected successfully!", "success");
            playBeep(600, 0.3, 0.3);
          } else {
            this.updateStatus("Connection failed", "error");
          }
        }

        /**
         * @method testTimerRelay
         * @description Tests the timer relay functionality with a user-specified duration.
         * Reads duration from UI input and triggers the enlarger with safelight handling.
         * Useful for testing exposure timing and safelight auto-off feature.
         * @returns {Promise<void>} Resolves when test timer completes
         * @fires parseFloat - Reads duration from testTimerSeconds input element
         * @fires triggerTimerRelay - Starts exposure with specified duration
         * @example
         * // User clicks "Test Timer Relay" button
         * // Reads value from testTimerSeconds input (default: 5 seconds)
         * await relayManager.testTimerRelay();
         */
        async testTimerRelay() {
          const seconds = parseFloat(
            this.testTimerSeconds ? this.testTimerSeconds.value : 5,
          );
          if (seconds > 0) {
            await this.triggerTimerRelay(seconds);
          }
        }

        /**
         * @method allRelaysOn
         * @description Turns ON all relays simultaneously.
         * Respects safelight auto-off setting: if enabled and enlarger is on,
         * safelight will not be turned on to prevent fogging.
         * @returns {Promise<void>} Resolves when all relays are turned on
         * @fires setRelay - Controls each relay individually
         * @fires updateStatus - Updates UI with success message
         * @fires playBeep - Audio feedback (800Hz, 0.5s duration)
         * @example
         * // Turn on all relays (respecting safelight auto-off)
         * await relayManager.allRelaysOn();
         */
        async allRelaysOn() {
          // If safelight auto-off is enabled and we're turning on enlarger,
          // we should handle safelight appropriately
          if (this.safelightAutoOff) {
            // Turn on all relays except safelight if enlarger is being turned on
            for (let i = 1; i <= 4; i++) {
              if (i === 2 && this.relayStates[1]) {
                // Skip turning on safelight if enlarger is already on or about to be on
                continue;
              }
              await this.setRelay(i, true);
            }
          } else {
            // Original behavior
            for (let i = 1; i <= 4; i++) {
              await this.setRelay(i, true);
            }
          }

          this.updateStatus("All relays ON", "success");
          playBeep(800, 0.5, 0.3);
        }

        /**
         * @method allRelaysOff
         * @description Turns OFF all relays simultaneously.
         * Resets the safelightWasOn flag to prevent unexpected safelight restoration.
         * @returns {Promise<void>} Resolves when all relays are turned off
         * @fires setRelay - Controls each relay individually
         * @fires updateStatus - Updates UI with success message
         * @fires playBeep - Audio feedback (400Hz, 0.5s duration)
         * @example
         * // Turn off all relays
         * await relayManager.allRelaysOff();
         */
        async allRelaysOff() {
          for (let i = 1; i <= 4; i++) {
            await this.setRelay(i, false);
          }
          this.safelightWasOn = false; // Reset the flag
          this.updateStatus("All relays OFF", "success");
          playBeep(400, 0.5, 0.3);
        }

        /**
         * @method updateRelayButtons
         * @description Updates all relay control buttons in the UI to reflect current states.
         * Changes button text (ON/OFF) and CSS classes based on relayStates.
         * @returns {void}
         * @fires document.querySelectorAll - Finds all relay control buttons
         * @fires Element.textContent - Updates button text
         * @fires Element.classList.toggle - Updates CSS classes
         * @example
         * // Called after any relay state change
         * relayManager.updateRelayButtons();
         */
        updateRelayButtons() {
          document
            .querySelectorAll(".settings-btn[data-relay]")
            .forEach((btn) => {
              const relayNum = parseInt(btn.getAttribute("data-relay"));
              const state = this.relayStates[relayNum];

              btn.textContent = state ? "ON" : "OFF";
              btn.classList.toggle("on", state);
            });
        }

        /**
         * @method updateStatus
         * @description Updates the relay status display element with a message and color.
         * Theme-aware: adapts colors for dark, light, and day schemes.
         * @param {string} message - The status message to display
         * @param {string} [type="info"] - Message type: "success", "error", or "info"
         * @returns {void}
         * @fires Element.textContent - Updates status text
         * @fires Element.style.color - Updates text color based on type and theme
         * @theme-aware - Uses different colors for each theme scheme
         * @example
         * // Success message
         * relayManager.updateStatus("Connected successfully!", "success");
         *
         * // Error message
         * relayManager.updateStatus("Connection failed", "error");
         *
         * // Info message
         * relayManager.updateStatus("Testing connection...", "info");
         */
        updateStatus(message, type = "info") {
          if (!this.relayStatus) return;

          this.relayStatus.textContent = message;

          // Set color based on type and theme
          if (document.body.classList.contains("light-scheme")) {
            this.relayStatus.style.color =
              type === "success"
                ? "#006600"
                : type === "error"
                  ? "#cc0000"
                  : "#666";
          } else if (document.body.classList.contains("day-scheme")) {
            this.relayStatus.style.color =
              type === "success"
                ? "#33cc33"
                : type === "error"
                  ? "#ff3333"
                  : "#ccc";
          } else {
            const colors = {
              success: "#0a0",
              error: "#f00",
              info: "#900",
            };
            this.relayStatus.style.color = colors[type] || "#900";
          }
        }
      }

      // Load settings to UI - UPDATED with countdown settings AND auto advance
      function loadSettingsToUI() {
        if (!settingsManager) return;

        document.getElementById("settingBaseTime").value =
          settingsManager.settings.baseTime;
        document.getElementById("settingDevTime").value =
          settingsManager.settings.devTime;
        document.getElementById("settingStopTime").value =
          settingsManager.settings.stopTime;
        document.getElementById("settingFixTime").value =
          settingsManager.settings.fixTime;
        document.getElementById("settingFloTime").value =
          settingsManager.settings.floTime;
        document.getElementById("settingCalcWarningBeep").checked =
          settingsManager.settings.calcWarningBeep;
        document.getElementById("settingCalcEndBeep").checked =
          settingsManager.settings.calcEndBeep;
        document.getElementById("settingTimerWarningBeep").checked =
          settingsManager.settings.timerWarningBeep;
        document.getElementById("settingTimerEndBeep").checked =
          settingsManager.settings.timerEndBeep;

        // Countdown settings
        document.getElementById("settingCountdownDelay").value =
          settingsManager.settings.countdownDelay;
        document.getElementById("settingCountdownBeep").checked =
          settingsManager.settings.countdownBeep;
        document.getElementById("settingCountdownPattern").value =
          settingsManager.settings.countdownPattern || "every-second"; // NEW

        // NEW: Auto advance setting
        document.getElementById("settingAutoAdvance").checked =
          settingsManager.settings.autoAdvance;

        // Apply auto advance to F-Stop Test generator
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.setAutoAdvance(
            settingsManager.settings.autoAdvance,
          );
        }
        document.getElementById("settingAutoAdvanceDelay").value =
          settingsManager.settings.autoAdvanceDelay || 1;

        // Apply auto advance to F-Stop Test generator
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.setAutoAdvance(
            settingsManager.settings.autoAdvance,
          );
          window.fstopTestGenerator.setAutoAdvanceDelay(
            (settingsManager.settings.autoAdvanceDelay || 1) * 1000,
          );
        }

        // Load base time slider limits
        const baseTimeMinInput = document.getElementById("baseTimeMin");
        const baseTimeMaxInput = document.getElementById("baseTimeMax");
        if (baseTimeMinInput) {
          baseTimeMinInput.value = settingsManager.settings.baseTimeMin || 0.4;
        }
        if (baseTimeMaxInput) {
          baseTimeMaxInput.value = settingsManager.settings.baseTimeMax || 50;
        }

        // Apply limits to BASE TIME slider
        const baseTimeSlider = document.getElementById("baseTimeSlider");
        if (baseTimeSlider) {
          baseTimeSlider.min = settingsManager.settings.baseTimeMin || 0.4;
          baseTimeSlider.max = settingsManager.settings.baseTimeMax || 50;
        }

        // Load test base time slider limits
        const testBaseTimeMinInput = document.getElementById("testBaseTimeMin");
        const testBaseTimeMaxInput = document.getElementById("testBaseTimeMax");
        if (testBaseTimeMinInput) {
          testBaseTimeMinInput.value =
            settingsManager.settings.testBaseTimeMin || 1;
        }
        if (testBaseTimeMaxInput) {
          testBaseTimeMaxInput.value =
            settingsManager.settings.testBaseTimeMax || 50;
        }

        // Apply limits to TEST BASE TIME slider
        const testBaseSlider = document.getElementById("testBaseSlider");
        if (testBaseSlider) {
          testBaseSlider.min = settingsManager.settings.testBaseTimeMin || 1;
          testBaseSlider.max = settingsManager.settings.testBaseTimeMax || 50;
        }

        // F-stop increment denominator (persisted setting)
        const savedDenom = settingsManager.settings.stopDenominator || 3;
        const cSeg = document.getElementById("calcIncrementSeg");
        const tSeg = document.getElementById("testIncrementSeg");
        if (cSeg) {
          Array.from(cSeg.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === savedDenom;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        if (tSeg) {
          Array.from(tSeg.querySelectorAll(".segmented-btn")).forEach((b) => {
            const bd = parseInt(b.dataset.denom, 10);
            const active = bd === savedDenom;
            b.classList.toggle("active", active);
            b.setAttribute("aria-pressed", active ? "true" : "false");
          });
        }
        const oldC = document.getElementById("calcIncrementDenom");
        if (oldC) oldC.value = savedDenom;
        const oldT = document.getElementById("testIncrementDenom");
        if (oldT) oldT.value = savedDenom;
        const settingsSel = document.getElementById("settingStopIncrement");
        if (settingsSel) settingsSel.value = savedDenom;
        window.stopDenominator = savedDenom;

        // Apply base time to calculator and test generator (on load)
        (function applyLoadedBaseAndTimerDefaults() {
          const newBase = parseFloat(
            settingsManager.settings.baseTime || DEFAULT_SETTINGS.baseTime,
          );
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            baseSlider.value = newBase;
            baseSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }
          const testBase = document.getElementById("testBaseSlider");
          if (testBase) {
            testBase.value = newBase;
            testBase.dispatchEvent(new Event("input", { bubbles: true }));
          }

          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = newBase;
            window.incrementalTimer.updateCalculations();
            window.incrementalTimer.updateAllDisplays();
          }

          if (window.fstopTestGenerator) {
            window.fstopTestGenerator.baseTime = newBase;
            if (window.fstopTestGenerator.testBaseSlider) {
              window.fstopTestGenerator.testBaseSlider.value = newBase;
            }
            window.fstopTestGenerator.generateSteps();
            window.fstopTestGenerator.updateDisplay();
          }

          // Apply saved default timer values
          const mapping = {
            Dev: parseInt(settingsManager.settings.devTime, 10),
            Stop: parseInt(settingsManager.settings.stopTime, 10),
            Fix: parseInt(settingsManager.settings.fixTime, 10),
            Flo: parseInt(settingsManager.settings.floTime, 10),
          };

          // Update DEFAULT_TIMER_TIMES so future timers use these defaults
          Object.keys(mapping).forEach((k) => {
            if (typeof mapping[k] === "number" && !isNaN(mapping[k])) {
              DEFAULT_TIMER_TIMES[k] = mapping[k];
            }
          });

          // Update any existing timers
          if (timerManager && timerManager.timers) {
            timerManager.timers.forEach((timer) => {
              const newTime = mapping[timer.name];
              if (typeof newTime === "number" && !isNaN(newTime)) {
                const roundedTime = Math.round(newTime);
                if (!timer.isRunning) {
                  timer.setTime(roundedTime);
                } else {
                  timer.totalTime = roundedTime;
                  timer.timeLeft = roundedTime;
                  timer.warningPlayed = false;
                  timer.updateDisplay();
                  timer.updateButtonStates();
                }
              }
            });
          }
        })();

        // NEW: Transfer destination setting for test strips
        if (window.fstopTestGenerator) {
          const destination =
            settingsManager.settings.testTransferDestination || "calc";
          window.fstopTestGenerator.setTransferDestination(destination);
        }

        // NEW: Safelight auto-off setting
        document.getElementById("safelightAutoOff").checked =
          settingsManager.settings.safelightAutoOff !== false; // Default to true

        // Virtual proof stability settings
        const stabilityEnabled =
          settingsManager.settings.proofStabilityEnabled !== false;
        const stabilityBeep =
          settingsManager.settings.proofStabilityBeep !== false;
        const stabilityTolerance =
          settingsManager.settings.proofStabilityTolerance ??
          DEFAULT_SETTINGS.proofStabilityTolerance;
        const stabilityMinStable =
          settingsManager.settings.proofStabilityMinStable ??
          DEFAULT_SETTINGS.proofStabilityMinStable;
        const stabilityMaxWait =
          settingsManager.settings.proofStabilityMaxWait ??
          DEFAULT_SETTINGS.proofStabilityMaxWait;
        const stabilityMinDelta =
          settingsManager.settings.proofStabilityMinDelta ??
          DEFAULT_SETTINGS.proofStabilityMinDelta;

        const proofEnabledEl = document.getElementById(
          "proofStabilityEnabled",
        );
        if (proofEnabledEl) proofEnabledEl.checked = stabilityEnabled;
        const proofBeepEl = document.getElementById("proofStabilityBeep");
        if (proofBeepEl) proofBeepEl.checked = stabilityBeep;
        const proofToleranceEl = document.getElementById(
          "proofStabilityTolerance",
        );
        if (proofToleranceEl) proofToleranceEl.value = stabilityTolerance;
        const proofMinStableEl = document.getElementById(
          "proofStabilityMinStable",
        );
        if (proofMinStableEl) proofMinStableEl.value = stabilityMinStable;
        const proofMaxWaitEl = document.getElementById("proofStabilityMaxWait");
        if (proofMaxWaitEl) proofMaxWaitEl.value = stabilityMaxWait;
        const proofMinDeltaEl = document.getElementById("proofStabilityMinDelta");
        if (proofMinDeltaEl) proofMinDeltaEl.value = stabilityMinDelta;

        if (window.lightMeterManager) {
          const stability = window.lightMeterManager.proof.stability;
          stability.enabled = stabilityEnabled;
          stability.beepOnStable = stabilityBeep;
          stability.tolerancePct = parseFloat(stabilityTolerance) ||
            DEFAULT_SETTINGS.proofStabilityTolerance;
          stability.minStableCount = parseInt(stabilityMinStable, 10) ||
            DEFAULT_SETTINGS.proofStabilityMinStable;
          stability.maxWaitMs = parseInt(stabilityMaxWait, 10) ||
            DEFAULT_SETTINGS.proofStabilityMaxWait;
          stability.minDeltaLux = parseFloat(stabilityMinDelta) ||
            DEFAULT_SETTINGS.proofStabilityMinDelta;
        }
      }

      // Timer Manager
      timerManager = {
        timers: [],
        init: function () {
          // Create timers
          this.timers = [
            new Timer("Dev"),
            new Timer("Stop"),
            new Timer("Fix"),
            new Timer("Flo"),
          ];

          // Apply settings if available
          if (settingsManager) {
            // Apply saved profile if exists
            if (appState.persistent.currentProfile) {
              const profile = settingsManager.profiles.find(
                (p) => p.name === appState.persistent.currentProfile,
              );
              if (profile && profile.times) {
                this.timers.forEach((timer) => {
                  if (profile.times[timer.name] !== undefined) {
                    timer.setTime(profile.times[timer.name]);
                  }
                });
              }
            }
          }

          // Start All button - NEW: Start/Pause/Resume with countdown integration
          window.startAllState = {
            isCountdown: false,
            isRunning: false,
            isPaused: false,
            countdownResolve: null,
            firstTimer: null,
            originalDisplayText: null,
          };

          const updateStartAllButton = () => {
            const btn = document.getElementById("startAll");
            if (!btn) return;

            if (window.startAllState.isCountdown) {
              btn.textContent = "Cancel";
              btn.disabled = false;
            } else if (window.startAllState.isRunning) {
              btn.textContent = "Pause";
              btn.disabled = false;
            } else if (window.startAllState.isPaused) {
              btn.textContent = "Resume";
              btn.disabled = false;
            } else {
              btn.textContent = "Start All";
              btn.disabled = false;
            }
          };

          document
            .getElementById("startAll")
            .addEventListener("click", async () => {
              const firstEnabledTimer = this.timers.find(
                (t) => t.state.isEnabled,
              );
              if (!firstEnabledTimer) return;

              // CANCEL countdown
              if (window.startAllState.isCountdown) {
                if (window.startAllState.countdownResolve) {
                  window.startAllState.countdownResolve("cancelled");
                  // Also cancel the countdown manager to stop the timer
                  if (window.countdownManager) {
                    window.countdownManager.cancel();
                  }
                }
                return;
              }

              // PAUSE running sequence
              if (window.startAllState.isRunning) {
                // Stop all timers in the sequence
                this.timers.forEach((timer) => {
                  if (timer.state.isRunning) {
                    timer.stop();
                  }
                });
                window.startAllState.isRunning = false;
                window.startAllState.isPaused = true;
                updateStartAllButton();
                return;
              }

              // RESUME paused sequence
              if (window.startAllState.isPaused) {
                // Find the first timer that has time left and resume it
                const timerToResume = this.timers.find(
                  (t) =>
                    t.state.isEnabled &&
                    t.state.timeLeft > 0 &&
                    !t.state.isRunning,
                );
                if (timerToResume) {
                  // Log timer start and end current session
                  if (window.exposureLogManager) {
                    const timerData = {
                      dev: appState.timers.Dev.timeLeft,
                      stop: appState.timers.Stop.timeLeft,
                      fix: appState.timers.Fix.timeLeft,
                      flo: appState.timers.Flo.timeLeft,
                    };
                    window.exposureLogManager.addTimerPhaseAndEnd(timerData);
                  }

                  window.startAllState.isPaused = false;
                  window.startAllState.isRunning = true;
                  timerToResume.start(true); // Start as sequence
                  updateStartAllButton();
                }
                return;
              }

              // START NEW SEQUENCE
              // Start countdown on first timer's display
              const display = document.getElementById(
                `display${firstEnabledTimer.name}`,
              );
              window.startAllState.originalDisplayText = display.textContent;
              window.startAllState.firstTimer = firstEnabledTimer;
              window.startAllState.isCountdown = true;
              window.startAllState.isRunning = false;
              window.startAllState.isPaused = false;

              // Update button states during countdown
              updateStartAllButton();
              document.getElementById("resetAll").disabled = false; // Keep reset enabled

              const countdownResult = await new Promise((resolve) => {
                window.startAllState.countdownResolve = resolve;
                window.countdownManager.startCountdown(display, () => {
                  resolve("complete");
                });
              });

              // Restore display
              display.textContent = window.startAllState.originalDisplayText;
              window.startAllState.countdownResolve = null;
              window.startAllState.isCountdown = false;

              if (countdownResult === "cancelled") {
                updateStartAllButton();
                return;
              }

              // Log timer start and end current session
              if (window.exposureLogManager) {
                const timerData = {
                  dev: appState.timers.Dev.timeLeft,
                  stop: appState.timers.Stop.timeLeft,
                  fix: appState.timers.Fix.timeLeft,
                  flo: appState.timers.Flo.timeLeft,
                };
                window.exposureLogManager.addTimerPhaseAndEnd(timerData);
              }

              // Start the timer as part of a sequence
              window.startAllState.isRunning = true;
              firstEnabledTimer.reset();
              firstEnabledTimer.start(true);
              updateStartAllButton();
            });

          // Reset All button - NEW: Stop/Reset functionality
          document.getElementById("resetAll").addEventListener("click", () => {
            // If countdown is running, cancel it
            if (
              window.startAllState.isCountdown &&
              window.startAllState.countdownResolve
            ) {
              window.startAllState.countdownResolve("cancelled");
              // Also cancel the countdown manager to stop the timer
              if (window.countdownManager) {
                window.countdownManager.cancel();
              }
              // The click handler will handle cleanup
              return;
            }

            // Stop all running timers
            this.timers.forEach((timer) => {
              if (timer.state.isRunning) {
                timer.stop();
              }
              // Reset all enabled timers
              if (timer.state.isEnabled) {
                timer.reset();
              }
            });

            // Reset start all state
            window.startAllState.isCountdown = false;
            window.startAllState.isRunning = false;
            window.startAllState.isPaused = false;
            window.startAllState.countdownResolve = null;
            updateStartAllButton();
          });

          // Audio context init is now in centralized delegation
        },
      };

      // Calculator functions
      const baseTimeSlider = document.getElementById("baseTimeSlider");
      const stopSlider = document.getElementById("stopSlider");
      const chartBaseSlider = document.getElementById("chartBaseSlider");

      /**
       * @function formatStop
       * @description Formats a stop value as a human-readable string with fractions.
       * Supports denominators 2, 3, 4, 6 with Unicode fraction characters.
       * @param {number} value - Stop value (in fractional steps)
       * @returns {string} Formatted stop string (e.g., "1⅓", "2½", "-3.0")
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * formatStop(4); // Returns "1⅓" if denominator is 3
       */
      function formatStop(value) {
        const denom = window.stopDenominator || 3;
        const val = value / denom; // actual stops
        const sign = val < 0 ? "-" : "";
        const absVal = Math.abs(val);
        const whole = Math.floor(absVal);
        const frac = absVal - whole;
        const tol = 1e-6;

        if (Math.abs(frac) < tol) return `${sign}${whole}.0`;

        if (denom === 2) {
          if (Math.abs(frac - 0.5) < tol) return `${sign}${whole}½`;
        } else if (denom === 3) {
          if (Math.abs(frac - 1 / 3) < tol) return `${sign}${whole}⅓`;
          if (Math.abs(frac - 2 / 3) < tol) return `${sign}${whole}⅔`;
        } else if (denom === 4) {
          if (Math.abs(frac - 0.25) < tol) return `${sign}${whole}¹⁄₄`;
          if (Math.abs(frac - 0.5) < tol) return `${sign}${whole}²⁄₄`;
          if (Math.abs(frac - 0.75) < tol) return `${sign}${whole}³⁄₄`;
        } else if (denom === 6) {
          if (Math.abs(frac - 1 / 6) < tol) return `${sign}${whole}¹⁄₆`;
          if (Math.abs(frac - 2 / 6) < tol) return `${sign}${whole}²⁄₆`;
          if (Math.abs(frac - 3 / 6) < tol) return `${sign}${whole}³⁄₆`;
          if (Math.abs(frac - 4 / 6) < tol) return `${sign}${whole}⁴⁄₆`;
          if (Math.abs(frac - 5 / 6) < tol) return `${sign}${whole}⁵⁄₆`;
        }

        return `${sign}${absVal.toFixed(1)}`;
      }

      /**
       * @function formatStopCompact
       * @description Formats stop value in compact form for rulers and small displays.
       * Shows fraction-only when <1 stop, includes whole number otherwise.
       * @param {number} stopValue - Stop value in full stops
       * @returns {string} Compact formatted stop string (e.g., "⅓", "1½", "2")
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * formatStopCompact(0.33); // Returns "⅓" if denominator is 3
       */
      function formatStopCompact(stopValue) {
        const denom = window.stopDenominator || 3;
        const whole = Math.floor(stopValue);
        const fraction = stopValue - whole;
        const tol = 1e-6;

        if (Math.abs(fraction) < tol) {
          return `${whole}`;
        }

        let fracLabel = "";
        if (denom === 2) {
          if (Math.abs(fraction - 0.5) < tol) fracLabel = "½";
        } else if (denom === 3) {
          if (Math.abs(fraction - 1 / 3) < tol) fracLabel = "⅓";
          else if (Math.abs(fraction - 2 / 3) < tol) fracLabel = "⅔";
        } else if (denom === 4) {
          if (Math.abs(fraction - 0.25) < tol) fracLabel = "¹⁄₄";
          else if (Math.abs(fraction - 0.5) < tol) fracLabel = "²⁄₄";
          else if (Math.abs(fraction - 0.75) < tol) fracLabel = "³⁄₄";
        } else if (denom === 6) {
          if (Math.abs(fraction - 1 / 6) < tol) fracLabel = "¹⁄₆";
          else if (Math.abs(fraction - 2 / 6) < tol) fracLabel = "²⁄₆";
          else if (Math.abs(fraction - 3 / 6) < tol) fracLabel = "³⁄₆";
          else if (Math.abs(fraction - 4 / 6) < tol) fracLabel = "⁴⁄₆";
          else if (Math.abs(fraction - 5 / 6) < tol) fracLabel = "⁵⁄₆";
        }

        if (fracLabel) {
          return whole === 0 ? fracLabel : `${whole}${fracLabel}`;
        }

        return stopValue.toFixed(1);
      }

      /**
       * @function calculateTime
       * @description Calculates exposure time for a given stop value.
       * Uses the formula: time = base * 2^(stop/denominator)
       * @param {number} base - Base exposure time in seconds
       * @param {number} stop - Stop value (in fractional steps)
       * @returns {number} Calculated exposure time in seconds
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * calculateTime(10, 3); // Returns 20.0 if denominator is 3 (1 stop = 2x time)
       */
      function calculateTime(base, stop) {
        const denom = window.stopDenominator || 3;
        return base * Math.pow(2, stop / denom);
      }

      /**
       * @class IncrementalTimer
       * @classdesc Dodge/burn calculator with step-by-step exposure progression.
       * Manages incremental exposure calculations for darkroom printing, allowing
       * users to build up exposure through multiple steps with f-stop precision.
       *
       * @property {number} baseTime - Base exposure time in seconds
       * @property {number} currentStop - Current f-stop increment value
       * @property {number} previousTotalTime - Total time from previous step
       * @property {number} currentTotalTime - Total time for current step
       * @property {number} thisExposureTime - Time for this specific step
       * @property {number} accumulatedTime - Cumulative time across all steps
       * @property {number} currentTime - Current countdown time
       * @property {boolean} isRunning - Whether exposure is in progress
       * @property {boolean} isPaused - Whether exposure is paused
       * @property {boolean} isCountdown - Whether countdown is active
       * @property {number} lastExposureTime - Time of last completed exposure
       * @property {DriftCorrectedTimer|null} driftTimer - High-precision timer instance
       * @property {number|null} lastBeepSecond - Last second that beep played
       * @property {Function|null} countdownResolve - Promise resolver for countdown
       *
       * @description
       * The calculator works by accumulating exposure time across multiple steps.
       * Each step adds time based on f-stop increments (1/3, 1/2, 1 stop, etc.).
       *
       * F-Stop Formula: time = baseTime × 2^(stop/denominator)
       *
       * Integration Points:
       * - Uses CountdownManager before starting exposure
       * - Triggers RelayManager for automatic enlarger control
       * - Syncs with appState.calculator for persistence
       * - Updates UI via render functions
       *
       * @example
       * // Initialize calculator
       * const calc = new IncrementalTimer();
       *
       * // Set base time and start
       * calc.baseTime = 10.0;
       * calc.currentStop = 1; // 1/3 stop
       * calc.updateCalculations();
       * await calc.start(); // Includes countdown and relay trigger
       *
       * // After exposure completes
       * calc.accumulatedTime = calc.currentTotalTime;
       * calc.updateCalculations(); // Ready for next step
       */
      class IncrementalTimer {
        /**
         * @constructor
         * @description Creates an IncrementalTimer instance and initializes state.
         * Syncs with appState.calculator, sets up event listeners, and renders UI.
         * @property {DriftCorrectedTimer|null} driftTimer - High-precision timer
         * @property {number|null} lastBeepSecond - Last beep second tracking
         * @property {Function|null} countdownResolve - Countdown promise resolver
         */
        constructor() {
          // Initialize state from appState
          this.syncFromState();

          this.driftTimer = null; // Using drift-corrected timer
          this.lastBeepSecond = null;
          this.countdownResolve = null;

          this.init();
          this.render();
        }

        /**
         * @method syncFromState
         * @description Synchronizes local properties from central appState.calculator.
         * Called during initialization to load persisted runtime state.
         * @returns {void}
         * @fires appState.calculator - Reads from central calculator state
         * @example
         * this.syncFromState(); // Load state before operations
         */
        syncFromState() {
          const state = appState.calculator;
          this.baseTime = state.baseTime;
          this.currentStop = state.currentStop;
          this.previousTotalTime = 0;
          this.currentTotalTime = state.currentTotalTime;
          this.thisExposureTime = state.thisExposureTime;
          this.accumulatedTime = state.accumulatedTime;
          this.currentTime = state.currentTime;
          this.isRunning = state.isRunning;
          this.isPaused = state.isPaused;
          this.isCountdown = state.isCountdown;
          this.lastExposureTime = state.lastExposureTime;
          this.displayedExposureTime = state.displayedExposureTime;
        }

        /**
         * @method syncToState
         * @description Synchronizes central appState.calculator from local properties.
         * Called before rendering to ensure UI reflects current state.
         * @returns {void}
         * @fires appState.calculator - Writes to central calculator state
         * @example
         * this.syncToState(); // Save state before rendering
         */
        syncToState() {
          const state = appState.calculator;
          state.baseTime = this.baseTime;
          state.currentStop = this.currentStop;
          state.currentTotalTime = this.currentTotalTime;
          state.thisExposureTime = this.thisExposureTime;
          state.accumulatedTime = this.accumulatedTime;
          state.currentTime = this.currentTime;
          state.isRunning = this.isRunning;
          state.isPaused = this.isPaused;
          state.isCountdown = this.isCountdown;
          state.lastExposureTime = this.lastExposureTime;
          state.displayedExposureTime = this.displayedExposureTime;
        }

        /**
         * @method render
         * @description Unified render method that updates all calculator UI elements.
         * Syncs state to appState, then calls render functions for display, details, timer status, and chart.
         * @returns {void}
         * @fires syncToState - Updates central state before rendering
         * @fires renderCalculatorDisplay - Updates main display
         * @fires renderCalculatorExposureDetails - Updates exposure details
         * @fires renderCalculatorTimerStatus - Updates timer status
         * @fires updateChart - Updates f-stop chart
         * @example
         * this.render(); // Update all UI elements
         */
        render() {
          this.syncToState();
          renderCalculatorDisplay();
          renderCalculatorExposureDetails();
          renderCalculatorTimerStatus();
          updateChart();
        }

        /**
         * @method init
         * @description Initializes event listeners for calculator sliders.
         * Binds base time and stop increment sliders to update calculations.
         * @returns {void}
         * @fires addEventListener - Listens for slider input events
         * @fires updateFromSliders - Called when sliders change
         * @example
         * this.init(); // Set up slider listeners
         */
        init() {
          // Sliders still need direct listeners for input events
          baseTimeSlider.addEventListener("input", () =>
            this.updateFromSliders(),
          );
          stopSlider.addEventListener("input", () => this.updateFromSliders());
        }

        /**
         * @method stopCurrentExposure
         * @description Stops the current exposure or cancels countdown.
         * Resets timer state and updates UI. If countdown is active, cancels it.
         * If exposure is running, stops it and resets current time.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires driftTimer.stop - Stops high-precision timer
         * @fires updateStatus - Updates UI with stop status
         * @fires playPreset - Audio feedback
         * @example
         * // User clicks "Stop" button during countdown or exposure
         * this.stopCurrentExposure();
         */
        stopCurrentExposure() {
          if (!this.isRunning && !this.isPaused && !this.isCountdown) return;

          const wasCountdown = this.isCountdown;

          if (this.isCountdown && window.countdownManager?.isActive) {
            window.countdownManager.cancel();
            if (this.countdownResolve) {
              this.countdownResolve("cancelled");
              this.countdownResolve = null;
            }
          }

          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.isCountdown = false;
          this.lastBeepSecond = null;

          // Reset current time to current exposure time
          this.currentTime = this.thisExposureTime;

          // Update state and render
          appState.ui.timerStatus = wasCountdown
            ? "COUNTDOWN CANCELLED"
            : "EXPOSURE STOPPED";
          this.render();

          playPreset("pause");
        }

        /**
         * @method repeatLast
         * @description Repeats the last completed exposure time.
         * Sets current exposure time to the last completed exposure time
         * and prepares the timer for immediate restart.
         * @returns {void}
         * @fires driftTimer.stop - Stops any running timer
         * @fires updateStatus - Updates UI with repeat status
         * @fires playPreset - Audio feedback
         * @example
         * // User clicks "Repeat" button after completing an exposure
         * this.repeatLast();
         */
        repeatLast() {
          if (this.lastExposureTime <= 0) return;

          // Set current exposure to last exposure time
          this.thisExposureTime = this.lastExposureTime;
          this.currentTime = this.lastExposureTime;

          // Reset timer state
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Update state and render
          appState.ui.timerStatus = "READY TO REPEAT";
          this.render();

          playPreset("pause");
        }

        /**
         * @method updateFromSliders
         * @description Updates calculator from slider values.
         * Reads base time and stop increment from UI sliders, recalculates
         * exposure times, and updates display.
         * @returns {void}
         * @fires updateCalculations - Recalculates exposure times
         * @fires render - Updates UI display
         * @example
         * // Called when user moves sliders
         * this.updateFromSliders();
         */
        updateFromSliders() {
          this.baseTime = parseFloat(baseTimeSlider.value);
          this.currentStop = parseInt(stopSlider.value);
          this.updateCalculations();
          this.render();
        }

        /**
         * @method updateCalculations
         * @description Recalculates all exposure times based on current parameters.
         * Uses f-stop formula: time = baseTime × 2^(stop/denominator)
         * Updates currentTotalTime, thisExposureTime, and currentTime.
         * @returns {void}
         * @fires calculateTime - F-stop time calculation function
         * @example
         * // After changing base time or stop increment
         * this.updateCalculations();
         */
        updateCalculations() {
          this.currentTotalTime = calculateTime(
            this.baseTime,
            this.currentStop,
          );
          this.thisExposureTime = this.currentTotalTime - this.accumulatedTime;

          if (this.thisExposureTime < 0) {
            this.thisExposureTime = 0;
          }

          if (!this.isRunning && !this.isPaused) {
            this.currentTime = this.thisExposureTime;
          }
        }

        /**
         * @method updateAllDisplays
         * @deprecated Use render() instead
         * @description Legacy method that calls render().
         * @returns {void}
         * @fires render - Updates all displays
         */
        updateAllDisplays() {
          // Deprecated - use render() instead
          this.render();
        }

        /**
         * @method triggerRelayForTimer
         * @description Triggers the enlarger relay for the current exposure time.
         * Only triggers if auto-trigger is enabled in RelayManager.
         * @returns {Promise<void>} Resolves when relay trigger completes
         * @fires relayManager.triggerTimerRelay - Sends timer command to server
         * @example
         * // Called automatically during start() method
         * await this.triggerRelayForTimer();
         */
        async triggerRelayForTimer() {
          if (window.relayManager && window.relayManager.autoTrigger) {
            // Use the current exposure time
            const exposureTime = this.thisExposureTime;

            // Send relay trigger with the exposure time
            await window.relayManager.triggerTimerRelay(exposureTime);
          }
        }

        /**
         * @method start
         * @description Starts the exposure with countdown and relay trigger.
         * Performs countdown using CountdownManager, triggers enlarger relay,
         * and starts the exposure timer with drift correction.
         * @returns {Promise<void>} Resolves when countdown completes or is cancelled
         * @throws {Error} Logs error if relay trigger fails
         * @fires countdownManager.startCountdown - Visual/audio countdown
         * @fires relayManager.triggerTimerRelay - Triggers enlarger
         * @fires startInterval - Begins exposure timer
         * @fires updateStatus - Updates UI status
         * @fires render - Updates UI display
         * @example
         * // User clicks "Start Exposure" button
         * await this.start();
         */
        async start() {
          if (
            this.isRunning ||
            this.isPaused ||
            this.isCountdown ||
            this.thisExposureTime <= 0
          )
            return;

          // Start countdown
          const display = document.getElementById("calcTimerDisplay");
          const originalText = display.textContent;
          this.isCountdown = true;
          appState.ui.timerStatus = "COUNTDOWN STARTING...";
          this.render();

          // During countdown: disable start/repeat/reset, keep stop enabled
          const startBtn = document.getElementById("startExposure");
          const stopBtn = document.getElementById("stopCalcTimer");
          const resetBtn = document.getElementById("resetCalcTimer");
          const repeatBtn = document.getElementById("repeatExposure");
          if (startBtn) startBtn.disabled = true;
          if (stopBtn) stopBtn.disabled = false;
          if (resetBtn) resetBtn.disabled = true;
          if (repeatBtn) repeatBtn.disabled = true;

          const countdownResult = await new Promise((resolve) => {
            this.countdownResolve = resolve;
            window.countdownManager.startCountdown(display, () => {
              resolve("complete");
            });
          });

          this.countdownResolve = null;
          this.isCountdown = false;

          // Ensure display is restored even if countdown was cancelled
          display.textContent = originalText;

          if (countdownResult === "cancelled") {
            appState.ui.timerStatus = "COUNTDOWN CANCELLED";
            this.render();
            return;
          }

          appState.ui.timerStatus = "EXPOSURE IN PROGRESS";

          // TRIGGER RELAY HERE
          if (window.relayManager && window.relayManager.autoTrigger) {
            try {
              await window.relayManager.triggerTimerRelay(
                this.thisExposureTime,
              );
            } catch (error) {
              console.error("Failed to trigger relay:", error);
            }
          }

          // Now start the actual exposure timer
          this.isRunning = true;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Capture the displayed exposure time for logging
          this.displayedExposureTime = this.thisExposureTime;

          this.render();
          this.startInterval();
        }

        /**
         * @method startInterval
         * @description Starts the drift-corrected exposure timer.
         * Creates a DriftCorrectedTimer that decrements currentTime by 0.1s intervals.
         * Updates display, plays warning beeps, and calls complete() when finished.
         * @returns {void}
         * @fires DriftCorrectedTimer - High-precision timer instance
         * @fires playPreset - Warning beeps at 3 seconds
         * @fires complete - Called when timer reaches zero
         * @example
         * // Called by start() after countdown
         * this.startInterval();
         */
        startInterval() {
          this.driftTimer = new DriftCorrectedTimer(() => {
            this.currentTime -= 0.1;

            if (this.currentTime <= 0) {
              this.currentTime = 0;
              this.complete();
            } else {
              // Update display directly for performance
              document.getElementById("calcTimerDisplay").textContent =
                this.currentTime.toFixed(2);

              // Sync state periodically
              appState.calculator.currentTime = this.currentTime;

              if (this.currentTime <= 3 && appState.settings.calcWarningBeep) {
                const currentSecond = Math.ceil(this.currentTime);

                if (
                  currentSecond !== this.lastBeepSecond &&
                  currentSecond <= 3 &&
                  currentSecond > 0
                ) {
                  this.lastBeepSecond = currentSecond;
                  playPreset("calcWarning");
                  document
                    .getElementById("calcTimerDisplay")
                    .classList.add("warning");

                  setTimeout(() => {
                    document
                      .getElementById("calcTimerDisplay")
                      .classList.remove("warning");
                  }, 500);
                }
              }
            }
          }, 100);

          this.driftTimer.start();
        }

        /**
         * @method pause
         * @description Pauses the running exposure timer.
         * Stops the drift timer and updates state to paused.
         * @returns {void}
         * @fires driftTimer.stop - Stops high-precision timer
         * @fires updateStatus - Updates UI with pause status
         * @fires playPreset - Audio feedback
         * @example
         * // User clicks "Pause" button during exposure
         * this.pause();
         */
        pause() {
          if (!this.isRunning) return;

          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = true;

          appState.ui.timerStatus = "EXPOSURE PAUSED";
          this.render();

          playPreset("pause");
        }

        /**
         * @method resume
         * @description Resumes a paused exposure timer.
         * Restarts the drift timer and continues countdown from paused time.
         * @returns {void}
         * @fires startInterval - Restarts timer with remaining time
         * @fires updateStatus - Updates UI with resume status
         * @example
         * // User clicks "Resume" button after pausing
         * this.resume();
         */
        resume() {
          if (!this.isPaused) return;

          this.isRunning = true;
          this.isPaused = false;
          this.lastBeepSecond = null;

          appState.ui.timerStatus = "EXPOSURE IN PROGRESS";
          this.render();

          this.startInterval();
        }

        /**
         * @method complete
         * @description Called when exposure timer reaches zero.
         * Stops timer, saves exposure time, updates accumulated time,
         * plays completion sound, and prepares for next step.
         * @returns {void}
         * @fires driftTimer.stop - Stops high-precision timer
         * @fires updateCalculations - Recalculates for next step
         * @fires playPreset - Completion beep
         * @fires updateStatus - Updates UI with complete status
         * @fires render - Updates display
         * @example
         * // Called automatically when timer reaches zero
         * this.complete();
         */
        complete() {
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.lastBeepSecond = null;

          // Save the exposure time that just completed
          this.lastExposureTime = this.thisExposureTime;

          this.accumulatedTime = this.currentTotalTime;

          if (appState.settings.calcEndBeep) {
            playPreset("calcComplete");
          }

          appState.ui.timerStatus = "EXPOSURE COMPLETE";
          this.updateCalculations();
          this.currentTime = this.thisExposureTime;

          // Log this CALC exposure
          if (window.exposureLogManager) {
            const filterContext = appState.calculator.splitGrade.enabled
              ? `F${appState.calculator.splitGrade.softFilter}/F${appState.calculator.splitGrade.hardFilter}`
              : null;

            // Get notes from input field
            const notesInput = document.getElementById("calcNotesInput");
            const notes = notesInput ? notesInput.value : "";

            // Use the displayed exposure time that was captured at start
            const exposureTime =
              this.displayedExposureTime || this.thisExposureTime;

            window.exposureLogManager.addCalcPhase({
              baseTime: appState.calculator.baseTime,
              stopAdjustment: appState.calculator.currentStop,
              finalTime: exposureTime,
              filterContext: filterContext,
              notes: notes,
            });

            // Clear notes input
            if (notesInput) notesInput.value = "";
          }

          this.render();
        }

        /**
         * @method reset
         * @description Resets calculator to initial state.
         * Stops any running timer, clears accumulated time, and resets
         * to ready state for new exposure sequence.
         * @returns {void}
         * @fires driftTimer.stop - Stops any running timer
         * @fires updateCalculations - Recalculates base exposure
         * @fires updateStatus - Updates UI with ready status
         * @fires render - Updates display
         * @example
         * // User clicks "Reset" button
         * this.reset();
         */
        reset() {
          if (this.driftTimer) {
            this.driftTimer.stop();
          }
          this.isRunning = false;
          this.isPaused = false;
          this.isCountdown = false;
          this.lastBeepSecond = null;
          this.displayedExposureTime = null;

          this.accumulatedTime = 0;
          this.updateCalculations();
          this.currentTime = this.thisExposureTime;

          appState.ui.timerStatus = "READY FOR EXPOSURE";
          this.render();
        }

        /**
         * @method toggle
         * @description Toggles between start, pause, and resume states.
         * Convenience method that handles state transitions based on current state.
         * @returns {void}
         * @fires start - If idle
         * @fires pause - If running
         * @fires resume - If paused
         * @example
         * // User clicks main exposure button
         * this.toggle();
         */
        toggle() {
          if (this.isCountdown) return;
          if (this.isRunning) {
            this.pause();
          } else if (this.isPaused) {
            this.resume();
          } else {
            this.start();
          }
        }
      }

      /**
       * @class EnlargerHeightCalculator
       * @classdesc Comprehensive darkroom exposure calculator integrating height, aperture, paper size, and contrast.
       * Calculates new exposure time based on multiple variables using the inverse square law and f-stop formulas.
       *
       * @property {IncrementalTimer} incrementalTimer - Reference to main calculator for time synchronization
       * @property {number} originalTime - Base exposure time in seconds
       * @property {number} originalHeight - Original enlarger height in cm
       * @property {number} newHeight - New enlarger height in cm
       * @property {number} originalFStop - Original lens aperture (f-stop)
       * @property {number} newFStop - New lens aperture (f-stop)
       * @property {number} originalPaperSize - Original paper area in m²
       * @property {number} newPaperSize - New paper area in m²
       * @property {number} originalPaperSizeCustom - Custom original paper area
       * @property {number} newPaperSizeCustom - Custom new paper area
       * @property {string} currentPaper - Selected paper type ('fomaspeed' or 'fomatonemg')
       * @property {string} currentFilter - Selected contrast filter
       * @property {number} filterFactor - Contrast filter factor from paper data
       * @property {number} customBankFactor - Custom filter bank multiplier
       * @property {string} customBankLabel - Name of custom filter bank
       * @property {number} heightFactor - Calculated height factor (squared)
       * @property {number} fstopFactor - Calculated f-stop factor (squared)
       * @property {number} paperSizeFactor - Calculated paper area ratio
       * @property {number} combinedFactor - Product of all factors
       * @property {number} newAdjustedTime - Final calculated exposure time
       *
       * @description
       * **Formula:** New Time = Original Time × Height Factor × F-Stop Factor × Paper Factor × Filter Factor × Custom Factor
       *
       * Where:
       * - Height Factor = (New Height ÷ Original Height)²
       * - F-Stop Factor = (New F-Stop ÷ Original F-Stop)²
       * - Paper Factor = New Paper Area ÷ Original Paper Area
       * - Filter Factor = Selected contrast filter multiplier
       * - Custom Factor = Custom filter bank multiplier
       *
       * **Integration:**
       * - Syncs with IncrementalTimer for current exposure time
       * - Updates CALC tab base time when applied
       * - Integrates with CustomFilterBankManager for contrast control
       * - Uses paper-specific filter data for accurate calculations
       *
       * @example
       * // Initialize calculator
       * const calc = new EnlargerHeightCalculator(window.incrementalTimer);
       *
       * // Copy current time from calculator
       * calc.copyCurrentTime();
       *
       * // Adjust parameters
       * calc.newHeight = 45; // Raise enlarger
       * calc.updateCalculations();
       * calc.updateDisplay();
       *
       * // Apply to CALC tab
       * calc.applyNewTime();
       */
      class EnlargerHeightCalculator {
        /**
         * @constructor
         * @description Creates an EnlargerHeightCalculator instance with default values.
         * Initializes all calculation parameters and sets up UI event listeners.
         * @param {IncrementalTimer} incrementalTimer - Reference to main calculator
         * @property {Object} paperTypes - Paper-specific contrast filter data
         */
        constructor(incrementalTimer) {
          this.incrementalTimer = incrementalTimer;
          this.originalTime = 10.0;
          this.originalHeight = 30.0;
          this.newHeight = 30.0;
          this.originalFStop = 5.6;
          this.newFStop = 5.6;
          this.originalPaperSize = 0.052; // Changed from 0.080
          this.newPaperSize = 0.052; // Changed from 0.080
          this.originalPaperSizeCustom = 0.052; // Changed from 0.080
          this.newPaperSizeCustom = 0.052; // Changed from 0.080

          // NEW: Contrast control variables
          this.currentBrand = "FOMA"; // FOMA, Ilford
          this.currentPaper = "fomaspeed";
          this.currentFilter = "none";
          this.filterFactor = 1.0;
          this.customBankFactor = 1.0;
          this.customBankLabel = "";

          // Paper types data from contrast calculator
          this.paperTypes = {
            // ===== FOMA PAPERS =====

            // FOMASPEED VARIANT
            fomaspeed: {
              name: "FOMASPEED VARIANT",
              filters: {
                none: { iso: 105, factor: 1.0 }, // Base ISO for no filter
                "2xY": { iso: 135, factor: 1.6 },
                Y: { iso: 120, factor: 1.4 },
                M1: { iso: 90, factor: 1.4 },
                "2xM1": { iso: 80, factor: 2.1 },
                M2: { iso: 65, factor: 2.6 },
                "2xM2": { iso: 55, factor: 4.6 },
              },
            },

            // FOMABROM VARIANT
            fomabrom: {
              name: "FOMABROM VARIANT",
              filters: {
                none: { iso: 105, factor: 1.0 }, // Base ISO for no filter
                "2xY": { iso: 135, factor: 1.6 },
                Y: { iso: 120, factor: 1.4 },
                M1: { iso: 90, factor: 1.4 },
                "2xM1": { iso: 80, factor: 2.1 },
                M2: { iso: 65, factor: 2.6 },
                "2xM2": { iso: 55, factor: 4.6 },
              },
            },

            // FOMAPASTEL MG (Special FB Colored Base)
            fomapastel_mg: {
              name: "FOMAPASTEL MG (Special FB Colored Base)",
              filters: {
                none: { iso: 105, factor: 1.0 }, // Base ISO for no filter
                "2xY": { iso: 135, factor: 1.5 },
                Y: { iso: 120, factor: 1.4 },
                M1: { iso: 90, factor: 1.4 },
                "2xM1": { iso: 80, factor: 2.0 },
                M2: { iso: 65, factor: 2.5 },
                "2xM2": { iso: 55, factor: 4.5 },
              },
            },

            // FOMATONE MG Classic (Warm Tone)
            fomatone_mg_classic_variant: {
              name: "FOMATONE MG Classic (Warm Tone)",
              filters: {
                none: { iso: 105, factor: 1.0 }, // Base ISO for no filter
                "2xY": { iso: 120, factor: 2.0 },
                Y: { iso: 105, factor: 1.5 },
                M1: { iso: 80, factor: 1.5 },
                "2xM1": { iso: 75, factor: 1.8 },
                M2: { iso: 65, factor: 2.0 },
                "2xM2": { iso: 55, factor: 3.0 },
              },
            },

            // ===== ILFORD PAPERS =====

            // Multigrade RC Cooltone
            cooltone: {
              name: "Multigrade RC Cooltone",
              filters: {
                none: { iso: 100, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 180, factor: 2.5 },
                0: { iso: 160, factor: 2.5 },
                1: { iso: 120, factor: 2.5 },
                2: { iso: 100, factor: 2.5 },
                3: { iso: 80, factor: 2.5 },
                4: { iso: 60, factor: 5.0 },
                5: { iso: 50, factor: 5.0 },
              },
            },

            // Multigrade IV RC Portfolio (Discontinued)
            portfolio: {
              name: "Multigrade IV RC Portfolio (Discontinued)",
              filters: {
                none: { iso: 110, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 180, factor: 2.5 },
                0: { iso: 160, factor: 2.5 },
                1: { iso: 130, factor: 2.5 },
                2: { iso: 110, factor: 2.5 },
                3: { iso: 90, factor: 2.5 },
                4: { iso: 60, factor: 5.0 },
                5: { iso: 40, factor: 5.0 },
              },
            },

            // MULTIGRADE RC DELUXE (NEW)
            rc_deluxe_new: {
              name: "MULTIGRADE RC DELUXE (NEW)",
              filters: {
                none: { iso: 90, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 160, factor: 2.08 },
                0: { iso: 130, factor: 2.08 },
                1: { iso: 110, factor: 2.08 },
                2: { iso: 90, factor: 2.08 },
                3: { iso: 70, factor: 2.08 },
                4: { iso: 60, factor: 2.27 },
                5: { iso: 50, factor: 2.27 },
              },
            },

            // MULTIGRADE RC PORTFOLIO (NEW)
            rc_portfolio_new: {
              name: "MULTIGRADE RC PORTFOLIO (NEW)",
              filters: {
                none: { iso: 90, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 160, factor: 2.08 },
                0: { iso: 130, factor: 2.08 },
                1: { iso: 110, factor: 2.08 },
                2: { iso: 90, factor: 2.08 },
                3: { iso: 70, factor: 2.08 },
                4: { iso: 60, factor: 2.27 },
                5: { iso: 50, factor: 2.27 },
              },
            },

            // Multigrade FB Classic
            fb_classic: {
              name: "Multigrade FB Classic",
              filters: {
                none: { iso: 95, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 170, factor: 2.17 },
                0: { iso: 140, factor: 2.17 },
                1: { iso: 110, factor: 2.17 },
                2: { iso: 95, factor: 2.17 },
                3: { iso: 80, factor: 2.17 },
                4: { iso: 60, factor: 2.38 },
                5: { iso: 50, factor: 2.38 },
              },
            },

            // Multigrade FB Warmtone
            fb_warmtone: {
              name: "Multigrade FB Warmtone",
              filters: {
                none: { iso: 110, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 170, factor: 2.0 },
                0: { iso: 160, factor: 2.0 },
                1: { iso: 130, factor: 2.0 },
                2: { iso: 110, factor: 2.0 },
                3: { iso: 90, factor: 2.0 },
                4: { iso: 70, factor: 4.0 },
                5: { iso: 50, factor: 4.0 },
              },
            },

            // Multigrade FB Cooltone
            fb_cooltone: {
              name: "Multigrade FB Cooltone",
              filters: {
                none: { iso: 100, factor: 1.0 }, // Base ISO for no filter (grade 2)
                "00": { iso: 180, factor: 2.36 },
                0: { iso: 160, factor: 2.36 },
                1: { iso: 130, factor: 2.36 },
                2: { iso: 100, factor: 2.36 },
                3: { iso: 80, factor: 2.36 },
                4: { iso: 60, factor: 2.62 },
                5: { iso: 50, factor: 2.62 },
              },
            },
          };

          this.heightFactor = 1.0;
          this.fstopFactor = 1.0;
          this.paperSizeFactor = 1.0;
          this.combinedFactor = 1.0;
          this.newAdjustedTime = 10.0;

          this.init();
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method init
         * @description Initializes UI elements and event listeners for the calculator.
         * Binds all sliders, dropdowns, and buttons to their respective handler functions.
         * @returns {void}
         * @fires addEventListener - Binds input/change/click events
         * @fires updateFromControls - Called by sliders and dropdowns
         * @fires copyCurrentTime - Called by "Use Current" button
         * @fires applyNewTime - Called by "Apply" button
         * @fires selectPaper - Called by paper type buttons
         * @example
         * this.init(); // Set up all UI bindings
         */
        init() {
          // Get existing elements
          this.originalHeightCoarseSlider = document.getElementById(
            "originalHeightCoarseSlider",
          );
          this.originalHeightFineSlider = document.getElementById(
            "originalHeightFineSlider",
          );
          this.newHeightCoarseSlider = document.getElementById(
            "newHeightCoarseSlider",
          );
          this.newHeightFineSlider = document.getElementById(
            "newHeightFineSlider",
          );
          this.originalHeightValue = document.getElementById(
            "originalHeightValue",
          );
          this.newHeightValue = document.getElementById("newHeightValue");
          this.originalTimeValue = document.getElementById("originalTimeValue");
          this.heightFactorElement = document.getElementById(
            "heightFactorDisplay",
          );
          this.fstopFactorElement = document.getElementById("fstopFactor");
          this.combinedFactorElement =
            document.getElementById("combinedFactor");
          this.newAdjustedTimeElement =
            document.getElementById("newAdjustedTime");
          this.copyCurrentTimeBtn = document.getElementById("copyCurrentTime");
          this.applyHeightTimeBtn = document.getElementById("applyHeightTime");
          this.originalFStopElement = document.getElementById("originalFStop");
          this.newFStopElement = document.getElementById("newFStop");
          this.originalPaperSizeElement =
            document.getElementById("originalPaperSize");
          this.newPaperSizeElement = document.getElementById("newPaperSize");
          this.originalCustomPaperSizeDiv = document.getElementById(
            "originalCustomPaperSize",
          );
          this.newCustomPaperSizeDiv =
            document.getElementById("newCustomPaperSize");
          this.originalCustomPaperSizeValue = document.getElementById(
            "originalCustomPaperSizeValue",
          );
          this.newCustomPaperSizeValue = document.getElementById(
            "newCustomPaperSizeValue",
          );
          this.setOriginalCustomPaperBtn = document.getElementById(
            "setOriginalCustomPaper",
          );
          this.setNewCustomPaperBtn =
            document.getElementById("setNewCustomPaper");

          // NEW: Get contrast control elements
          this.btnContrastFoma = document.getElementById("btnContrastFoma");
          this.btnContrastIlford = document.getElementById("btnContrastIlford");
          this.ilfordPaperSelector = document.getElementById(
            "ilfordPaperSelector",
          );
          this.fomaPaperSelector = document.getElementById("fomaPaperSelector");
          this.ilfordPaperType = document.getElementById("ilfordPaperType");
          this.fomaPaperType = document.getElementById("fomaPaperType");
          this.contrastFilterSelect = document.getElementById(
            "contrastFilterSelect",
          );
          this.isoValueElement = document.getElementById("isoValue");
          this.filterFactorValueElement =
            document.getElementById("filterFactorValue");
          this.filterFactorValueDisplay = document.getElementById(
            "filterFactorValueDisplay",
          );
          this.customBankFactorDisplay = document.getElementById(
            "customBankFactorDisplay",
          );
          this.isoRBox = document.getElementById("isoRBox");

          // Set initial values
          this.originalCoarseHeight = 30;
          this.originalFineHeight = 0;
          this.newCoarseHeight = 30;
          this.newFineHeight = 0;

          // Add event listeners for existing controls
          this.originalHeightCoarseSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );
          this.originalHeightFineSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );
          this.newHeightCoarseSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );
          this.newHeightFineSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );
          this.originalFStopElement.addEventListener("change", () =>
            this.updateFromControls(),
          );
          this.newFStopElement.addEventListener("change", () =>
            this.updateFromControls(),
          );
          this.copyCurrentTimeBtn.addEventListener("click", () =>
            this.copyCurrentTime(),
          );
          this.applyHeightTimeBtn.addEventListener("click", () =>
            this.applyNewTime(),
          );
          this.originalPaperSizeElement.addEventListener("change", (e) => {
            const value = e.target.value;
            if (value === "custom") {
              this.originalCustomPaperSizeDiv.style.display = "block";
            } else {
              this.originalCustomPaperSizeDiv.style.display = "none";
              this.originalPaperSize = parseFloat(value);
              this.updateCalculations();
              this.updateDisplay();
            }
          });

          // New paper size change handler
          this.newPaperSizeElement.addEventListener("change", (e) => {
            const value = e.target.value;
            if (value === "custom") {
              this.newCustomPaperSizeDiv.style.display = "block";
            } else {
              this.newCustomPaperSizeDiv.style.display = "none";
              this.newPaperSize = parseFloat(value);
              this.updateCalculations();
              this.updateDisplay();
            }
          });
          this.setNewCustomPaperBtn.addEventListener("click", () => {
            const customValue = parseFloat(this.newCustomPaperSizeValue.value);
            if (customValue && customValue > 0) {
              this.newPaperSizeCustom = customValue;
              if (this.newPaperSizeElement.value === "custom") {
                this.newPaperSize = customValue;
                this.updateCalculations();
                this.updateDisplay();
                // Show visual feedback
                this.setNewCustomPaperBtn.textContent = "✓ Set";
                this.setNewCustomPaperBtn.classList.add("active");
                setTimeout(() => {
                  this.setNewCustomPaperBtn.textContent = "Set";
                  this.setNewCustomPaperBtn.classList.remove("active");
                }, 1000);
              }
            }
          });

          // Set original custom paper size button
          this.setOriginalCustomPaperBtn.addEventListener("click", () => {
            const customValue = parseFloat(
              this.originalCustomPaperSizeValue.value,
            );
            if (customValue && customValue > 0) {
              this.originalPaperSizeCustom = customValue;
              if (this.originalPaperSizeElement.value === "custom") {
                this.originalPaperSize = customValue;
                this.updateCalculations();
                this.updateDisplay();
                // Show visual feedback
                this.setOriginalCustomPaperBtn.textContent = "✓ Set";
                this.setOriginalCustomPaperBtn.classList.add("active");
                setTimeout(() => {
                  this.setOriginalCustomPaperBtn.textContent = "Set";
                  this.setOriginalCustomPaperBtn.classList.remove("active");
                }, 1000);
              }
            }
          });

          // NEW: Add event listeners for contrast controls
          // Paper brand toggle buttons
          this.btnContrastFoma.addEventListener("click", () => {
            this.setPaperBrand("FOMA");
          });
          this.btnContrastIlford.addEventListener("click", () => {
            this.setPaperBrand("Ilford");
          });

          // Paper type dropdowns
          this.ilfordPaperType.addEventListener("change", () => {
            this.setIlfordPaperType(this.ilfordPaperType.value);
          });
          this.fomaPaperType.addEventListener("change", () => {
            this.setFomaPaperType(this.fomaPaperType.value);
          });

          // Contrast filter dropdown
          this.contrastFilterSelect.addEventListener("change", () => {
            this.currentFilter = this.contrastFilterSelect.value;
            this.updateCalculations();
            this.updateDisplay();
          });

          this.applyHeightTimeBtn.addEventListener("click", initAudioContext);

          // Initialize filter options on startup
          this.updateFilterOptions();
        }

        /**
         * @method setPaperBrand
         * @description Sets the paper brand and updates UI accordingly.
         * Updates toggle button states, shows/hides paper type dropdowns, and updates filter options.
         * @param {string} brand - 'FOMA' or 'Ilford'
         * @returns {void}
         * @fires updateBrandUI - Updates UI visibility
         * @fires updateFilterOptions - Updates filter dropdown
         * @fires updateCalculations - Recalculates with new brand
         * @fires updateDisplay - Updates UI
         * @example
         * this.setPaperBrand('Ilford'); // Switch to Ilford brand
         */
        setPaperBrand(brand) {
          this.currentBrand = brand;

          // Update toggle button states
          this.btnContrastFoma.classList.toggle("active", brand === "FOMA");
          this.btnContrastIlford.classList.toggle("active", brand === "Ilford");

          // Set default paper type for the selected brand
          if (brand === "FOMA") {
            this.currentPaper = "fomaspeed";
            if (this.fomaPaperType) {
              this.fomaPaperType.value = "fomaspeed";
            }
          } else if (brand === "Ilford") {
            this.currentPaper = "cooltone";
            if (this.ilfordPaperType) {
              this.ilfordPaperType.value = "cooltone";
            }
          }

          // Update UI
          this.updateBrandUI();
          this.updateFilterOptions();
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method setIlfordPaperType
         * @description Sets the Ilford paper type from dropdown selection.
         * Updates current paper and recalculates exposure.
         * @param {string} type - Ilford paper type (e.g., 'cooltone', 'fb_classic')
         * @returns {void}
         * @fires updateCalculations - Recalculates with new paper
         * @fires updateDisplay - Updates UI
         * @example
         * this.setIlfordPaperType('fb_classic'); // Use Multigrade FB Classic
         */
        setIlfordPaperType(type) {
          this.currentPaper = type;
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method setFomaPaperType
         * @description Sets the FOMA paper type from dropdown selection.
         * Updates current paper and recalculates exposure.
         * @param {string} type - FOMA paper type (e.g., 'fomaspeed', 'fomabrom')
         * @returns {void}
         * @fires updateCalculations - Recalculates with new paper
         * @fires updateDisplay - Updates UI
         * @example
         * this.setFomaPaperType('fomaspeed'); // Use FOMASPEED VARIANT
         */
        setFomaPaperType(type) {
          this.currentPaper = type;
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method updateBrandUI
         * @description Updates UI visibility based on selected brand.
         * Shows/hides paper type dropdowns and ISO R display.
         * @returns {void}
         * @fires Element.style.display - Shows/hides UI elements
         */
        updateBrandUI() {
          // Show/hide paper type dropdowns based on brand
          if (this.currentBrand === "FOMA") {
            this.ilfordPaperSelector.style.display = "none";
            this.fomaPaperSelector.style.display = "block";
            this.isoRBox.style.display = "block";
          } else if (this.currentBrand === "Ilford") {
            this.ilfordPaperSelector.style.display = "block";
            this.fomaPaperSelector.style.display = "none";
            this.isoRBox.style.display = "block";
          } else {
            this.ilfordPaperSelector.style.display = "none";
            this.fomaPaperSelector.style.display = "none";
            this.isoRBox.style.display = "none";
          }
        }

        /**
         * @method updateFilterOptions
         * @description Dynamically populates filter dropdown based on selected brand.
         * Updates filter options and sets default selection.
         * @returns {void}
         * @fires Element.innerHTML - Updates filter select options
         */
        updateFilterOptions() {
          const filterSelect = this.contrastFilterSelect;
          filterSelect.innerHTML = "";

          let options = [];
          if (this.currentBrand === "FOMA") {
            options = [
              { value: "none", text: "No filter" },
              { value: "2xY", text: "2×Y" },
              { value: "Y", text: "Y" },
              { value: "M1", text: "M1" },
              { value: "2xM1", text: "2×M1" },
              { value: "M2", text: "M2" },
              { value: "2xM2", text: "2×M2" },
            ];
          } else if (this.currentBrand === "Ilford") {
            options = [
              { value: "none", text: "No filter" },
              { value: "00", text: "Grade 00" },
              { value: "0", text: "Grade 0" },
              { value: "1", text: "Grade 1" },
              { value: "2", text: "Grade 2" },
              { value: "3", text: "Grade 3" },
              { value: "4", text: "Grade 4" },
              { value: "5", text: "Grade 5" },
            ];
          }

          options.forEach((opt) => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.text;
            filterSelect.appendChild(option);
          });

          // Set default selection
          filterSelect.value = options[0].value;
          this.currentFilter = filterSelect.value;
        }

        /**
         * @method updateCustomPaperSizeDisplays
         * @description Updates custom paper size input fields and visibility.
         * Shows/hides custom input fields based on dropdown selection.
         * @returns {void}
         * @fires Element.style.display - Shows/hides custom inputs
         * @fires Element.value - Updates input values
         * @example
         * this.updateCustomPaperSizeDisplays(); // Sync custom inputs
         */
        updateCustomPaperSizeDisplays() {
          // Update custom input fields with current values
          this.originalCustomPaperSizeValue.value =
            this.originalPaperSizeCustom.toFixed(3);
          this.newCustomPaperSizeValue.value =
            this.newPaperSizeCustom.toFixed(3);

          // Show/hide custom inputs based on selection
          if (this.originalPaperSizeElement.value === "custom") {
            this.originalCustomPaperSizeDiv.style.display = "block";
          } else {
            this.originalCustomPaperSizeDiv.style.display = "none";
          }

          if (this.newPaperSizeElement.value === "custom") {
            this.newCustomPaperSizeDiv.style.display = "block";
          } else {
            this.newCustomPaperSizeDiv.style.display = "none";
          }
        }

        /**
         * @method copyCurrentTime
         * @description Copies current exposure time from IncrementalTimer to calculator.
         * Resets fine height adjustments to zero and updates all calculations.
         * @returns {void}
         * @fires updateCalculations - Recalculates with new base time
         * @fires updateDisplay - Updates UI
         * @fires playBeep - Audio feedback
         * @example
         * this.copyCurrentTime(); // Use current calculator time as base
         */
        copyCurrentTime() {
          this.originalTime = this.incrementalTimer.currentTotalTime;

          // Reset fine adjustments to zero
          this.originalFineHeight = 0;
          this.newFineHeight = 0;

          // Update sliders
          this.originalHeightFineSlider.value = 0;
          this.newHeightFineSlider.value = 0;

          this.updateCalculations();
          this.updateDisplay();
          playBeep(600, 0.3, 0.2);
        }

        /**
         * @method updateFromControls
         * @description Reads all control values and updates calculator state.
         * Processes height sliders (coarse + fine), f-stop dropdowns, and paper size selections.
         * Handles custom paper size inputs and visibility.
         * @returns {void}
         * @fires updateCalculations - Recalculates all factors
         * @fires updateDisplay - Updates UI
         * @fires updateCustomPaperSizeDisplays - Syncs custom inputs
         * @example
         * // Called when any control changes
         * this.updateFromControls();
         */
        updateFromControls() {
          // Get coarse and fine values
          this.originalCoarseHeight = parseInt(
            this.originalHeightCoarseSlider.value,
          );
          this.originalFineHeight =
            parseInt(this.originalHeightFineSlider.value) / 10; // Convert to decimal
          this.newCoarseHeight = parseInt(this.newHeightCoarseSlider.value);
          this.newFineHeight = parseInt(this.newHeightFineSlider.value) / 10;

          // Calculate total heights
          this.originalHeight =
            this.originalCoarseHeight + this.originalFineHeight;
          this.newHeight = this.newCoarseHeight + this.newFineHeight;

          // Get f-stop values
          this.originalFStop = parseFloat(this.originalFStopElement.value);
          this.newFStop = parseFloat(this.newFStopElement.value);

          // Get paper size values
          const originalPaperSizeSelect = this.originalPaperSizeElement.value;
          const newPaperSizeSelect = this.newPaperSizeElement.value;

          // Handle original paper size
          if (originalPaperSizeSelect === "custom") {
            // Show custom input and set current value
            this.originalCustomPaperSizeDiv.style.display = "block";
            this.originalCustomPaperSizeValue.value =
              this.originalPaperSizeCustom.toFixed(3);
            this.originalPaperSize = this.originalPaperSizeCustom;
          } else {
            // Hide custom input and use preset value
            this.originalCustomPaperSizeDiv.style.display = "none";
            this.originalPaperSize = parseFloat(originalPaperSizeSelect);
          }

          // Handle new paper size
          if (newPaperSizeSelect === "custom") {
            // Show custom input and set current value
            this.newCustomPaperSizeDiv.style.display = "block";
            this.newCustomPaperSizeValue.value =
              this.newPaperSizeCustom.toFixed(3);
            this.newPaperSize = this.newPaperSizeCustom;
          } else {
            // Hide custom input and use preset value
            this.newCustomPaperSizeDiv.style.display = "none";
            this.newPaperSize = parseFloat(newPaperSizeSelect);
          }

          this.updateCalculations();
          this.updateDisplay();
          this.updateCustomPaperSizeDisplays();
        }

        /**
         * @method updateCalculations
         * @description Calculates all exposure factors and final adjusted time.
         * Applies inverse square law for height and f-stop, area ratio for paper size,
         * and multiplies by filter factors.
         * @returns {void}
         * @description Formula: New Time = Original Time × Height² × F-Stop² × Paper Area × Filter × Custom
         * @fires Math.pow - For squared calculations
         * @fires paperTypes - Reads filter data from paper database
         * @example
         * this.updateCalculations(); // Recalculate all factors
         */
        updateCalculations() {
          // Height factor: (newHeight ÷ originalHeight)²
          if (this.originalHeight > 0) {
            this.heightFactor = Math.pow(
              this.newHeight / this.originalHeight,
              2,
            );
          } else {
            this.heightFactor = 1.0;
          }

          // F-stop factor: (New F-Stop ÷ Original F-Stop)²
          if (this.newFStop > 0) {
            this.fstopFactor = Math.pow(this.newFStop / this.originalFStop, 2);
          } else {
            this.fstopFactor = 1.0;
          }

          // Paper size factor: New Paper Area ÷ Original Paper Area
          if (this.originalPaperSize > 0) {
            // CORRECT: (√New Paper Area ÷ √Original Paper Area)² = New Paper Area ÷ Original Paper Area
            // This is actually mathematically the same as newPaperSize / originalPaperSize
            // The issue was with the VALUES, not the formula!
            this.paperSizeFactor = this.newPaperSize / this.originalPaperSize;
          } else {
            this.paperSizeFactor = 1.0;
          }

          // Filter factor comes from contrast control selection
          let filterData;
          // Use paper-specific data for both FOMA and Ilford
          const paper = this.paperTypes[this.currentPaper];
          filterData = paper?.filters?.[this.currentFilter];

          if (filterData) {
            this.filterFactor = filterData.factor;
          } else {
            this.filterFactor = 1.0;
          }

          // Combined factor includes ALL factors plus custom bank factor
          this.combinedFactor =
            this.heightFactor *
            this.fstopFactor *
            this.paperSizeFactor *
            this.filterFactor *
            this.customBankFactor;
          this.newAdjustedTime = this.originalTime * this.combinedFactor;
        }

        /**
         * @method updateDisplay
         * @description Updates all UI elements with current calculation results.
         * Displays factors, times, and filter data. Updates button text with calculation summary.
         * @returns {void}
         * @fires Element.textContent - Updates all display elements
         * @fires Element.classList - Updates button states
         * @example
         * this.updateDisplay(); // Refresh all UI displays
         */
        updateDisplay() {
          // Update height displays with one decimal
          this.originalHeightValue.textContent = `${this.originalHeight.toFixed(
            1,
          )}`;
          this.newHeightValue.textContent = `${this.newHeight.toFixed(1)}`;
          this.originalTimeValue.textContent = this.originalTime.toFixed(2);
          this.heightFactorElement.textContent = `${this.heightFactor.toFixed(
            2,
          )}x`;
          this.fstopFactorElement.textContent = `${this.fstopFactor.toFixed(
            2,
          )}x`;
          document.getElementById("paperSizeFactor").textContent =
            `${this.paperSizeFactor.toFixed(2)}x`;
          this.filterFactorValueDisplay.textContent = `${this.filterFactor.toFixed(
            2,
          )}x`;
          this.combinedFactorElement.textContent = `${this.combinedFactor.toFixed(
            2,
          )}x`;
          this.newAdjustedTimeElement.textContent =
            this.newAdjustedTime.toFixed(2);

          // Update contrast control displays from selected paper/filter only
          let filterData;
          // Use paper-specific data for both FOMA and Ilford
          const paper = this.paperTypes[this.currentPaper];
          filterData = paper?.filters?.[this.currentFilter];

          if (filterData) {
            // Show ISO R for both FOMA and Ilford
            this.isoValueElement.textContent = filterData.iso;
            this.filterFactorValueElement.textContent = `${filterData.factor.toFixed(
              1,
            )}×`;
          }

          // Update custom bank factor display
          if (this.customBankFactorDisplay) {
            this.customBankFactorDisplay.textContent = `${this.customBankFactor.toFixed(
              2,
            )}x`;
          }

          // Update button text to show calculation
          const timeDiff = ((this.combinedFactor - 1) * 100).toFixed(0);
          const direction = this.combinedFactor > 1 ? "increase" : "decrease";

          if (this.combinedFactor !== 1.0) {
            this.applyHeightTimeBtn.textContent = `Apply ${this.newAdjustedTime.toFixed(
              1,
            )}s (${direction} ${Math.abs(timeDiff)}%)`;
          } else {
            this.applyHeightTimeBtn.textContent =
              "Apply Adjusted Time as Base Time";
          }
        }

        /**
         * @method applyCustomFilterFactor
         * @description Applies a custom filter factor from a filter bank.
         * Updates the custom factor and recalculates exposure.
         * @param {string} label - Name of the custom filter
         * @param {string|number} value - Filter factor multiplier
         * @returns {void}
         * @fires updateCalculations - Recalculates with new factor
         * @fires updateDisplay - Updates UI
         * @example
         * this.applyCustomFilterFactor('Custom Bank 1', '1.5'); // Apply 1.5x factor
         */
        applyCustomFilterFactor(label, value) {
          const factor = parseFloat(value);
          if (!factor || factor <= 0) return;
          this.customBankLabel = label || "Custom";
          this.customBankFactor = factor;
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method clearCustomFilterOverride
         * @description Clears any custom filter factor override.
         * Resets custom factor to 1.0 and clears label.
         * @returns {void}
         * @fires updateCalculations - Recalculates without custom factor
         * @fires updateDisplay - Updates UI
         * @example
         * this.clearCustomFilterOverride(); // Remove custom filter factor
         */
        clearCustomFilterOverride() {
          this.customBankLabel = "";
          this.customBankFactor = 1.0;
          this.updateCalculations();
          this.updateDisplay();
        }

        /**
         * @method applyNewTime
         * @description Applies calculated time to CALC tab base time slider.
         * Clamps time to 1-50 seconds range, updates slider, and triggers calculator update.
         * @returns {void}
         * @fires baseTimeSlider.value - Updates base time slider
         * @fires incrementalTimer.updateFromSliders - Syncs calculator
         * @fires playBeep - Audio feedback
         * @fires setTimeout - Visual button feedback
         * @example
         * this.applyNewTime(); // Apply calculated time to CALC tab
         */
        applyNewTime() {
          const newBaseTime = this.newAdjustedTime;
          const baseTimeSlider = document.getElementById("baseTimeSlider");
          const clampedTime = Math.max(1, Math.min(50, newBaseTime));
          baseTimeSlider.value = clampedTime.toFixed(1);

          this.incrementalTimer.updateFromSliders();
          playBeep(800, 0.1, 0.3);

          const btn = this.applyHeightTimeBtn;
          const originalText = btn.textContent;
          btn.textContent = "Applied!";
          btn.classList.add("active");

          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove("active");
          }, 1000);
        }
      }

      /**
       * @class CustomFilterBankManager
       * @classdesc Manages custom filter banks for contrast control in exposure calculations.
       * Provides user-defined filter factors that can be applied to the EnlargerHeightCalculator.
       * Supports 3 groups (A, B, C) with 12 slots each for storing custom contrast factors.
       *
       * @property {EnlargerHeightCalculator} calculator - Reference to main calculator
       * @property {Array} groups - Array of filter bank groups (max 3)
       * @property {number} currentGroupIndex - Currently selected group (0-2)
       * @property {HTMLElement} groupSelect - Dropdown for group selection
       * @property {HTMLElement} groupNameInput - Input for group name
       * @property {HTMLElement} rowsContainer - Container for filter rows
       *
       * @description
       * **Purpose:** Allows users to store custom contrast factors (e.g., for variable contrast papers,
       * custom filter sets, or experimental multipliers) and quickly apply them to calculations.
       *
       * **Structure:**
       * - 3 Groups (A, B, C) - Each can have a custom name
       * - 12 Slots per group - Each slot has a label and value (factor)
       * - Values persist in localStorage via StorageManager
       * - Can be exported/imported with all app data
       *
       * **Integration:**
       * - Connects to EnlargerHeightCalculator via applyCustomFilterFactor()
       * - Updates calculator's customBankFactor and customBankLabel
       * - Multiplies into combined factor: Custom Factor × Other Factors
       *
       * @example
       * // Initialize manager
       * const filterManager = new CustomFilterBankManager(heightCalculator);
       *
       * // Apply a custom factor
       * filterManager.calculator.applyCustomFilterFactor('My Filter', 1.5);
       *
       * // Save custom bank data
       * filterManager.save();
       */
      class CustomFilterBankManager {
        /**
         * @constructor
         * @description Creates a CustomFilterBankManager instance.
         * Loads saved filter banks from localStorage, initializes UI elements,
         * and sets up event listeners.
         * @param {EnlargerHeightCalculator} enlargerCalculator - Reference to main calculator
         * @property {Function} normalize - Validates and normalizes bank data
         * @property {Function} bindEvents - Sets up UI event listeners
         * @property {Function} render - Updates UI display
         */
        constructor(enlargerCalculator) {
          this.calculator = enlargerCalculator;
          this.groups = this.normalize(StorageManager.loadCustomFilterBanks());
          this.currentGroupIndex = 0;

          this.groupSelect = document.getElementById("customFilterGroup");
          this.groupNameInput = document.getElementById(
            "customFilterGroupName",
          );
          this.rowsContainer = document.getElementById("customFilterRows");

          this.bindEvents();
          this.render();
        }

        /**
         * @method normalize
         * @description Validates and normalizes filter bank data from localStorage.
         * Ensures data structure is valid, pads to 3 groups with 12 slots each,
         * and applies default values where needed.
         * @param {Array} banks - Raw bank data from storage
         * @returns {Array} Normalized array of 3 groups with 12 slots each
         * @fires getDefaultCustomFilterBanks - Gets default structure
         * @example
         * const normalized = this.normalize(rawData); // Validate and pad data
         */
        normalize(banks) {
          const defaults = getDefaultCustomFilterBanks();
          if (!Array.isArray(banks)) return defaults;

          const normalized = banks.slice(0, 3).map((group, idx) => {
            const base = defaults[idx] || defaults[0];
            const name =
              (group && typeof group.name === "string" && group.name.trim()) ||
              base.name;
            const slots = Array.isArray(group?.slots) ? group.slots : [];
            const paddedSlots = [...slots];
            while (paddedSlots.length < 12) {
              paddedSlots.push({
                label: base.slots[paddedSlots.length].label,
                value: 1.0,
              });
            }
            return {
              name,
              slots: paddedSlots.slice(0, 12).map((slot, slotIdx) => ({
                label:
                  (slot &&
                    typeof slot.label === "string" &&
                    slot.label.trim()) ||
                  base.slots[slotIdx].label,
                value:
                  typeof slot?.value === "number" && slot.value > 0
                    ? slot.value
                    : 1.0,
              })),
            };
          });

          while (normalized.length < 3) {
            normalized.push(defaults[normalized.length]);
          }

          return normalized;
        }

        /**
         * @method bindEvents
         * @description Sets up all UI event listeners for the filter bank interface.
         * Handles group selection, name changes, slot value updates, and "Use" button clicks.
         * @returns {void}
         * @fires addEventListener - Binds change/input/click events
         * @fires renderGroupHeader - Updates group display
         * @fires renderRows - Updates slot rows
         * @fires save - Persists changes
         * @fires calculator.applyCustomFilterFactor - Applies factor to calculator
         * @example
         * this.bindEvents(); // Set up all UI interactions
         */
        bindEvents() {
          if (this.groupSelect) {
            this.groupSelect.addEventListener("change", () => {
              this.currentGroupIndex =
                parseInt(this.groupSelect.value, 10) || 0;
              this.renderGroupHeader();
              this.renderRows();
            });
          }

          if (this.groupNameInput) {
            this.groupNameInput.addEventListener("input", (e) => {
              const name = e.target.value || "Group";
              this.groups[this.currentGroupIndex].name = name;
              this.save();
              this.renderGroupHeader();
            });
          }

          if (this.rowsContainer) {
            this.rowsContainer.addEventListener("input", (e) => {
              const row = e.target.closest(".custom-filter-row");
              if (!row) return;
              const idx = parseInt(row.getAttribute("data-index"), 10);
              const role = e.target.getAttribute("data-role");
              if (Number.isNaN(idx) || idx < 0 || idx >= 12) return;

              if (role === "name") {
                this.groups[this.currentGroupIndex].slots[idx].label =
                  e.target.value || `Slot ${idx + 1}`;
                this.save();
              } else if (role === "value") {
                const val = parseFloat(e.target.value);
                if (val && val > 0) {
                  this.groups[this.currentGroupIndex].slots[idx].value = val;
                  this.save();
                }
              }
            });

            this.rowsContainer.addEventListener("click", (e) => {
              const btn = e.target.closest("button[data-role='use']");
              if (!btn) return;
              const row = btn.closest(".custom-filter-row");
              if (!row) return;
              const idx = parseInt(row.getAttribute("data-index"), 10);
              const slot = this.groups[this.currentGroupIndex].slots[idx];
              if (!slot) return;
              this.calculator.applyCustomFilterFactor(
                slot.label || `Slot ${idx + 1}`,
                slot.value,
              );
              btn.textContent = "Using";
              btn.disabled = true;
              setTimeout(() => {
                btn.textContent = "Use";
                btn.disabled = false;
              }, 800);
            });
          }
        }

        /**
         * @method render
         * @description Updates the entire UI display for the filter bank.
         * Calls renderGroupHeader() and renderRows() to update all visual elements.
         * @returns {void}
         * @fires renderGroupHeader - Updates group selector and name
         * @fires renderRows - Updates slot rows
         * @example
         * this.render(); // Refresh entire UI
         */
        render() {
          this.renderGroupHeader();
          this.renderRows();
        }

        /**
         * @method renderGroupHeader
         * @description Updates the group selector dropdown and name input.
         * Populates options for all 3 groups and sets current group name.
         * @returns {void}
         * @fires Element.innerHTML - Updates group selector options
         * @fires Element.value - Updates name input value
         * @example
         * this.renderGroupHeader(); // Update group display
         */
        renderGroupHeader() {
          if (!this.groupSelect || !this.groupNameInput) return;
          this.groupSelect.innerHTML = this.groups
            .map(
              (g, idx) =>
                `<option value="${idx}" ${
                  idx === this.currentGroupIndex ? "selected" : ""
                }>${g.name || `Group ${idx + 1}`}</option>`,
            )
            .join("");
          const current = this.groups[this.currentGroupIndex];
          this.groupNameInput.value = current.name;
        }

        /**
         * @method renderRows
         * @description Renders all 12 filter slots for the current group.
         * Creates HTML for each slot with name input, value input, and "Use" button.
         * @returns {void}
         * @fires Element.innerHTML - Updates rows container
         * @example
         * this.renderRows(); // Update slot display
         */
        renderRows() {
          if (!this.rowsContainer) return;
          const current = this.groups[this.currentGroupIndex];
          const rowsHtml = current.slots
            .map(
              (slot, idx) => `
                <div class="custom-filter-row" data-index="${idx}">
                  <input
                    type="text"
                    data-role="name"
                    value="${slot.label || `Slot ${idx + 1}`}"
                    aria-label="Custom filter name ${idx + 1}"
                  />
                  <input
                    type="number"
                    data-role="value"
                    step="0.01"
                    min="0.001"
                    value="${(slot.value || 1).toFixed(2)}"
                    aria-label="Custom filter value ${idx + 1}"
                  />
                  <button type="button" data-role="use">Use</button>
                </div>
              `,
            )
            .join("");
          this.rowsContainer.innerHTML = rowsHtml;
        }

        /**
         * @method save
         * @description Saves current filter bank data to localStorage.
         * Persists all groups and slots via StorageManager.
         * @returns {void}
         * @fires StorageManager.saveCustomFilterBanks - Saves to localStorage
         * @example
         * this.save(); // Persist changes
         */
        save() {
          StorageManager.saveCustomFilterBanks(this.groups);
        }

        /**
         * @method replaceData
         * @description Replaces all filter bank data (used during import).
         * Normalizes new data, resets to first group, and updates UI.
         * @param {Array} banks - New filter bank data
         * @returns {void}
         * @fires normalize - Validates and normalizes data
         * @fires render - Updates UI
         * @example
         * // During data import
         * this.replaceData(importedBanks);
         */
        replaceData(banks) {
          this.groups = this.normalize(banks);
          this.currentGroupIndex = 0;
          this.render();
        }
      }

      // F-Stop Test Strip Generator Class with both Cumulative and Incremental methods and countdown AND AUTO ADVANCE
      // F-Stop Test Strip Generator - Profile Management Functions
      // These need to be defined before the class for proper scope access
      function getSelectedFromSeg(containerId) {
        const cont = document.getElementById(containerId);
        if (!cont) return null;
        const btn =
          cont.querySelector(".segmented-btn.active") ||
          cont.querySelector('.segmented-btn[aria-pressed="true"]');
        return btn ? parseInt(btn.dataset.denom, 10) : null;
      }
      function setActiveSeg(containerOrId, d) {
        const cont =
          typeof containerOrId === "string"
            ? document.getElementById(containerOrId)
            : containerOrId;
        if (!cont) return;
        Array.from(cont.querySelectorAll(".segmented-btn")).forEach((b) => {
          const bd = parseInt(b.dataset.denom, 10);
          const active = bd === d;
          b.classList.toggle("active", active);
          b.setAttribute("aria-pressed", active ? "true" : "false");
        });
      }
      function initSegControl(containerId) {
        const cont = document.getElementById(containerId);
        if (!cont) return;
        cont.addEventListener("click", (e) => {
          const btn = e.target.closest(".segmented-btn");
          if (!btn) return;
          const d = parseInt(btn.dataset.denom, 10);
          setActiveSeg(cont, d);
          applyDenomChange(d);
        });
      }

      // applyDenomChange now takes numeric denom and rescales sliders to preserve absolute stop values
      function applyDenomChange(d) {
        const newDenom = parseInt(d, 10) || 3;
        const prevDenom =
          window.stopDenominator ||
          (settingsManager && settingsManager.settings.stopDenominator) ||
          3;

        // If denom changed, rescale relevant sliders so the same absolute stop is preserved
        if (newDenom !== prevDenom) {
          // Rescale calculator stop slider (stopSlider values are fractional-step counts)
          const stopSlider = document.getElementById("stopSlider");
          if (stopSlider) {
            const oldVal = parseInt(stopSlider.value, 10) || 0;
            const stopInStops = oldVal / prevDenom; // current stop in full stops
            const newVal = Math.round(stopInStops * newDenom);
            stopSlider.value = newVal;
            // Trigger input handler to update displays
            stopSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }

          // Rescale test increment slider (step increments expressed in fractional-step counts)
          const testInc = document.getElementById("testIncrementSlider");
          if (testInc) {
            const oldInc = parseInt(testInc.value, 10) || 0;
            const incInStops = oldInc / prevDenom;
            let newInc = Math.round(incInStops * newDenom);
            const min = parseInt(testInc.min, 10) || 1;
            const max = parseInt(testInc.max, 10) || 99;
            newInc = Math.max(min, Math.min(max, newInc));
            testInc.value = newInc;
            testInc.dispatchEvent(new Event("input", { bubbles: true }));
          }
        }

        window.stopDenominator = newDenom;

        // Persist setting and keep UI in sync
        if (settingsManager) {
          settingsManager.settings.stopDenominator = newDenom;
          StorageManager.saveSettings(settingsManager.settings);
        }
        const settingsSel = document.getElementById("settingStopIncrement");
        if (settingsSel) settingsSel.value = newDenom;
        // Update assistive live region
        try {
          const live = document.getElementById("settingsLiveStatus");
          if (live)
            live.textContent = `Default stop increment set to ${denomLabel(
              newDenom,
            )}`;
        } catch (e) {}

        // Reflect change in segmented controls (if not already set) - keeps buttons active
        setActiveSeg("calcIncrementSeg", newDenom);
        setActiveSeg("testIncrementSeg", newDenom);

        if (window.incrementalTimer) {
          window.incrementalTimer.updateCalculations();
          window.incrementalTimer.updateAllDisplays();
        }
        if (window.fstopTestGenerator) {
          window.fstopTestGenerator.generateSteps();
          window.fstopTestGenerator.updateDisplay();
        }
        updateAllRulers();
        updateChart();
      }

      // Helper: render/refresh rulers and denominator handling for stops
      /**
       * @function renderRuler
       * @description Renders a visual ruler showing f-stop values between min and max steps.
       * Creates a horizontal scale with formatted stop values for visual reference.
       * @param {string} containerId - ID of the container element to render ruler in
       * @param {number} minStep - Minimum stop value (can be negative)
       * @param {number} maxStep - Maximum stop value
       * @returns {void}
       * @throws {Error} If container not found
       * @fires Element.setAttribute - Sets aria-label
       * @fires Element.innerHTML - Clears and rebuilds ruler
       * @fires formatStop - Formats stop values for display
       * @example
       * renderRuler("calcStopRuler", -6, 6); // Render ruler from -6 to +6 stops
       */
      function renderRuler(containerId, minStep, maxStep) {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.setAttribute("aria-label", "Stops scale");
        const total = maxStep - minStep;
        const frag = document.createDocumentFragment();
        for (let i = 0; i <= total; i++) {
          const step = minStep + i;
          const span = document.createElement("span");
          span.style.fontSize = "0.7rem";
          span.style.color = "var(--text-secondary)";
          span.style.flex = "1";
          span.style.textAlign = "center";
          span.textContent = formatStop(step);
          span.setAttribute("aria-hidden", "true");
          frag.appendChild(span);
        }
        container.innerHTML = "";
        container.appendChild(frag);
      }

      /**
       * @function updateAllRulers
       * @description Updates all visual rulers in the UI.
       * Renders the calculator stop ruler and test increment ruler with current settings.
       * @returns {void}
       * @fires renderRuler - Renders calculator ruler
       * @fires Element.getElementById - Gets test increment ruler
       * @fires Element.innerHTML - Clears and rebuilds rulers
       * @fires formatStopCompact - Formats stop values for compact display
       * @fires window.stopDenominator - Reads current denominator setting
       * @example
       * updateAllRulers(); // Update all visual rulers
       */
      function updateAllRulers() {
        renderRuler("calcStopRuler", -6, 6);

        const testContainer = document.getElementById("testIncrementRuler");
        if (!testContainer) return;
        const min = parseInt(
          document.getElementById("testIncrementSlider").min,
          10,
        );
        const max = parseInt(
          document.getElementById("testIncrementSlider").max,
          10,
        );
        const total = max - min;
        const frag = document.createDocumentFragment();
        for (let i = 0; i <= total; i++) {
          const val = min + i;
          const span = document.createElement("span");
          span.style.fontSize = "0.7rem";
          span.style.color = "var(--text-secondary)";
          span.style.flex = "1";
          span.style.textAlign = "center";
          const denom = window.stopDenominator || 3;
          const stopValue = val / denom;
          span.textContent = formatStopCompact(stopValue);
          frag.appendChild(span);
        }
        testContainer.innerHTML = "";
        testContainer.appendChild(frag);
      }

      /**
       * @class FStopTestStripGenerator
       * @classdesc Generates and manages f-stop test strips with cumulative or incremental methods.
       * Supports auto-advance mode, countdown integration, relay triggering, and profile management.
       *
       * @property {number} baseTime - Base exposure time in seconds
       * @property {number} stepIncrement - Increment value (1-9)
       * @property {number} numSteps - Number of test steps (default: 6)
       * @property {string} method - 'cumulative' or 'incremental'
       * @property {boolean} autoAdvance - Auto-advance between steps
       * @property {number} autoAdvanceDelay - Delay between steps in milliseconds
       * @property {Array} steps - Generated test steps array
       * @property {number} currentStep - Current step index (0-based)
       * @property {number} currentStepTime - Time remaining in current step
       * @property {boolean} isRunning - Test is running
       * @property {boolean} isPaused - Test is paused
       * @property {boolean} isWaitingForNextStep - Waiting for user to proceed
       * @property {DriftCorrectedTimer|null} interval - Timer instance
       * @property {number|null} lastBeepSecond - Last second that beep played
       * @property {Object|null} countdownCleanup - Stores display state during countdown
       *
       * @description
       * **Test Strip Methods:**
       * - **Cumulative**: Each strip is exposed for its total time (10s, 14s, 19s, etc.)
       * - **Incremental**: Each strip adds time to previous (10s, 4s, 5s, etc.)
       *
       * **F-Stop Formula**: time = baseTime × 2^(stop/denominator)
       *
       * **Auto-Advance**: Automatically proceeds to next step after configurable delay
       *
       * **Integration:**
       * - Uses CountdownManager before starting
       * - Triggers RelayManager for each step
       * - Click-to-apply: Click steps to send time to CALC tab
       * - Profile management: Save/load test configurations
       *
       * @example
       * // Initialize generator
       * const testGen = new FStopTestStripGenerator();
       *
       * // Generate and display test strip
       * testGen.generateSteps();
       * testGen.updateDisplay();
       *
       * // Start test
       * await testGen.start();
       *
       * // Apply step to CALC tab
       * testGen.applyStepToCalc(2); // Apply 3rd step time
       */
      class FStopTestStripGenerator {
        /**
         * @constructor
         * @description Creates a FStopTestStripGenerator instance.
         * Initializes all properties, generates steps, updates UI, and loads profiles.
         * @property {number} baseTime - Base exposure time (default: 10.0s)
         * @property {number} stepIncrement - Increment in fractional steps (default: 1)
         * @property {number} numSteps - Number of test steps (default: 6)
         * @property {string} method - 'cumulative' or 'incremental' (default: 'cumulative')
         * @property {boolean} autoAdvance - Auto-advance mode (default: false)
         * @property {number} autoAdvanceDelay - Delay in ms (default: 1000)
         */
        constructor() {
          this.baseTime = 10.0;
          this.stepIncrement = 1; // 1 = one fractional step (denominator controlled by stopDenominator)
          // Denominator applied in calculations; default to 3 (1/3 stop)
          window.stopDenominator = window.stopDenominator || 3;
          this.numSteps = 6;
          this.method = "cumulative"; // 'cumulative' or 'incremental'
          this.autoAdvance = false; // NEW: Auto advance mode
          this.autoAdvanceDelay = 1000; // Delay between steps in ms
          this.transferDestination = "calc"; // NEW: 'calc' or 'split'

          if (settingsManager) {
            this.autoAdvance = settingsManager.settings.autoAdvance || false;
            this.autoAdvanceDelay =
              (settingsManager.settings.autoAdvanceDelay || 1) * 1000; // Convert to ms
            this.transferDestination =
              settingsManager.settings.testTransferDestination || "calc";
          } else {
            this.autoAdvance = false;
            this.autoAdvanceDelay = 1000; // Default 1 second
            this.transferDestination = "calc";
          }

          this.currentStep = 0;
          this.steps = [];
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.interval = null;
          this.lastBeepSecond = null;
          this.currentStepTime = 0;

          this.init();
          this.generateSteps();
          this.updateDisplay();
          this.updateInstructions();

          // Initialize countdown cleanup properties
          this.countdownCleanup = null;
          this.countdownCleanupTimeout = null;

          // Load current test strip profile from storage
          appState.persistent.currentTestStripProfile =
            StorageManager.loadCurrentTestStripProfile();

          // Initialize test strip profile list
          this.updateTestStripProfileList();
        }

        /**
         * @method init
         * @description Initializes UI elements and event listeners for test strip generator.
         * Binds all sliders, buttons, toggles, and method selectors to their handlers.
         * @returns {void}
         * @fires addEventListener - Binds input/change/click events
         * @fires updateFromControls - Called by sliders
         * @fires toggle - Called by start/pause button
         * @fires stopCurrentTest - Called by stop button
         * @fires reset - Called by reset button
         * @fires setMethod - Called by method selector
         * @fires setAutoAdvance - Called by auto-advance toggle
         * @example
         * this.init(); // Set up all UI bindings
         */
        init() {
          // Get elements
          this.testBaseSlider = document.getElementById("testBaseSlider");
          this.testIncrementSlider = document.getElementById(
            "testIncrementSlider",
          );
          this.testStepsSlider = document.getElementById("testStepsSlider");
          this.testBaseValue = document.getElementById("testBaseValue");
          this.testIncrementValue =
            document.getElementById("testIncrementValue");
          this.testStepsValue = document.getElementById("testStepsValue");
          this.testSequenceInfo = document.getElementById("testSequenceInfo");
          this.testTimeRange = document.getElementById("testTimeRange");
          this.testStripPreview = document.getElementById("testStripPreview");

          // NEW: Auto advance toggle elements
          this.autoAdvanceToggle = document.getElementById("autoAdvanceToggle");
          this.autoAdvanceValue = document.getElementById("autoAdvanceValue");
          this.autoAdvanceDescription = document.getElementById(
            "autoAdvanceDescription",
          );

          // Timer elements
          this.testTimerStatus = document.getElementById("testTimerStatus");
          this.testTimerDisplay = document.getElementById("testTimerDisplay");
          this.currentStepDisplay =
            document.getElementById("currentStepDisplay");
          this.currentTimeDisplay =
            document.getElementById("currentTimeDisplay");
          this.currentStopDisplay =
            document.getElementById("currentStopDisplay");
          this.stepSizeDisplay = document.getElementById("stepSizeDisplay");
          this.timeMultiplierDisplay = document.getElementById(
            "timeMultiplierDisplay",
          );
          this.totalTestTimeDisplay = document.getElementById(
            "totalTestTimeDisplay",
          );
          this.testProgressBar = document.getElementById("testProgressBar");
          this.progressStart = document.getElementById("progressStart");
          this.progressMiddle = document.getElementById("progressMiddle");
          this.progressEnd = document.getElementById("progressEnd");

          // Control buttons
          this.startTestStripBtn = document.getElementById("startTestStrip");
          this.stopTestTimerBtn = document.getElementById("stopTestTimer");
          this.resetTestTimerBtn = document.getElementById("resetTestTimer");

          // Sound controls (removed from TEST tab)
          this.testWarningBeep = document.getElementById("testWarningBeep");
          this.testStepBeep = document.getElementById("testStepBeep");
          this.testEndBeep = document.getElementById("testEndBeep");

          // Preview controls
          this.previewMode = document.getElementById("previewMode");

          // Add event listeners
          this.testBaseSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );
          this.testIncrementSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );
          this.testStepsSlider.addEventListener("input", () =>
            this.updateFromControls(),
          );

          // NEW: Auto advance toggle event
          this.autoAdvanceToggle.addEventListener("change", () => {
            this.setAutoAdvance(this.autoAdvanceToggle.checked);
          });

          // In the init() method of FStopTestStripGenerator (around line 2300), update the startTestStripBtn event listener:
          this.startTestStripBtn.addEventListener("click", async () => {
            await this.toggle();
          });
          this.stopTestTimerBtn.addEventListener("click", () =>
            this.stopCurrentTest(),
          );
          this.resetTestTimerBtn.addEventListener("click", () => this.reset());

          this.previewMode.addEventListener("change", () =>
            this.updatePreview(),
          );

          // Method selector event listeners
          document
            .querySelectorAll(".toggle-btn[data-method]")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                const method = e.target.getAttribute("data-method");
                this.setMethod(method);
              });
            });

          // Audio context initialization
          this.startTestStripBtn.addEventListener("click", initAudioContext);

          // NEW: Transfer destination selection event listener (container-based)
          const transferSeg = document.getElementById("transferDestinationSeg");
          if (transferSeg) {
            transferSeg.addEventListener("click", (e) => {
              const btn = e.target.closest(".segmented-btn");
              if (btn && btn.dataset.destination) {
                this.setTransferDestination(btn.dataset.destination);
              }
            });
          }

          // Initialize UI with current destination
          this.updateTransferDestinationUI();
        }

        /**
         * @method setAutoAdvance
         * @description Enables or disables auto-advance mode.
         * When enabled, automatically proceeds to next step after configured delay.
         * @param {boolean} enabled - Whether to enable auto-advance
         * @returns {void}
         * @fires updateAutoAdvanceDisplay - Updates UI
         * @fires updateInstructions - Updates help text
         * @fires nextStep - If currently waiting between steps
         * @example
         * this.setAutoAdvance(true); // Enable auto-advance
         * this.setAutoAdvance(false); // Disable auto-advance
         */
        setAutoAdvance(enabled) {
          this.autoAdvance = enabled;
          this.updateAutoAdvanceDisplay();
          this.updateInstructions();

          // If test is running and auto advance is enabled, check if we should proceed
          if (this.isRunning && !this.isPaused && this.autoAdvance) {
            // If we're currently paused between steps, start next step
            if (
              this.currentStepTime <= 0 &&
              this.currentStep < this.steps.length - 1
            ) {
              this.nextStep();
            }
          }
        }

        /**
         * @method setAutoAdvanceDelay
         * @description Sets the delay between steps in auto-advance mode.
         * @param {number} delayMs - Delay in milliseconds
         * @returns {void}
         * @fires updateAutoAdvanceDisplay - Updates UI
         * @fires updateInstructions - Updates help text
         * @example
         * this.setAutoAdvanceDelay(2000); // 2 second delay
         */
        setAutoAdvanceDelay(delayMs) {
          this.autoAdvanceDelay = delayMs;
          this.updateAutoAdvanceDisplay();
          this.updateInstructions();
        }

        /**
         * @method updateAutoAdvanceDisplay
         * @description Updates the auto-advance UI display elements.
         * Shows ON/OFF status, delay time, and updates toggle state.
         * @returns {void}
         * @fires Element.textContent - Updates status text
         * @fires Element.checked - Updates toggle state
         * @example
         * this.updateAutoAdvanceDisplay(); // Refresh UI
         */
        updateAutoAdvanceDisplay() {
          if (this.autoAdvanceValue) {
            this.autoAdvanceValue.textContent = this.autoAdvance ? "ON" : "OFF";
          }
          if (this.autoAdvanceDescription) {
            const delaySec = this.autoAdvanceDelay / 1000;
            this.autoAdvanceDescription.textContent = this.autoAdvance
              ? `Automatically advance to next step (${delaySec}s delay)`
              : "Pause after each step";
          }
          if (this.autoAdvanceToggle) {
            this.autoAdvanceToggle.checked = this.autoAdvance;
          }
        }

        /**
         * @method updateInstructions
         * @description Updates instruction text based on method and auto-advance mode.
         * Shows different instructions for cumulative vs incremental methods.
         * Theme-aware styling for status text.
         * @returns {void}
         * @fires Element.textContent - Updates instruction text
         * @fires Element.style.color - Updates theme-aware colors
         * @example
         * this.updateInstructions(); // Refresh instruction display
         */
        updateInstructions() {
          const cumulativeText = document.getElementById(
            "cumulativeAdvanceText",
          );
          const incrementalText = document.getElementById(
            "incrementalAdvanceText",
          );
          const statusText = document.getElementById("autoAdvanceStatus");

          const delaySec = this.autoAdvanceDelay / 1000;

          if (this.autoAdvance) {
            cumulativeText.textContent = `Auto-advance: ON - Next step starts in ${delaySec}s`;
            incrementalText.textContent = `Auto-advance: ON - Slide mask, next step in ${delaySec}s`;
            statusText.textContent = `Current: Auto Advance (${delaySec}s delay)`;
          } else {
            cumulativeText.textContent =
              "Auto-advance: OFF - Press Next Step between exposures";
            incrementalText.textContent =
              "Auto-advance: OFF - Press Next Step after sliding mask";
            statusText.textContent =
              "Current: Manual Advance - press Next Step button";
          }

          // Update status text color based on theme
          if (document.body.classList.contains("light-scheme")) {
            statusText.style.color = this.autoAdvance
              ? "var(--accent)"
              : "var(--accent)";
          } else if (document.body.classList.contains("day-scheme")) {
            statusText.style.color = this.autoAdvance
              ? "var(--accent)"
              : "var(--accent)";
          } else {
            statusText.style.color = this.autoAdvance ? "#f00" : "#900";
          }
        }

        /**
         * @method setMethod
         * @description Sets the test strip method (cumulative or incremental).
         * Updates UI, regenerates steps, and resets if test is running.
         * @param {string} method - 'cumulative' or 'incremental'
         * @returns {void}
         * @fires generateSteps - Regenerates test steps
         * @fires updateDisplay - Updates UI
         * @fires updateInstructions - Updates help text
         * @fires stopCurrentTest - Stops running test
         * @fires reset - Resets test state
         * @example
         * this.setMethod('cumulative'); // Use cumulative method
         * this.setMethod('incremental'); // Use incremental method
         */
        setMethod(method) {
          if (this.method === method) return;

          this.method = method;

          // Update UI
          document
            .querySelectorAll(".toggle-btn[data-method]")
            .forEach((btn) => {
              btn.classList.remove("active");
              if (btn.getAttribute("data-method") === method) {
                btn.classList.add("active");
              }
            });

          document.getElementById("testMethodValue").textContent =
            method === "cumulative" ? "Cumulative" : "Incremental";

          // Show appropriate instructions
          if (method === "cumulative") {
            document.querySelector(".cumulative-instructions").style.display =
              "block";
            document.querySelector(".incremental-instructions").style.display =
              "none";
          } else {
            document.querySelector(".cumulative-instructions").style.display =
              "none";
            document.querySelector(".incremental-instructions").style.display =
              "block";
          }

          // Regenerate steps with new method
          this.generateSteps();
          this.updateDisplay();
          this.updateInstructions();

          // If running, stop and reset
          if (this.isRunning || this.isPaused) {
            this.stopCurrentTest();
            this.reset();
          }
        }

        /**
         * @method updateFromControls
         * @description Reads slider values and updates test strip configuration.
         * Regenerates steps and updates display.
         * @returns {void}
         * @fires generateSteps - Regenerates test steps
         * @fires updateDisplay - Updates UI
         * @example
         * // Called when sliders change
         * this.updateFromControls();
         */
        updateFromControls() {
          this.baseTime = parseFloat(this.testBaseSlider.value);
          this.stepIncrement = parseInt(this.testIncrementSlider.value);
          this.numSteps = parseInt(this.testStepsSlider.value);

          this.generateSteps();
          this.updateDisplay();
        }

        /**
         * @method generateSteps
         * @description Generates test strip steps based on current parameters.
         * Supports both cumulative and incremental methods with f-stop precision.
         * @returns {void}
         * @fires window.stopDenominator - Reads denominator setting
         * @fires Math.pow - Calculates f-stop times
         * @description Step Structure:
         * - step: Step number (1-based)
         * - stop: F-stop value
         * - time: Time for this step (incremental or cumulative)
         * - cumulativeTime: Total time (cumulative method only)
         * - incrementalTime: Time for this step (incremental method)
         * - totalExposure: Total exposure on paper
         * @example
         * this.generateSteps(); // Regenerate steps after parameter change
         */
        generateSteps() {
          this.steps = [];

          if (this.method === "cumulative") {
            // Existing cumulative method
            let totalTime = 0;
            for (let i = 0; i < this.numSteps; i++) {
              const denom = window.stopDenominator || 3;
              const stopValue = (i * this.stepIncrement) / denom; // Convert to stop value
              const time = this.baseTime * Math.pow(2, stopValue);
              totalTime += time;

              this.steps.push({
                step: i + 1,
                stop: stopValue,
                time: time,
                cumulativeTime: totalTime,
                incrementalTime: time, // Same as time for cumulative
                totalExposure: time, // Total exposure for this step
              });
            }
          } else {
            // New incremental method
            let previousTotalTime = this.baseTime;

            for (let i = 0; i < this.numSteps; i++) {
              const denom = window.stopDenominator || 3;
              const stopValue = (i * this.stepIncrement) / denom;
              const totalExposure = this.baseTime * Math.pow(2, stopValue);

              // For first step: incremental time = base time
              // For subsequent steps: incremental time = difference between current and previous total
              let incrementalTime;
              if (i === 0) {
                incrementalTime = this.baseTime;
              } else {
                const previousStop = ((i - 1) * this.stepIncrement) / denom;
                const previousTotal = this.baseTime * Math.pow(2, previousStop);
                incrementalTime = totalExposure - previousTotal;
              }

              this.steps.push({
                step: i + 1,
                stop: stopValue,
                time: incrementalTime, // Time to expose THIS step
                cumulativeTime: 0, // Not used in incremental method
                incrementalTime: incrementalTime,
                totalExposure: totalExposure, // Total exposure on paper for this strip
              });

              previousTotalTime = totalExposure;
            }
          }
        }

        getIncrementLabel(increment) {
          return formatStopCompact(increment / (window.stopDenominator || 3));
        }

        formatStop(stopValue) {
          const denom = window.stopDenominator || 3;
          const whole = Math.floor(stopValue);
          const fraction = stopValue - whole;
          const tolerance = 0.0001;

          if (Math.abs(fraction) < tolerance) return `${whole}.0`;
          if (denom === 2) {
            if (Math.abs(fraction - 0.5) < tolerance) return `${whole}½`;
          } else if (denom === 3) {
            if (Math.abs(fraction - 1 / 3) < tolerance) return `${whole}⅓`;
            if (Math.abs(fraction - 2 / 3) < tolerance) return `${whole}⅔`;
          } else if (denom === 4) {
            if (Math.abs(fraction - 0.25) < tolerance) return `${whole}¹⁄₄`;
            if (Math.abs(fraction - 0.5) < tolerance) return `${whole}²⁄₄`;
            if (Math.abs(fraction - 0.75) < tolerance) return `${whole}³⁄₄`;
          }

          return `${stopValue.toFixed(1)}`;
        }

        /**
         * @method updateDisplay
         * @description Updates all UI elements with current test strip configuration.
         * Displays control values, sequence info, time ranges, progress labels, and preview.
         * @returns {void}
         * @fires updatePreview - Updates visual preview
         * @fires Element.textContent - Updates all display elements
         * @fires Element.style.width - Updates progress bar
         * @example
         * this.updateDisplay(); // Refresh all UI elements
         */
        updateDisplay() {
          // Update control values
          this.testBaseValue.textContent = `${this.baseTime.toFixed(1)}s`;
          this.testIncrementValue.textContent = `${this.getIncrementLabel(
            this.stepIncrement,
          )} stop`;
          this.testStepsValue.textContent = this.numSteps;

          // Update sequence info with method
          const methodText =
            this.method === "cumulative" ? "Cumulative" : "Incremental";
          this.testSequenceInfo.textContent = `${
            this.numSteps
          } steps × ${this.getIncrementLabel(
            this.stepIncrement,
          )} stop (${methodText})`;

          // Update time range based on method
          let minTime, maxTime;
          if (this.method === "cumulative") {
            minTime = this.baseTime;
            maxTime = this.steps[this.steps.length - 1]?.time || this.baseTime;
            this.testTimeRange.textContent = `${minTime.toFixed(
              2,
            )}s to ${maxTime.toFixed(2)}s`;

            // Update progress labels
            this.progressStart.textContent = `${minTime.toFixed(1)}s`;
            this.progressMiddle.textContent = `${(
              (minTime + maxTime) /
              2
            ).toFixed(1)}s`;
            this.progressEnd.textContent = `${maxTime.toFixed(1)}s`;
          } else {
            // For incremental method, show incremental times range
            minTime = this.steps[0]?.incrementalTime || this.baseTime;
            maxTime =
              this.steps[this.steps.length - 1]?.incrementalTime ||
              this.baseTime;
            this.testTimeRange.textContent = `Step times: ${minTime.toFixed(
              2,
            )}s to ${maxTime.toFixed(2)}s`;

            // Show total exposure range for incremental method
            const minTotal = this.baseTime;
            const maxTotal =
              this.steps[this.steps.length - 1]?.totalExposure || this.baseTime;
            this.progressStart.textContent = `${minTotal.toFixed(1)}s`;
            this.progressMiddle.textContent = `${(
              (minTotal + maxTotal) /
              2
            ).toFixed(1)}s`;
            this.progressEnd.textContent = `${maxTotal.toFixed(1)}s`;
          }

          // Update preview
          this.updatePreview();

          // Update info displays
          if (this.steps.length > 0) {
            const totalTime = this.steps.reduce(
              (sum, step) => sum + step.time,
              0,
            );
            this.totalTestTimeDisplay.textContent = `${totalTime.toFixed(1)}s`;

            // Update step size display
            const denom = window.stopDenominator || 3;
            const stepSize = this.stepIncrement / denom;
            this.stepSizeDisplay.textContent = `${stepSize.toFixed(1)} stops`;

            // Update timer display and step info when not running
            if (
              !this.isRunning &&
              !this.isPaused &&
              !this.isWaitingForNextStep
            ) {
              const firstStep = this.steps[0];
              this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
              this.currentStepDisplay.textContent = `1/${this.steps.length}`;
              this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
                2,
              )}s`;
              this.currentStopDisplay.textContent =
                this.method === "cumulative"
                  ? `${this.formatStop(firstStep.stop)}`
                  : `+${this.getIncrementLabel(this.stepIncrement)}`;
              this.timeMultiplierDisplay.textContent =
                this.method === "cumulative"
                  ? `${Math.pow(2, firstStep.stop).toFixed(2)}×`
                  : `${firstStep.totalExposure.toFixed(1)}s total`;
            }
          }
        }

        /**
         * @method updatePreview
         * @description Updates the visual test strip preview display.
         * Creates colored step elements with click-to-apply functionality.
         * Theme-aware coloring for dark/light/day schemes.
         * @returns {void}
         * @fires Element.innerHTML - Creates step elements
         * @fires Element.style.backgroundColor - Sets theme-aware colors
         * @fires addEventListener - Click handler for applyStepToCalc
         * @fires Element.style.width - Updates progress bar
         * @example
         * this.updatePreview(); // Refresh visual preview
         */
        updatePreview() {
          this.testStripPreview.innerHTML = "";
          const showTimes = this.previewMode.checked;

          this.steps.forEach((step, index) => {
            const stepEl = document.createElement("div");
            stepEl.className = "test-step";
            stepEl.dataset.step = step.step;
            stepEl.style.cursor = "pointer";

            // Calculate color intensity based on method
            if (this.method === "cumulative") {
              // Color based on total exposure (cumulative method)
              const maxTime = this.steps[this.steps.length - 1].time;
              const intensity = Math.min(
                100 + (step.time / maxTime) * 150,
                250,
              );
              stepEl.style.backgroundColor = `rgb(${intensity}, 0, 0)`;
            } else {
              // Color based on total exposure on paper (incremental method)
              const maxTotal = this.steps[this.steps.length - 1].totalExposure;
              const intensity = Math.min(
                100 + (step.totalExposure / maxTotal) * 150,
                250,
              );
              stepEl.style.backgroundColor = `rgb(${intensity}, 0, 0)`;
            }

            // Theme adjustments
            if (
              document.body.classList.contains("light-scheme") ||
              document.body.classList.contains("day-scheme")
            ) {
              // Create bigger steps: use index-based calculation for more distinct colors
              const stepIndex = index;
              const totalSteps = this.steps.length;
              // Use 50-250 range with bigger jumps between steps
              const greyIntensity = 50 + stepIndex * (150 / (totalSteps - 1));
              stepEl.style.backgroundColor = `rgb(${greyIntensity}, ${greyIntensity}, ${greyIntensity})`;
            }

            if (
              index === this.currentStep &&
              (this.isRunning || this.isPaused)
            ) {
              stepEl.classList.add("active");
            }

            // Store the total exposure time for this step
            // Both methods use totalExposure for consistency
            const timeValue = step.totalExposure;
            stepEl.dataset.time = timeValue;

            // Add click handler to apply this time to selected destination
            stepEl.addEventListener("click", () => {
              this.applyStepToDestination(index);
            });

            if (showTimes) {
              if (this.method === "cumulative") {
                stepEl.innerHTML = `
                            <div class="step-time">${step.time.toFixed(
                              1,
                            )}s</div>
                            <div class="step-stop">${this.formatStop(
                              step.stop,
                            )}</div>
                        `;
              } else {
                stepEl.innerHTML = `
                            <div class="step-time">${step.time.toFixed(
                              1,
                            )}s</div>
                            <div class="step-stop">+${this.getIncrementLabel(
                              this.stepIncrement,
                            )}</div>
                            <div style="font-size: 0.4rem; color: var(--accent); margin-top: 1px;">
                                Total: ${step.totalExposure.toFixed(1)}s
                            </div>
                        `;
              }
            } else {
              stepEl.innerHTML = `
                        <div class="step-time">${step.step}</div>
                        <div class="step-stop">${this.getIncrementLabel(
                          this.stepIncrement,
                        )}</div>
                    `;
            }

            this.testStripPreview.appendChild(stepEl);
          });

          // Update progress bar
          const progressFill = document.getElementById("progressFill");
          // Show progress including the current step being executed (currentStep is 0-indexed)
          const progressPercent =
            ((this.currentStep + 1) / this.steps.length) * 100;
          if (progressFill) {
            progressFill.style.width = `${progressPercent}%`;
          }
        }

        /**
         * @method start
         * @description Starts the test strip with countdown and relay triggering.
         * Performs countdown, triggers relay for first step, and begins timer.
         * @returns {Promise<void>} Resolves when countdown completes and test starts
         * @fires countdownManager.startCountdown - Visual/audio countdown
         * @fires startStep - Begins first step
         * @fires playBeep - Audio feedback
         * @fires updateStatus - Updates UI status
         * @example
         * await this.start(); // Start test strip
         */
        async start() {
          if (this.isRunning || this.steps.length === 0) return;

          // Disable buttons during countdown
          this.startTestStripBtn.disabled = true;
          this.stopTestTimerBtn.disabled = false; // Keep Stop enabled
          this.resetTestTimerBtn.disabled = true;

          // Start countdown
          const display = this.testTimerDisplay;
          const originalText = display.textContent;
          this.testTimerStatus.textContent = "COUNTDOWN STARTING...";

          await new Promise((resolve) => {
            window.countdownManager.startCountdown(display, () => {
              resolve();
            });
          });

          // Restore display and enable buttons
          display.textContent = originalText;
          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";

          // Continue with original start logic
          this.isRunning = true;
          this.isPaused = false;
          this.currentStep = 0;
          await this.startStep(); // Add await here

          this.startTestStripBtn.textContent = "Pause";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = false;
          this.resetTestTimerBtn.disabled = true;

          // Play start beep (if sound controls exist)
          if (this.testStepBeep && this.testStepBeep.checked) {
            playBeep(600, 0.1, 0.3);
          }
        }

        /**
         * @method triggerRelayForStep
         * @description Triggers the enlarger relay for a specific test step.
         * Only triggers if auto-trigger is enabled and step time is positive.
         * @param {number} stepTime - Exposure time for this step in seconds
         * @returns {Promise<void>} Resolves when relay trigger completes
         * @throws {Error} Logs error if relay trigger fails
         * @fires relayManager.triggerTimerRelay - Sends timer command to server
         * @example
         * await this.triggerRelayForStep(10.5); // Trigger for 10.5s
         */
        async triggerRelayForStep(stepTime) {
          if (
            window.relayManager &&
            window.relayManager.autoTrigger &&
            stepTime > 0
          ) {
            try {
              await window.relayManager.triggerTimerRelay(stepTime);
            } catch (error) {
              console.error("Failed to trigger relay for step:", error);
            }
          }
        }

        /**
         * @method startStep
         * @description Starts a single test strip step with relay triggering.
         * Updates UI displays, triggers relay, and starts interval timer.
         * @returns {Promise<void>} Resolves when step starts
         * @throws {Error} Logs error if relay trigger fails
         * @fires updatePreview - Updates visual preview
         * @fires triggerRelayForStep - Triggers enlarger
         * @fires startInterval - Begins countdown timer
         * @fires Element.textContent - Updates all displays
         * @example
         * await this.startStep(); // Start current step
         */
        async startStep() {
          if (this.currentStep >= this.steps.length) {
            this.complete();
            return;
          }

          const step = this.steps[this.currentStep];
          this.currentStepTime = step.time;
          this.lastBeepSecond = null;

          // Always show running status while the timer counts down
          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";

          this.currentStepDisplay.textContent = `${this.currentStep + 1}/${
            this.steps.length
          }`;

          if (this.method === "cumulative") {
            this.currentTimeDisplay.textContent = `${step.time.toFixed(2)}s`;
            this.currentStopDisplay.textContent = `${this.formatStop(
              step.stop,
            )}`;
            this.timeMultiplierDisplay.textContent = `${Math.pow(
              2,
              step.stop,
            ).toFixed(2)}×`;
          } else {
            this.currentTimeDisplay.textContent = `${step.time.toFixed(2)}s`;
            this.currentStopDisplay.textContent = `+${this.getIncrementLabel(
              this.stepIncrement,
            )}`;

            const totalExposure = step.totalExposure;
            this.timeMultiplierDisplay.textContent = `${totalExposure.toFixed(
              1,
            )}s total`;
          }

          this.testTimerDisplay.textContent = step.time.toFixed(2);

          this.updatePreview();

          // TRIGGER RELAY FOR THIS STEP - AWAIT HERE
          if (window.relayManager && window.relayManager.autoTrigger) {
            try {
              await window.relayManager.triggerTimerRelay(step.time);
            } catch (error) {
              console.error("Failed to trigger relay:", error);
            }
          }

          // Start the interval timer
          this.startInterval();
        }

        /**
         * @method startInterval
         * @description Starts the interval timer for the current step.
         * Decrements time by 0.1s intervals, updates display, plays warning beeps.
         * @returns {void}
         * @fires stepComplete - Called when step time reaches zero
         * @fires playBeep - Warning beeps at 3 seconds
         * @fires Element.textContent - Updates timer display
         * @fires Element.classList - Adds/removes warning class
         * @example
         * this.startInterval(); // Begin countdown for current step
         */
        startInterval() {
          this.interval = setInterval(() => {
            this.currentStepTime -= 0.1;

            if (this.currentStepTime <= 0) {
              this.currentStepTime = 0;
              this.stepComplete();
            } else {
              this.testTimerDisplay.textContent =
                this.currentStepTime.toFixed(2);

              // 3-second warning beep (if sound controls exist)
              if (
                this.currentStepTime <= 3 &&
                this.testWarningBeep &&
                this.testWarningBeep.checked
              ) {
                const currentSecond = Math.ceil(this.currentStepTime);

                if (
                  currentSecond !== this.lastBeepSecond &&
                  currentSecond <= 3 &&
                  currentSecond > 0
                ) {
                  this.lastBeepSecond = currentSecond;
                  playBeep(400, 0.1, 0.3);
                  this.testTimerDisplay.classList.add("warning");

                  setTimeout(() => {
                    this.testTimerDisplay.classList.remove("warning");
                  }, 300);
                }
              }
            }
          }, 100);
        }

        /**
         * @method stepComplete
         * @description Called when a step's timer reaches zero.
         * Handles auto-advance or manual advance mode, updates UI, and proceeds to next step.
         * @returns {void}
         * @fires updatePreview - Updates visual preview
         * @fires complete - If last step
         * @fires startStep - If auto-advance and more steps remain
         * @fires setTimeout - Delays next step in auto-advance mode
         * @fires playBeep - Step completion beep
         * @example
         * // Called automatically when step timer reaches zero
         * this.stepComplete();
         */
        stepComplete() {
          clearInterval(this.interval);

          // Play step complete beep (if sound controls exist)
          if (this.testStepBeep && this.testStepBeep.checked) {
            playBeep(800, 0.1, 0.3);
          }

          // Update preview to show completed step
          this.updatePreview();

          // Cancel any ongoing countdown (safety check)
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Determine next action based on auto advance setting
          if (this.autoAdvance && !this.isPaused) {
            // Auto advance: move to next step after configured delay
            this.currentStep++;

            if (this.currentStep < this.steps.length) {
              // Update status to show auto advance countdown
              const delaySec = this.autoAdvanceDelay / 1000;
              this.testTimerStatus.textContent = `Auto advancing in ${delaySec}s...`;

              // Start next step after configured delay
              setTimeout(() => {
                if (this.isRunning && !this.isPaused) {
                  this.startStep();
                }
              }, this.autoAdvanceDelay); // Use configured delay
            } else {
              this.complete();
            }
          } else {
            // Manual advance mode
            // Check if this was the last step
            if (this.currentStep >= this.steps.length - 1) {
              // Last step completed - finish immediately
              this.complete();
            } else {
              // More steps remain - pause and wait for user input
              this.isRunning = false; // Pause the timer
              this.isWaitingForNextStep = true; // Track waiting state
              this.testTimerStatus.textContent =
                "STEP COMPLETE - PRESS NEXT STEP";

              // Update Start button to act as Next Step and keep Stop enabled
              this.startTestStripBtn.textContent = "Next Step";
              this.stopTestTimerBtn.disabled = false;

              // Update step number to show current (completed) step
              this.currentStepDisplay.textContent = `${this.currentStep + 1}/${
                this.steps.length
              } (Completed)`;

              // Show instruction based on method
              if (this.method === "incremental") {
                this.testTimerStatus.textContent =
                  "SLIDE MASK → THEN PRESS NEXT STEP";
              }
            }
          }
        }

        /**
         * @method pause
         * @description Pauses the running test strip.
         * Stops the interval timer and updates UI to show paused state.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires restoreDisplayAfterCountdown - Restores display
         * @fires playBeep - Audio feedback
         * @fires Element.textContent - Updates status
         * @fires Element.classList - Removes warning class
         * @example
         * this.pause(); // Pause current test
         */
        pause() {
          if (!this.isRunning) return;

          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = true;

          this.testTimerStatus.textContent = "TEST STRIP PAUSED";
          this.startTestStripBtn.textContent = "Resume";
          this.testTimerDisplay.classList.remove("warning");

          playBeep(400, 0.1, 0.2);
        }

        /**
         * @method resume
         * @description Resumes a paused test strip.
         * Restarts the interval timer from the current step time.
         * @returns {void}
         * @fires startInterval - Resumes countdown
         * @fires Element.textContent - Updates status
         * @example
         * this.resume(); // Resume paused test
         */
        resume() {
          if (!this.isPaused) return;

          this.isRunning = true;
          this.isPaused = false;

          this.testTimerStatus.textContent = "TEST STRIP IN PROGRESS";
          this.startTestStripBtn.textContent = "Pause";

          // RESUME from current time instead of restarting the step
          this.startInterval();
        }

        /**
         * @method stopCurrentTest
         * @description Stops the current test and resets to initial state.
         * Can be called at any time to abort the test.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires restoreDisplayAfterCountdown - Restores display
         * @fires playBeep - Audio feedback
         * @fires Element.textContent - Updates all displays
         * @fires Element.classList - Removes warning class
         * @example
         * this.stopCurrentTest(); // Stop and reset test
         */
        stopCurrentTest() {
          // Allow stopping at any time - no return check

          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.currentStep = 0;
          this.currentStepTime = 0;
          this.lastBeepSecond = null;

          this.testTimerStatus.textContent = "READY FOR TEST STRIP";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;
          this.testTimerDisplay.textContent = "0.00";
          this.testTimerDisplay.classList.remove("warning");

          // Reset step display
          if (this.steps.length > 0) {
            const firstStep = this.steps[0];
            this.currentStepDisplay.textContent = `1/${this.steps.length}`;
            this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
              2,
            )}s`;
            this.currentStopDisplay.textContent =
              this.method === "cumulative"
                ? `${this.formatStop(firstStep.stop)}`
                : `+${this.getIncrementLabel(this.stepIncrement)}`;
            this.timeMultiplierDisplay.textContent =
              this.method === "cumulative"
                ? `${Math.pow(2, firstStep.stop).toFixed(2)}×`
                : `${firstStep.totalExposure.toFixed(1)}s total`;
            this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
          }

          this.updatePreview();

          playBeep(600, 0.1, 0.2);
        }

        /**
         * @method nextStep
         * @description Proceeds to the next test step.
         * Handles countdown if auto-advance is off, or proceeds immediately if on.
         * @returns {void}
         * @fires startCountdownForNextStep - Countdown before next step
         * @fires proceedToNextStep - Immediate next step
         * @example
         * this.nextStep(); // Proceed to next step
         */
        nextStep() {
          if (
            this.isPaused ||
            (!this.isRunning && this.currentStep < this.steps.length)
          ) {
            // If auto advance is OFF, do countdown before next step
            if (!this.autoAdvance) {
              this.startCountdownForNextStep();
            } else {
              // If auto advance is ON, proceed immediately
              this.proceedToNextStep();
            }
          }
        }

        /**
         * @method startCountdownForNextStep
         * @description Starts countdown before proceeding to next step.
         * Prevents multiple countdowns, saves display state, and handles completion.
         * @returns {void}
         * @fires countdownManager.startCountdown - Visual/audio countdown
         * @fires restoreDisplayAfterCountdown - Restores display after countdown
         * @fires proceedToNextStep - Called when countdown completes
         * @fires console.warn - If countdown already active
         * @fires console.error - If countdown fails
         * @example
         * this.startCountdownForNextStep(); // Countdown before next step
         */
        startCountdownForNextStep() {
          // Prevent multiple countdowns
          if (window.countdownManager && window.countdownManager.isActive) {
            console.warn("Countdown already active");
            return;
          }
          // Disable buttons during countdown, but keep Stop enabled
          this.startTestStripBtn.disabled = true;
          this.stopTestTimerBtn.disabled = false; // Keep Stop enabled
          this.resetTestTimerBtn.disabled = true;

          // Save original display values AND style properties
          const originalDisplay = this.testTimerDisplay.textContent;
          const originalStatus = this.testTimerStatus.textContent;
          const originalTimerBgColor =
            this.testTimerDisplay.style.backgroundColor;
          const originalTimerColor = this.testTimerDisplay.style.color;
          const originalTimerFontWeight =
            this.testTimerDisplay.style.fontWeight;

          // Store references for cleanup
          this.countdownCleanup = {
            display: originalDisplay,
            status: originalStatus,
            timerBgColor: originalTimerBgColor,
            timerColor: originalTimerColor,
            timerFontWeight: originalTimerFontWeight,
          };

          // Start countdown
          this.testTimerStatus.textContent = "COUNTDOWN FOR NEXT STEP...";

          // Clear any existing cleanup reference first
          if (this.countdownCleanupTimeout) {
            clearTimeout(this.countdownCleanupTimeout);
          }

          try {
            window.countdownManager.startCountdown(
              this.testTimerDisplay,
              () => {
                // Countdown complete callback
                this.restoreDisplayAfterCountdown();
                // Proceed to the actual next step
                this.proceedToNextStep();
              },
            );
          } catch (error) {
            console.error("Countdown failed:", error);
            // Fallback: proceed without countdown
            this.restoreDisplayAfterCountdown();
            this.proceedToNextStep();
          }
        }

        /**
         * @method restoreDisplayAfterCountdown
         * @description Restores display after countdown completes or is cancelled.
         * Resets text, colors, and font weights to original or theme defaults.
         * @returns {void}
         * @fires Element.textContent - Restores original text
         * @fires Element.style - Restores original styles
         * @fires Element.disabled - Re-enables buttons
         * @example
         * this.restoreDisplayAfterCountdown(); // Restore after countdown
         */
        restoreDisplayAfterCountdown() {
          if (this.countdownCleanup) {
            this.testTimerDisplay.textContent = this.countdownCleanup.display;
            this.testTimerStatus.textContent = this.countdownCleanup.status;
            this.testTimerDisplay.style.backgroundColor =
              this.countdownCleanup.timerBgColor;
            this.testTimerDisplay.style.color =
              this.countdownCleanup.timerColor;
            this.testTimerDisplay.style.fontWeight =
              this.countdownCleanup.timerFontWeight;
            this.countdownCleanup = null;
          } else {
            // Default restoration based on theme
            if (document.body.classList.contains("light-scheme")) {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#0066cc";
            } else if (document.body.classList.contains("day-scheme")) {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#ffcc00";
            } else {
              this.testTimerDisplay.style.backgroundColor = "";
              this.testTimerDisplay.style.color = "#f00";
            }
            this.testTimerDisplay.style.fontWeight = "";
          }

          // Re-enable appropriate buttons
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = false;
          this.resetTestTimerBtn.disabled = true;
        }

        // NEW METHOD: Actual next step logic (moved from original nextStep)
        /**
         * @method proceedToNextStep
         * @description Advances to the next test step or completes the test.
         * Cleans up countdown display, increments step counter, and starts next step.
         * If all steps complete, calls complete() to finish the test.
         * @returns {Promise<void>} Resolves when step transition is complete
         * @throws {Error} If called when no test is active
         * @fires Element.textContent - Updates step counter display
         * @fires Element.style - Restores display styles
         * @fires Element.disabled - Updates button states
         * @example
         * await this.proceedToNextStep(); // Move to next step or finish
         */
        async proceedToNextStep() {
          // Clean up any remaining countdown display properties
          this.restoreDisplayAfterCountdown();

          this.currentStep++;

          if (this.currentStep < this.steps.length) {
            this.isRunning = true;
            this.isPaused = false;
            this.isWaitingForNextStep = false;
            await this.startStep(); // Add await here

            // Update button states
            this.startTestStripBtn.textContent = "Pause";
            this.stopTestTimerBtn.disabled = false;
            this.resetTestTimerBtn.disabled = true;
          } else {
            this.complete();
          }
        }

        /**
         * @method complete
         * @description Marks the test strip as complete and updates UI accordingly.
         * Cancels any active countdown, restores display, stops the timer, and shows completion status.
         * Plays completion beep if enabled, updates button states, and highlights all steps.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires Element.textContent - Shows "TEST STRIP COMPLETE" message
         * @fires Element.disabled - Updates all button states
         * @fires Element.textContent - Updates start button text
         * @fires AudioService.playBeep - Plays completion sound if enabled
         * @fires this.updatePreview - Updates step preview display
         * @example
         * this.complete(); // Mark test as complete
         */
        complete() {
          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;

          // Play end beep (if sound controls exist)
          if (this.testEndBeep && this.testEndBeep.checked) {
            playBeep(800, 0.1, 0.3);
          }

          this.testTimerStatus.textContent = "TEST STRIP COMPLETE";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;

          // Highlight all steps as complete
          this.currentStep = this.steps.length;
          this.updatePreview();

          // Log test strip session
          if (window.exposureLogManager && this.steps.length > 0) {
            const selectedStep = this.steps[this.currentStep - 1];

            // Get notes from input field
            const notesInput = document.getElementById("testNotesInput");
            const notes = notesInput ? notesInput.value : "";

            window.exposureLogManager.addTestPhase({
              baseTime: this.baseTime,
              method: this.method,
              steps: this.steps.map((s) => s.time),
              selectedStep: selectedStep ? selectedStep.time : null,
              selectedStop: selectedStep ? selectedStep.stop : null,
              transferDestination: appState.settings.testTransferDestination,
              notes: notes,
            });

            // Clear notes input
            if (notesInput) notesInput.value = "";
          }
        }

        /**
         * @method reset
         * @description Resets the test strip to initial state.
         * Cancels any active countdown, clears intervals, resets all state variables,
         * and restores UI to ready state with default styling and step display.
         * @returns {void}
         * @fires countdownManager.cancel - Cancels active countdown
         * @fires Element.textContent - Resets displays to initial values
         * @fires Element.classList - Removes warning class
         * @fires Element.disabled - Resets all button states
         * @fires this.updatePreview - Updates step preview display
         * @example
         * this.reset(); // Reset test strip to initial state
         */
        reset() {
          // Cancel any ongoing countdown
          if (window.countdownManager && window.countdownManager.isActive) {
            window.countdownManager.cancel();
          }

          // Restore display if countdown was active
          if (this.restoreDisplayAfterCountdown) {
            this.restoreDisplayAfterCountdown();
          }

          clearInterval(this.interval);
          this.isRunning = false;
          this.isPaused = false;
          this.isWaitingForNextStep = false;
          this.currentStep = 0;
          this.currentStepTime = 0;

          this.testTimerStatus.textContent = "READY FOR TEST STRIP";
          this.startTestStripBtn.textContent = "Start Test Strip";
          this.startTestStripBtn.disabled = false;
          this.stopTestTimerBtn.disabled = true;
          this.resetTestTimerBtn.disabled = false;
          this.testTimerDisplay.textContent = "0.00";
          this.testTimerDisplay.classList.remove("warning");

          // Reset step display
          if (this.steps.length > 0) {
            const firstStep = this.steps[0];
            this.currentStepDisplay.textContent = `1/${this.steps.length}`;
            this.currentTimeDisplay.textContent = `${firstStep.time.toFixed(
              2,
            )}s`;
            this.currentStopDisplay.textContent =
              this.method === "cumulative"
                ? `${this.formatStop(firstStep.stop)}`
                : `+${this.getIncrementLabel(this.stepIncrement)}`;
            this.timeMultiplierDisplay.textContent =
              this.method === "cumulative"
                ? `${Math.pow(2, firstStep.stop).toFixed(2)}×`
                : `${firstStep.totalExposure.toFixed(1)}s total`;
            this.testTimerDisplay.textContent = firstStep.time.toFixed(2);
          }

          this.updatePreview();
        }

        /**
         * @method toggle
         * @description Toggles the test strip state (start/pause/resume/next).
         * Acts as a universal control button that changes behavior based on current state:
         * - Running → Pause
         * - Paused → Resume
         * - Waiting for next → Next step
         * - Stopped → Start
         * @returns {Promise<void>} Resolves when toggle action completes
         * @fires this.pause - When running
         * @fires this.resume - When paused
         * @fires this.nextStep - When waiting for next step
         * @fires this.start - When stopped
         * @example
         * await this.toggle(); // Toggle current state
         */
        async toggle() {
          if (this.isRunning) {
            this.pause();
          } else if (this.isPaused) {
            await this.resume();
          } else if (this.isWaitingForNextStep) {
            // Waiting for next step - act like Next Step button
            this.nextStep();
          } else {
            await this.start();
          }
        }

        /**
         * @method applyStepToCalc
         * @description Applies a test step's total exposure time to the CALC tab's base time.
         * Updates the base time slider, triggers state update, switches to CALC tab, and scrolls to top.
         * @param {number} stepIndex - Index of the step to apply (0-based)
         * @returns {void}
         * @throws {Error} If stepIndex is out of bounds
         * @fires Element.value - Updates base time slider value
         * @fires Event.input - Triggers slider input event to update calculator state
         * @fires switchTab - Switches to CALC tab
         * @fires Element.scrollTop - Scrolls container to top
         * @fires window.scrollTo - Scrolls window to top as fallback
         * @example
         * this.applyStepToCalc(2); // Apply third step's total exposure to CALC tab
         */
        applyStepToCalc(stepIndex) {
          if (stepIndex < 0 || stepIndex >= this.steps.length) return;

          const step = this.steps[stepIndex];

          // Get the total exposure time for this step
          // Both methods use totalExposure for consistency
          const timeValue = step.totalExposure;

          // Update the CALC tab's base time slider
          const baseTimeSlider = document.getElementById("baseTimeSlider");
          if (baseTimeSlider) {
            baseTimeSlider.value = timeValue.toFixed(1);

            // Trigger the input event to update the IncrementalTimer state
            baseTimeSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }

          // Switch to CALC tab
          switchTab("calc");

          // Scroll to top using container
          const container = document.querySelector(".container");
          if (container) {
            container.scrollTop = 0;
          }
          // Also scroll window as fallback
          window.scrollTo(0, 0);

          // Audio feedback
          if (typeof playBeep === "function") {
            playBeep(800, 0.1, 0.3);
          }
        }

        /**
         * @method applyStepToSplit
         * @description Applies a test step's total exposure time to the SPLIT tab's neutral time.
         * Updates the neutral time slider, triggers state update, switches to SPLIT tab, and scrolls to top.
         * @param {number} stepIndex - Index of the step to apply (0-based)
         * @returns {void}
         * @throws {Error} If stepIndex is out of bounds
         * @fires Element.value - Updates neutral time slider value
         * @fires Event.input - Triggers slider input event to update split calculator state
         * @fires switchTab - Switches to SPLIT tab
         * @fires Element.scrollTop - Scrolls container to top
         * @fires window.scrollTo - Scrolls window to top as fallback
         * @example
         * this.applyStepToSplit(2); // Apply third step's total exposure to SPLIT tab
         */
        applyStepToSplit(stepIndex) {
          if (stepIndex < 0 || stepIndex >= this.steps.length) return;

          const step = this.steps[stepIndex];

          // Get the total exposure time for this step
          const timeValue = step.totalExposure;

          // Update the SPLIT tab's neutral time slider
          const neutralTimeSlider =
            document.getElementById("neutralTimeSlider");
          if (neutralTimeSlider) {
            neutralTimeSlider.value = timeValue.toFixed(1);

            // Trigger the input event to update the SplitGradeCalculator state
            neutralTimeSlider.dispatchEvent(
              new Event("input", { bubbles: true }),
            );
          }

          // Switch to SPLIT tab
          switchTab("split");

          // Scroll to top using container
          const container = document.querySelector(".container");
          if (container) {
            container.scrollTop = 0;
          }
          // Also scroll window as fallback
          window.scrollTo(0, 0);

          // Audio feedback
          if (typeof playBeep === "function") {
            playBeep(800, 0.1, 0.3);
          }
        }

        /**
         * @method applyStepToDestination
         * @description Applies a test step's total exposure time to the selected destination.
         * Uses the current transferDestination setting to determine whether to apply to CALC or SPLIT tab.
         * @param {number} stepIndex - Index of the step to apply (0-based)
         * @returns {void}
         * @fires this.applyStepToCalc - If destination is 'calc'
         * @fires this.applyStepToSplit - If destination is 'split'
         * @example
         * this.applyStepToDestination(2); // Apply to current destination
         */
        applyStepToDestination(stepIndex) {
          if (this.transferDestination === "split") {
            this.applyStepToSplit(stepIndex);
          } else {
            this.applyStepToCalc(stepIndex);
          }
        }

        /**
         * @method setTransferDestination
         * @description Sets the transfer destination and persists to storage.
         * Updates the UI to reflect the selected destination.
         * @param {string} destination - 'calc' or 'split'
         * @returns {void}
         * @fires StorageManager.saveTestTransferDestination - Persist setting
         * @fires appState.settings.testTransferDestination - Update appState
         * @fires updateTransferDestinationUI - Update visual feedback
         * @example
         * this.setTransferDestination('split'); // Set to SPLIT tab
         */
        setTransferDestination(destination) {
          if (destination !== "calc" && destination !== "split") return;

          this.transferDestination = destination;

          // Update appState
          if (appState && appState.settings) {
            appState.settings.testTransferDestination = destination;
          }

          // Persist to storage
          StorageManager.saveTestTransferDestination(destination);

          // Update UI
          this.updateTransferDestinationUI();

          // Audio feedback
          if (typeof playBeep === "function") {
            playBeep(600, 0.1, 0.2);
          }

          // Visual feedback via settings manager if available
          if (settingsManager && settingsManager.showAllProfilesFeedback) {
            const label = destination === "calc" ? "CALC" : "SPLIT";
            settingsManager.showAllProfilesFeedback(
              `Transfer destination: ${label}`,
              "info",
            );
          }
        }

        /**
         * @method updateTransferDestinationUI
         * @description Updates the visual feedback for transfer destination selection.
         * Highlights the active button and updates aria-pressed attributes.
         * @returns {void}
         * @fires Element.classList - Updates button states
         * @fires Element.setAttribute - Updates aria-pressed
         * @example
         * this.updateTransferDestinationUI(); // Refresh visual feedback
         */
        updateTransferDestinationUI() {
          const transferSeg = document.getElementById("transferDestinationSeg");
          if (!transferSeg) return;

          const buttons = transferSeg.querySelectorAll(".segmented-btn");
          buttons.forEach((btn) => {
            const isActive =
              btn.dataset.destination === this.transferDestination;
            btn.classList.toggle("active", isActive);
            btn.setAttribute("aria-pressed", isActive ? "true" : "false");
          });
        }

        /**
         * @method getCurrentTestStripProfile
         * @description Gets the currently loaded test strip profile name from appState.
         * Returns the single source of truth for the active profile.
         * @returns {string|null} The profile name or null if no profile loaded
         * @fires appState.persistent.currentTestStripProfile - Reads current profile
         * @example
         * const profile = this.getCurrentTestStripProfile(); // Get active profile name
         */
        getCurrentTestStripProfile() {
          return appState.persistent.currentTestStripProfile;
        }

        /**
         * @method setCurrentTestStripProfile
         * @description Sets the current test strip profile in appState and persists to storage.
         * Updates the single source of truth and saves to localStorage.
         * @param {string} profileName - The name of the profile to set as current
         * @returns {void}
         * @fires appState.persistent.currentTestStripProfile - Updates current profile
         * @fires StorageManager.saveCurrentTestStripProfile - Persists to storage
         * @example
         * this.setCurrentTestStripProfile("My Test Profile"); // Set and save profile
         */
        setCurrentTestStripProfile(profileName) {
          appState.persistent.currentTestStripProfile = profileName;
          StorageManager.saveCurrentTestStripProfile(profileName);
        }

        /**
         * @method getCurrentSettings
         * @description Gets current test strip settings as a configuration object.
         * Collects base time, step increment, denominator, and number of steps.
         * @returns {Object} Settings object with baseTime, stepIncrement, denominator, numSteps
         * @fires Element.value - Reads slider values
         * @fires window.stopDenominator - Reads global denominator setting
         * @example
         * const settings = this.getCurrentSettings(); // Get current configuration
         */
        /**
         * @method getCurrentSettings
         * @description Gets current test strip settings as a configuration object.
         * Collects base time, step increment, denominator, number of steps, method, and auto-advance settings.
         * @returns {Object} Settings object with baseTime, stepIncrement, denominator, numSteps, method, autoAdvance, autoAdvanceDelay
         * @fires Element.value - Reads slider values
         * @fires window.stopDenominator - Reads global denominator setting
         * @example
         * const settings = this.getCurrentSettings(); // Get current configuration
         */
        getCurrentSettings() {
          return {
            baseTime: parseFloat(this.testBaseSlider.value),
            stepIncrement: parseInt(this.testIncrementSlider.value),
            denominator: window.stopDenominator || 3,
            numSteps: parseInt(this.testStepsSlider.value),
            method: this.method,
            autoAdvance: this.autoAdvance,
            autoAdvanceDelay: this.autoAdvanceDelay / 1000, // Convert to seconds
          };
        }

        /**
         * @method applyProfile
         * @description Applies settings from a profile to the test strip controls.
         * Stops any running test, updates all controls, sets denominator, method, auto-advance,
         * and refreshes the UI with visual feedback.
         * @param {Object} profile - The profile object to apply
         * @returns {void}
         * @throws {Error} If profile is invalid
         * @fires this.stopCurrentTest - Stops running test
         * @fires Element.value - Updates slider values
         * @fires window.stopDenominator - Updates global denominator
         * @fires setActiveSeg - Updates segment control
         * @fires this.setMethod - Sets test method
         * @fires this.setAutoAdvance - Sets auto-advance mode
         * @fires StorageManager.saveSettings - Persists auto-advance delay
         * @fires this.setCurrentTestStripProfile - Sets current profile name
         * @fires this.updateFromControls - Refreshes all displays
         * @fires updateAllRulers - Updates visual rulers
         * @fires this.updateTestStripProfileList - Updates profile list UI
         * @fires AudioService.playBeep - Plays confirmation sound
         * @example
         * this.applyProfile(myProfile); // Apply profile settings
         */
        applyProfile(profile) {
          if (!profile) return;

          // Stop current test if running
          if (this.isRunning) {
            this.stopCurrentTest();
          }

          // Apply settings to controls
          this.testBaseSlider.value = profile.baseTime;
          this.testIncrementSlider.value = profile.stepIncrement;
          this.testStepsSlider.value = profile.numSteps;

          // Set denominator
          window.stopDenominator = profile.denominator;
          setActiveSeg("testIncrementSeg", profile.denominator);

          // Set method
          this.setMethod(profile.method);

          // Set auto advance
          this.setAutoAdvance(profile.autoAdvance);
          if (profile.autoAdvanceDelay !== undefined) {
            this.autoAdvanceDelay = profile.autoAdvanceDelay * 1000;
            if (settingsManager) {
              settingsManager.settings.autoAdvanceDelay =
                profile.autoAdvanceDelay;
              StorageManager.saveSettings(settingsManager.settings);
            }
          }

          // Set current profile
          this.setCurrentTestStripProfile(profile.name);

          // Update from controls to refresh everything
          this.updateFromControls();
          if (typeof updateAllRulers === "function") {
            updateAllRulers();
          }

          // Update profile list to show active state
          this.updateTestStripProfileList();

          // Visual feedback
          playBeep(600, 0.3, 0.3);
        }

        /**
         * @method saveProfile
         * @description Saves current settings as a named profile.
         * Creates a profile object with current settings and timestamp, saves to storage,
         * and updates the profile list UI with visual feedback.
         * @param {string} name - The name for the new profile
         * @returns {boolean} True if saved successfully, false otherwise
         * @throws {Error} If storage operation fails
         * @fires this.getCurrentSettings - Collects current settings
         * @fires StorageManager.loadTestStripProfiles - Loads existing profiles
         * @fires StorageManager.saveTestStripProfiles - Saves updated profiles
         * @fires this.updateTestStripProfileList - Updates UI
         * @fires AudioService.playBeep - Plays confirmation sound
         * @example
         * const success = this.saveProfile("My Profile"); // Save current settings
         */
        saveProfile(name) {
          if (!name || name.trim() === "") {
            alert("Please enter a profile name");
            return false;
          }

          const profile = {
            name: name.trim(),
            ...this.getCurrentSettings(),
            date: new Date().toISOString(),
          };

          // Get existing profiles
          const profiles = StorageManager.loadTestStripProfiles();

          // Check if profile already exists
          const existingIndex = profiles.findIndex(
            (p) => p.name === profile.name,
          );
          if (existingIndex >= 0) {
            profiles[existingIndex] = profile;
          } else {
            profiles.push(profile);
          }

          // Save to storage
          if (StorageManager.saveTestStripProfiles(profiles)) {
            this.updateTestStripProfileList();
            playBeep(800, 0.3, 0.3);
            return true;
          }

          return false;
        }

        /**
         * @method loadProfile
         * @description Loads a profile by name and applies it to the test strip controls.
         * Searches through saved profiles and applies the matching one.
         * @param {string} profileName - The name of the profile to load
         * @returns {boolean} True if profile found and applied, false otherwise
         * @fires StorageManager.loadTestStripProfiles - Loads all profiles
         * @fires this.applyProfile - Applies the profile settings
         * @example
         * const success = this.loadProfile("My Profile"); // Load and apply profile
         */
        loadProfile(profileName) {
          const profiles = StorageManager.loadTestStripProfiles();
          const profile = profiles.find((p) => p.name === profileName);

          if (profile) {
            this.applyProfile(profile);
            return true;
          }

          return false;
        }

        /**
         * @method deleteProfile
         * @description Deletes a profile by name after user confirmation.
         * Prompts user for confirmation, removes profile from storage, and updates UI.
         * @param {string} profileName - The name of the profile to delete
         * @returns {boolean} True if deleted successfully, false otherwise or cancelled
         * @fires confirm - User confirmation dialog
         * @fires StorageManager.loadTestStripProfiles - Loads all profiles
         * @fires StorageManager.saveTestStripProfiles - Saves filtered profiles
         * @fires this.updateTestStripProfileList - Updates UI
         * @fires AudioService.playBeep - Plays deletion sound
         * @example
         * const success = this.deleteProfile("Old Profile"); // Delete profile
         */
        deleteProfile(profileName) {
          if (confirm(`Delete test strip profile "${profileName}"?`)) {
            const profiles = StorageManager.loadTestStripProfiles();
            const filtered = profiles.filter((p) => p.name !== profileName);

            if (StorageManager.saveTestStripProfiles(filtered)) {
              this.updateTestStripProfileList();
              playBeep(400, 0.3, 0.3);
              return true;
            }
          }
          return false;
        }

        /**
         * @method clearAllProfiles
         * @description Clears all test strip profiles after user confirmation.
         * Prompts user for confirmation, clears storage, and updates UI.
         * @returns {boolean} True if cleared successfully, false otherwise or cancelled
         * @fires confirm - User confirmation dialog
         * @fires StorageManager.saveTestStripProfiles - Clears all profiles
         * @fires this.updateTestStripProfileList - Updates UI
         * @fires AudioService.playBeep - Plays confirmation sound
         * @example
         * const success = this.clearAllProfiles(); // Clear all profiles
         */
        clearAllProfiles() {
          if (
            confirm("Clear all test strip profiles? This cannot be undone.")
          ) {
            if (StorageManager.saveTestStripProfiles([])) {
              this.updateTestStripProfileList();
              playBeep(400, 0.3, 0.3);
              return true;
            }
          }
          return false;
        }

        /**
         * @method updateTestStripProfileList
         * @description Updates the profile list display in the UI.
         * Loads all profiles from storage, creates list items with load/delete buttons,
         * and highlights the currently active profile.
         * @returns {void}
         * @fires StorageManager.loadTestStripProfiles - Loads all profiles
         * @fires this.getCurrentTestStripProfile - Gets active profile name
         * @fires this.loadProfile - Called when profile is clicked
         * @fires this.deleteProfile - Called when delete button is clicked
         * @fires Element.innerHTML - Clears and rebuilds list
         * @example
         * this.updateTestStripProfileList(); // Refresh profile list UI
         */
        updateTestStripProfileList() {
          const listElement = document.getElementById("testStripProfileList");
          if (!listElement) return;

          const profiles = StorageManager.loadTestStripProfiles();
          const currentProfile = this.getCurrentTestStripProfile();
          listElement.innerHTML = "";

          if (profiles.length === 0) {
            listElement.innerHTML =
              '<div style="padding: 10px; text-align: center; color: var(--text-secondary); font-size: 0.75rem;">No profiles saved yet</div>';
            return;
          }

          profiles.forEach((profile) => {
            const itemDiv = document.createElement("div");
            itemDiv.className = `shelf-life-item ${
              currentProfile === profile.name ? "active" : ""
            }`;

            const methodLabel =
              profile.method === "cumulative" ? "Cumulative" : "Incremental";
            const autoAdvanceLabel = profile.autoAdvance ? "Auto" : "Manual";
            const denomLabel = `1/${profile.denominator}`;

            itemDiv.innerHTML = `
              <div>
                <strong>${profile.name}</strong>
                <div style="font-size: 0.65rem; color: var(--text-secondary);">
                  ${profile.baseTime}s • ${
                    profile.stepIncrement
                  }×${denomLabel} • ${profile.numSteps} steps
                </div>
                <div style="font-size: 0.6rem; color: var(--accent);">
                  ${methodLabel} • ${autoAdvanceLabel}
                </div>
                <div style="font-size: 0.55rem; color: var(--text-secondary); margin-top: 2px;">
                  ${new Date(profile.date).toLocaleDateString()}
                </div>
              </div>
              <div class="shelf-life-actions">
                <button class="btn-action load-btn" data-context="teststrip" data-name="${
                  profile.name
                }">Load</button>
                <button class="btn-action delete-btn" data-context="teststrip" data-name="${
                  profile.name
                }">Delete</button>
              </div>
            `;

            listElement.appendChild(itemDiv);
          });
        }
      }

      /**
       * @function updateChart
       * @description Updates the f-stop calculation table with current base time and stop settings.
       * Generates a table showing total time, increment from base, and step increments for stops -6 to +6.
       * Highlights the currently selected stop row.
       * @returns {void}
       * @fires chartBaseSlider.value - Reads chart base time (if available)
       * @fires Element.getElementById - Gets base time slider and table body
       * @fires window.incrementalTimer - Reads calculator base time
       * @fires settingsManager.settings - Reads settings base time
       * @fires calculateTime - Calculates time for each stop
       * @fires formatStop - Formats stop values
       * @fires Element.innerHTML - Clears and rebuilds table
       * @fires Element.appendChild - Adds rows to table
       * @fires Element.style - Applies highlighting to current stop row
       * @example
       * updateChart(); // Update f-stop calculation table
       */
      function updateChart() {
        const baseTime = (function () {
          // Prefer chart slider if present, otherwise fall back to the main base time slider
          if (typeof chartBaseSlider !== "undefined" && chartBaseSlider)
            return parseFloat(chartBaseSlider.value);
          const bt = document.getElementById("baseTimeSlider");
          if (bt) return parseFloat(bt.value);
          if (window.incrementalTimer)
            return parseFloat(window.incrementalTimer.baseTime) || 10;
          if (settingsManager)
            return parseFloat(settingsManager.settings.baseTime) || 10;
          return 10;
        })();
        const chartBaseEl = document.getElementById("chartBaseValue");
        if (chartBaseEl) chartBaseEl.textContent = `${baseTime.toFixed(1)}s`;

        const tableBody = document.getElementById("tableBody");
        const currentStop = parseInt(stopSlider.value);

        tableBody.innerHTML = "";

        let previousTotalTime = null;

        for (let stop = -6; stop <= 6; stop++) {
          const totalTime = calculateTime(baseTime, stop);
          const fromBaseTime = totalTime - baseTime;

          let increment = 0;
          if (previousTotalTime !== null) {
            increment = totalTime - previousTotalTime;
          }
          previousTotalTime = totalTime;

          const stopLabel = formatStop(stop);
          const row = document.createElement("tr");

          if (stop === currentStop) {
            row.style.background = "var(--panel-light)";
            row.style.fontWeight = "bold";
          }

          row.innerHTML = `
                <td>${stopLabel}</td>
                <td><strong>${totalTime.toFixed(2)}</strong></td>
                <td>${fromBaseTime >= 0 ? "+" : ""}${fromBaseTime.toFixed(
                  2,
                )}</td>
                <td class="increment-cell">${
                  increment >= 0 ? "+" : ""
                }${increment.toFixed(2)}</td>
            `;

          tableBody.appendChild(row);
        }
      }

      // Fullscreen Manager
      /**
       * @class FullscreenManager
       * @description Manages fullscreen mode for the application.
       * Handles entering, exiting, and toggling fullscreen state across different browsers.
       * Monitors fullscreen change events and updates UI accordingly.
       * @property {boolean} isFullscreen - Current fullscreen state
       * @property {HTMLElement|null} toggleBtn - Fullscreen toggle button element
       * @example
       * const fullscreenManager = new FullscreenManager();
       */
      class FullscreenManager {
        /**
         * @constructor
         * @description Creates a new FullscreenManager instance.
         * Initializes state, finds toggle button, and sets up event listeners.
         * @fires this.init - Initializes event listeners
         */
        constructor() {
          this.isFullscreen = false;
          this.toggleBtn = document.getElementById("toggleFullscreen");
          this.init();
        }

        /**
         * @method init
         * @description Initializes event listeners for fullscreen management.
         * Sets up click handler for toggle button and fullscreen change listeners
         * for all browser prefixes (standard, WebKit, Mozilla, Microsoft).
         * @returns {void}
         * @fires Element.addEventListener - Adds click listener to toggle button
         * @fires document.addEventListener - Adds fullscreen change listeners
         * @example
         * this.init(); // Initialize event listeners
         */
        init() {
          if (this.toggleBtn) {
            this.toggleBtn.addEventListener("click", () => this.toggle());
          }

          document.addEventListener("fullscreenchange", () =>
            this.handleFullscreenChange(),
          );
          document.addEventListener("webkitfullscreenchange", () =>
            this.handleFullscreenChange(),
          );
          document.addEventListener("mozfullscreenchange", () =>
            this.handleFullscreenChange(),
          );
          document.addEventListener("MSFullscreenChange", () =>
            this.handleFullscreenChange(),
          );
        }

        /**
         * @method toggle
         * @description Toggles fullscreen mode on or off.
         * Calls enter() if not fullscreen, exit() if fullscreen.
         * @returns {void}
         * @fires this.enter - When entering fullscreen
         * @fires this.exit - When exiting fullscreen
         * @example
         * this.toggle(); // Toggle fullscreen state
         */
        toggle() {
          if (!this.isFullscreen) {
            this.enter();
          } else {
            this.exit();
          }
        }

        /**
         * @method enter
         * @description Enters fullscreen mode using browser-specific APIs.
         * Attempts standard requestFullscreen first, then falls back to prefixed versions,
         * and finally uses CSS class fallback if APIs are unavailable.
         * @returns {void}
         * @fires Element.requestFullscreen - Standard fullscreen API
         * @fires Element.webkitRequestFullscreen - WebKit prefix
         * @fires Element.mozRequestFullScreen - Mozilla prefix
         * @fires Element.msRequestFullscreen - Microsoft prefix
         * @fires Element.classList.add - Adds fullscreen-mode class
         * @fires this.updateButton - Updates button text
         * @example
         * this.enter(); // Enter fullscreen mode
         */
        enter() {
          const element = document.documentElement;

          if (element.requestFullscreen) {
            element.requestFullscreen();
          } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
          } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
          } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
          } else {
            document.body.classList.add("fullscreen-mode");
            this.isFullscreen = true;
            this.updateButton();
          }
        }

        /**
         * @method exit
         * @description Exits fullscreen mode using browser-specific APIs.
         * Attempts standard exitFullscreen first, then falls back to prefixed versions,
         * and finally uses CSS class fallback if APIs are unavailable.
         * @returns {void}
         * @fires document.exitFullscreen - Standard fullscreen API
         * @fires document.webkitExitFullscreen - WebKit prefix
         * @fires document.mozCancelFullScreen - Mozilla prefix
         * @fires document.msExitFullscreen - Microsoft prefix
         * @fires Element.classList.remove - Removes fullscreen-mode class
         * @fires this.updateButton - Updates button text
         * @example
         * this.exit(); // Exit fullscreen mode
         */
        exit() {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          } else {
            document.body.classList.remove("fullscreen-mode");
            this.isFullscreen = false;
            this.updateButton();
          }
        }

        /**
         * @method handleFullscreenChange
         * @description Handles fullscreen change events from the browser.
         * Updates internal state, applies/removes fullscreen CSS class,
         * and updates the toggle button text.
         * @returns {void}
         * @fires document.fullscreenElement - Checks current fullscreen element
         * @fires Element.classList.add - Adds fullscreen-mode class
         * @fires Element.classList.remove - Removes fullscreen-mode class
         * @fires this.updateButton - Updates button text
         * @example
         * this.handleFullscreenChange(); // Handle fullscreen state change
         */
        handleFullscreenChange() {
          this.isFullscreen = !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
          );

          if (this.isFullscreen) {
            document.body.classList.add("fullscreen-mode");
          } else {
            document.body.classList.remove("fullscreen-mode");
          }

          this.updateButton();
        }

        /**
         * @method updateButton
         * @description Updates the toggle button text based on fullscreen state.
         * Shows "Exit Fullscreen" when in fullscreen mode, "Enter Fullscreen" otherwise.
         * @returns {void}
         * @fires Element.textContent - Updates button text
         * @example
         * this.updateButton(); // Update button display
         */
        updateButton() {
          if (this.toggleBtn) {
            this.toggleBtn.textContent = this.isFullscreen
              ? "Exit Fullscreen"
              : "Enter Fullscreen";
          }
        }
      }

      /**
       * @class RealTimeAutoFactorial
       * @classdesc Intelligent factorial development with automatic multiplier calculation
       *
       * PHASE 1 - Calibration (First Print):
       * - User sets Dev timer to target time (e.g., 60s)
       * - User starts development
       * - When black appears, user presses "Mark Baseline"
       * - Tool calculates: multiplier = targetTime / elapsedTime
       * - Stores multiplier for future use
       * - Development continues normally
       *
       * PHASE 2 - Production (Subsequent Prints):
       * - User starts Dev timer (shows current target)
       * - When black appears, user presses "Black Point"
       * - Tool calculates: newTarget = elapsedTime × multiplier
       * - Stores new target for NEXT print
       * - Current development continues to completion
       * - After completion, Dev timer shows new target
       *
       * Key Features:
       * - Automatic multiplier calculation
       * - Real-time elapsed time tracking
       * - Non-intrusive (doesn't stop current development)
       * - Visual feedback at each step
       * - Works seamlessly with existing Dev timer
       */
      class RealTimeAutoFactorial {
        constructor(timerManager) {
          this.timerManager = timerManager;

          // State
          this.multiplier = null; // Calculated multiplier (e.g., 3.0)
          this.isCalibrated = false; // Has Mark Baseline been pressed?
          this.pendingNewTime = null; // New time for next print

          // For tracking
          this.devTimer = null;
          this.targetTime = null; // Current Dev timer setting
          this.elapsedTime = 0; // Current elapsed time
          this.trackingInterval = null;

          // UI refs
          this.multiplierDisplay = null;
          this.statusDisplay = null;
        }

        /**
         * Initialize and bind to Dev timer
         */
        init() {
          // Get UI elements
          this.multiplierDisplay = document.getElementById(
            "factorialMultiplier",
          );
          this.statusDisplay = document.getElementById("factorialStatus");

          // Find Dev timer
          this.devTimer = this.timerManager.timers.find(
            (t) => t.name === "Dev",
          );

          if (!this.devTimer) {
            console.error("Dev timer not found!");
            return;
          }

          // Bind events
          this.bindEvents();

          // Start tracking
          this.startTracking();

          // Initial UI update
          this.updateMultiplierDisplay();

          console.log("RealTimeAutoFactorial initialized");
        }

        /**
         * Bind button events
         */
        bindEvents() {
          // Mark Baseline button (Phase 1)
          const markBtn = document.getElementById("markBaseline");
          if (markBtn) {
            markBtn.addEventListener("click", () => this.markBaseline());
          }

          // Black Point button (Phase 2)
          const blackBtn = document.getElementById("blackPoint");
          if (blackBtn) {
            blackBtn.addEventListener("click", () => this.blackPoint());
          }

          // Reset multiplier
          const resetBtn = document.getElementById("resetMultiplier");
          if (resetBtn) {
            resetBtn.addEventListener("click", () => this.resetMultiplier());
          }
        }

        /**
         * Track Dev timer state continuously
         */
        startTracking() {
          if (this.trackingInterval) {
            clearInterval(this.trackingInterval);
          }

          this.trackingInterval = setInterval(() => {
            if (!this.devTimer) return;

            const state = this.devTimer.state;

            // Update target time from current Dev setting
            this.targetTime = state.totalTime;

            // Calculate elapsed time if running
            if (state.isRunning) {
              this.elapsedTime = state.totalTime - state.timeLeft;
            } else if (state.timeLeft === 0 && state.totalTime > 0) {
              // Timer just completed
              this.elapsedTime = state.totalTime;

              // Apply pending new time if exists
              if (this.pendingNewTime !== null) {
                this.devTimer.setTime(this.pendingNewTime);
                this.pendingNewTime = null;
                this.updateStatus(
                  `✓ Dev timer updated to ${this.devTimer.state.totalTime}s for next print`,
                  "success",
                );
              }
            } else if (state.timeLeft === state.totalTime) {
              // Timer reset
              this.elapsedTime = 0;
            }

            this.updateStatusDisplay();
          }, 100);
        }

        /**
         * MARK BASELINE - Phase 1: Calculate multiplier
         */
        markBaseline() {
          if (!this.devTimer) return;

          const state = this.devTimer.state;

          // Validation
          if (!state.isRunning && this.elapsedTime === 0) {
            this.updateStatus("❌ Start Dev timer first!", "error");
            return;
          }

          if (this.isCalibrated) {
            this.updateStatus(
              "⚠ Already calibrated! Use Black Point for new prints",
              "warning",
            );
            return;
          }

          // Get the target time (what Dev timer was set to)
          const target = this.targetTime;

          // Get elapsed time (when black appeared)
          const elapsed = this.elapsedTime;

          if (elapsed === 0) {
            this.updateStatus("❌ Wait for black to appear!", "error");
            return;
          }

          // Calculate multiplier: target / elapsed
          this.multiplier = target / elapsed;
          this.isCalibrated = true;

          // Update UI
          this.updateMultiplierDisplay();
          this.updateStatus(
            `✓ Multiplier set: ${this.multiplier.toFixed(
              2,
            )} (${target}s / ${elapsed}s)`,
            "success",
          );

          // Update button states
          this.updateButtonStates();
        }

        /**
         * BLACK POINT - Phase 2: Adjust timer based on multiplier
         */
        blackPoint() {
          if (!this.devTimer) return;

          const state = this.devTimer.state;

          // Validation
          if (!this.isCalibrated) {
            this.updateStatus(
              "❌ Mark Baseline first to set multiplier!",
              "error",
            );
            return;
          }

          if (!state.isRunning && this.elapsedTime === 0) {
            this.updateStatus("❌ Start Dev timer for this print!", "error");
            return;
          }

          // Get elapsed time (when black appeared for this print)
          const elapsed = this.elapsedTime;

          if (elapsed === 0) {
            this.updateStatus("❌ Wait for black to appear!", "error");
            return;
          }

          // Calculate new target time: elapsed × multiplier
          const newTarget = elapsed * this.multiplier;

          // Store as pending - will be applied when current timer completes
          this.pendingNewTime = newTarget;

          // Update UI
          this.updateStatus(
            `✓ Next Dev time: ${newTarget.toFixed(
              1,
            )}s (${elapsed}s × ${this.multiplier.toFixed(2)})`,
            "success",
          );

          // Flash the Dev display to show it's been noted
          const devDisplay = document.getElementById("displayDev");
          if (devDisplay) {
            devDisplay.style.color = "var(--accent)";
            devDisplay.style.fontWeight = "bold";
            setTimeout(() => {
              devDisplay.style.color = "";
              devDisplay.style.fontWeight = "";
            }, 1500);
          }
        }

        /**
         * Reset multiplier (start over)
         */
        resetMultiplier() {
          this.multiplier = null;
          this.isCalibrated = false;
          this.elapsedTime = 0;
          this.pendingNewTime = null;

          this.updateMultiplierDisplay();
          this.updateStatus(
            "Multiplier reset. Set Dev time and start first print.",
            "info",
          );
          this.updateButtonStates();
        }

        /**
         * Update multiplier display
         */
        updateMultiplierDisplay() {
          if (!this.multiplierDisplay) return;

          if (this.multiplier) {
            this.multiplierDisplay.textContent = this.multiplier.toFixed(2);
            this.multiplierDisplay.style.color = "var(--accent)";
            this.multiplierDisplay.style.fontWeight = "bold";
          } else {
            this.multiplierDisplay.textContent = "Not Set";
            this.multiplierDisplay.style.color = "";
            this.multiplierDisplay.style.fontWeight = "";
          }
        }

        /**
         * Update status text based on current state
         */
        updateStatusDisplay() {
          if (!this.statusDisplay) return;

          if (!this.isCalibrated) {
            if (this.targetTime && this.elapsedTime === 0) {
              this.statusDisplay.textContent =
                "Dev timer ready - Start and watch for black";
            } else if (this.elapsedTime > 0) {
              this.statusDisplay.textContent =
                "Black appeared? Press MARK BASELINE";
            } else {
              this.statusDisplay.textContent =
                "Set Dev time and start first print";
            }
          } else {
            if (this.pendingNewTime !== null) {
              this.statusDisplay.textContent = `Next: ${this.pendingNewTime.toFixed(
                0,
              )}s - Continue current development`;
            } else if (this.elapsedTime > 0) {
              this.statusDisplay.textContent =
                "Black appeared? Press BLACK POINT";
            } else {
              this.statusDisplay.textContent =
                "Multiplier set - Start next print";
            }
          }
        }

        /**
         * Update button states
         */
        updateButtonStates() {
          const markBtn = document.getElementById("markBaseline");
          const blackBtn = document.getElementById("blackPoint");

          if (markBtn && blackBtn) {
            if (this.isCalibrated) {
              markBtn.disabled = true;
              markBtn.style.opacity = "0.5";
              blackBtn.disabled = false;
              blackBtn.style.opacity = "1";
            } else {
              markBtn.disabled = false;
              markBtn.style.opacity = "1";
              blackBtn.disabled = true;
              blackBtn.style.opacity = "0.5";
            }
          }
        }

        /**
         * Update status message with color coding
         */
        updateStatus(message, type = "info") {
          if (!this.statusDisplay) return;

          this.statusDisplay.textContent = message;

          const colors = {
            info: "var(--text-secondary)",
            success: "var(--accent)",
            error: "var(--warning)",
            warning: "#ffaa00",
          };

          this.statusDisplay.style.color = colors[type] || colors.info;
        }

        /**
         * Get current factorial state for profile saving
         * @returns {Object} Factorial state with multiplier and calibration status
         */
        getFactorialState() {
          return {
            multiplier: this.multiplier,
            isCalibrated: this.isCalibrated,
            pendingNewTime: this.pendingNewTime,
          };
        }

        /**
         * Set factorial state from loaded profile
         * @param {Object} state - Factorial state from profile
         */
        setFactorialState(state) {
          if (state && typeof state === "object") {
            this.multiplier = state.multiplier || null;
            this.isCalibrated = state.isCalibrated || false;
            this.pendingNewTime = state.pendingNewTime || null;

            // Update UI
            this.updateMultiplierDisplay();
            this.updateStatusDisplay();
            this.updateButtonStates();

            console.log("Factorial state restored from profile:", state);
          }
        }

        /**
         * Clean up
         */
        destroy() {
          if (this.trackingInterval) {
            clearInterval(this.trackingInterval);
          }
        }
      }

      /**
       * @class LightMeterManager
       * @classdesc Light Meter / Contrast Analyzer for darkroom exposure metering.
       * Uses TSL2591X sensor via server API to measure light, calculate exposures,
       * analyze contrast, and recommend filter grades.
       *
       * EXPOSURE METER MODE:
       * - Measures lux at baseboard
       * - Calculates exposure time using calibration constant
       * - Applies filter factor for grade selection
       * - Sends calculated time to CALC tab timer
       *
       * CONTRAST ANALYZER MODE:
       * - Measures highlight and shadow areas separately
       * - Calculates ΔEV (contrast range) from the readings
       * - Recommends appropriate filter grade
       * - Calculates exposure time with recommended filter
       *
       * SPLIT-GRADE MODE:
       * - Uses highlight/shadow readings for split-grade printing
       * - Calculates separate soft/hard exposure times
       * - Supports Ilford and FOMA filter systems
       * - Sends individual times to CALC tab
       *
       * INTEGRATION:
       * - Uses same pattern as TEST STRIP to send times to CALC tab
       * - Leverages existing IncrementalTimer for exposure execution
       * - Stores calibration in localStorage for persistence
       */
      class LightMeterManager {
        constructor() {
          // Mode: 'exposure', 'contrast', or 'split'
          this.currentMode = "exposure";

          // Paper selection: stored as paper_id (e.g., 'ilford_cooltone')
          this.currentPaperId = ""; // Set after papers list is loaded
          this.papersList = []; // Will be fetched from server

          // Legacy support for old UI
          this.paperBrand = "ilford";
          this.fomaPaperType = "fomaspeed";
          this.ilfordPaperType = "cooltone";
          this.filterSystem = "ilford_cooltone";

          // Calibration profiles (lux × seconds per paper type)
          // Each paper type has its own calibration value
          this.calibrations = this.loadAllCalibrations();
          this.calibration = this.getCalibrationForCurrentPaper();


          // Sensor status
          this.sensorConnected = false;
          this.lastLux = null;

          // Stored readings for contrast analysis
          this.highlightLux = null;
          this.shadowLux = null;

          // Calculated values
          this.exposureTime = null;
          this.deltaEV = null;
          this.recommendedGrade = null;
          this.splitGradeResult = null;
          this.contrastSuggestedTime = null;

          // Virtual proof state
          this.proof = {
            width: 30,
            height: 20,
            cursor: 0,
            samples: [],
            results: [],
            referenceIndex: null,
            referenceLux: null,
            lastIndex: null,
            selectedIndex: null,
            filterGrade: "2",
            isScanning: false,
            isMeasuring: false,
            scanAbort: false,
            stability: {
              enabled: true,
              tolerancePct: 2.5,
              minStableCount: 2,
              maxWaitMs: 900,
              minDeltaLux: 0.2,
              beepOnStable: true,
            },
          };

          // Filter data will be fetched from server (no local copies)
          this.filtersCache = {}; // Cache filters per paper to reduce server calls

          this.init();
        }

        /**
         * Initialize light meter UI and event listeners
         */
        async init() {
          // Fetch papers list from server first
          await this.fetchPapersFromServer();

          // Mode selection
          this.bindModeSelection();

          // Paper/filter system selection
          this.bindPaperSelection();

          // Initialize paper brand UI (sets default to ilford)
          this.setPaperBrand("ilford");

          // Exposure mode controls
          this.bindExposureModeControls();

          // Contrast mode controls
          this.bindContrastModeControls();

          // Split-grade mode controls
          this.bindSplitModeControls();

          // Virtual proof mode controls
          this.bindProofModeControls();

          // Virtual proof settings controls
          this.bindProofSettingsControls();

          // Calibration controls
          this.bindCalibrationControls();

          // Sensor settings controls
          this.bindSensorControls();

          // Check sensor status on init
          this.checkSensorStatus();

          // Update calibration display
          this.updateCalibrationDisplay();

          // Sync current paper selection with server
          await this.syncPaperWithServer();

          console.log("LightMeterManager initialized");
        }

        /**
         * Bind mode selection segmented control
         */
        bindModeSelection() {
          document
            .querySelectorAll("#meterModeSeg .segmented-btn")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                const mode = btn.getAttribute("data-mode");
                this.setMode(mode);
              });
            });
        }

        /**
         * Set active meter mode
         */
        setMode(mode) {
          this.currentMode = mode;

          // Update segmented control
          document
            .querySelectorAll("#meterModeSeg .segmented-btn")
            .forEach((btn) => {
              const isActive = btn.getAttribute("data-mode") === mode;
              btn.classList.toggle("active", isActive);
              btn.setAttribute("aria-pressed", isActive ? "true" : "false");
            });

          // Update mode value display
          const modeNames = {
            exposure: "Exposure",
            contrast: "Contrast",
            split: "Split-Grade",
            proof: "Virtual Proof",
          };
          const modeDisplay = document.getElementById("meterModeValue");
          if (modeDisplay) modeDisplay.textContent = modeNames[mode] || mode;

          // Show/hide mode content panels
          document.getElementById("meterExposureMode").style.display =
            mode === "exposure" ? "block" : "none";
          document.getElementById("meterContrastMode").style.display =
            mode === "contrast" ? "block" : "none";
          document.getElementById("meterSplitMode").style.display =
            mode === "split" ? "block" : "none";
          document.getElementById("meterProofMode").style.display =
            mode === "proof" ? "block" : "none";
        }

        /**
         * Bind paper and filter system selection
         */
        bindPaperSelection() {
          // Paper brand buttons
          const ilfordBtn = document.getElementById("btnMeterIlford");
          const fomaBtn = document.getElementById("btnMeterFoma");

          if (ilfordBtn) {
            ilfordBtn.addEventListener("click", () => {
              this.setPaperBrand("ilford");
            });
          }

          if (fomaBtn) {
            fomaBtn.addEventListener("click", () => {
              this.setPaperBrand("foma");
            });
          }

          // Ilford paper type dropdown
          const ilfordPaperSelect = document.getElementById(
            "meterIlfordPaperType",
          );
          if (ilfordPaperSelect) {
            ilfordPaperSelect.addEventListener("change", () => {
              this.setIlfordPaperType(ilfordPaperSelect.value);
            });
          }

          // FOMA paper type dropdown
          const fomaPaperSelect = document.getElementById("meterFomaPaperType");
          if (fomaPaperSelect) {
            fomaPaperSelect.addEventListener("change", () => {
              this.setFomaPaperType(fomaPaperSelect.value);
            });
          }

          // Note: updateFilterDropdown will be called by setPaperBrand during init
        }

        /**
         * Populate paper type dropdowns from papersList (dynamically from server)
         * This replaces hardcoded values with data from paper_database
         */
        populatePaperTypeDropdowns() {
          if (!this.papersList || this.papersList.length === 0) {
            console.warn("populatePaperTypeDropdowns: papersList is empty");
            return;
          }

          // Group papers by manufacturer
          const ilfordPapers = this.papersList.filter((p) =>
            p.id.startsWith("ilford"),
          );
          const fomaPapers = this.papersList.filter((p) =>
            p.id.startsWith("foma"),
          );

          // Create mapping of paper_id to display name for Ilford
          const ilfordSelect = document.getElementById("meterIlfordPaperType");
          if (ilfordSelect && ilfordPapers.length > 0) {
            ilfordSelect.innerHTML = "";
            ilfordPapers.forEach((paper) => {
              const option = document.createElement("option");
              option.value = paper.id; // Use paper_id directly as value
              option.textContent = paper.display_name;
              ilfordSelect.appendChild(option);
            });
            // Set to previously selected if it exists, otherwise first in list
            if (
              this.currentPaperId &&
              ilfordPapers.some((paper) => paper.id === this.currentPaperId)
            ) {
              ilfordSelect.value = this.currentPaperId;
            } else {
              ilfordSelect.value = ilfordPapers[0].id;
            }
          }

          // Create mapping of paper_id to display name for FOMA
          const fomaSelect = document.getElementById("meterFomaPaperType");
          if (fomaSelect && fomaPapers.length > 0) {
            fomaSelect.innerHTML = "";
            fomaPapers.forEach((paper) => {
              const option = document.createElement("option");
              option.value = paper.id; // Use paper_id directly as value
              option.textContent = paper.display_name;
              fomaSelect.appendChild(option);
            });
            // Set to previously selected if it exists, otherwise first in list
            if (
              this.currentPaperId &&
              fomaPapers.some((paper) => paper.id === this.currentPaperId)
            ) {
              fomaSelect.value = this.currentPaperId;
            } else {
              fomaSelect.value = fomaPapers[0].id;
            }
          }

          console.log(
            `Populated Ilford dropdown with ${ilfordPapers.length} papers, FOMA with ${fomaPapers.length} papers`,
          );
        }

        /**
         * Set Ilford paper type (from dropdown) - now takes paper_id directly
         */
        setIlfordPaperType(paperId) {
          // Direct paper_id from dropdown
          this.currentPaperId = paperId;
          console.log(`setIlfordPaperType: Set to ${paperId}`);

          // Extract the suffix for UI state tracking
          const ilfordPrefixes = {
            ilford_cooltone: "cooltone",
            ilford_iv_rc_portfolio: "portfolio",
            ilford_multigrade_rc_deluxe_new: "rc_deluxe_new",
            ilford_multigrade_rc_portfolio_new: "rc_portfolio_new",
            ilford_fb_classic: "fb_classic",
            ilford_fb_warmtone: "fb_warmtone",
            ilford_fb_cooltone: "fb_cooltone",
          };
          this.ilfordPaperType = ilfordPrefixes[paperId] || "cooltone";

          // Update filter dropdowns with grades for this paper
          this.updateFilterDropdown();

          // SYNC WITH SERVER - Critical for correct grade recommendations
          this.syncFilterSystemWithServer();

          // Load calibration for new paper and update display
          this.loadCalibrationForCurrentPaper();
          this.updateCalibrationDisplay();

        }

        /**
         * Set paper brand
         */
        setPaperBrand(brand) {
          console.log(`setPaperBrand called with brand: ${brand}`);
          this.paperBrand = brand;

          // Update UI
          document
            .getElementById("btnMeterIlford")
            ?.classList.toggle("active", brand === "ilford");
          document
            .getElementById("btnMeterFoma")
            ?.classList.toggle("active", brand === "foma");

          // Show/hide paper type selectors and populate them from paper database
          const ilfordSelector = document.getElementById(
            "meterIlfordPaperSelector",
          );
          const fomaSelector = document.getElementById(
            "meterFomaPaperSelector",
          );
          console.log(
            `ilfordSelector found: ${!!ilfordSelector}, fomaSelector found: ${!!fomaSelector}`,
          );
          if (ilfordSelector) {
            const displayValue = brand === "ilford" ? "block" : "none";
            console.log(`Setting ilfordSelector display to: ${displayValue}`);
            ilfordSelector.style.display = displayValue;
          }
          if (fomaSelector) {
            const displayValue = brand === "foma" ? "block" : "none";
            console.log(`Setting fomaSelector display to: ${displayValue}`);
            fomaSelector.style.display = displayValue;
          }

          // Populate paper type dropdowns from papersList (dynamically from database)
          this.populatePaperTypeDropdowns();

          // Set appropriate paper based on brand
          if (brand === "ilford") {
            // Get the currently selected Ilford paper from dropdown
            const ilfordSelect = document.getElementById(
              "meterIlfordPaperType",
            );
            if (ilfordSelect) {
              const paperId = ilfordSelect.value;
              if (paperId) {
                this.setIlfordPaperType(paperId);
              }
            }
          } else {
            // Get the currently selected FOMA paper from dropdown
            const fomaSelect = document.getElementById("meterFomaPaperType");
            if (fomaSelect) {
              const paperId = fomaSelect.value;
              if (paperId) {
                this.setFomaPaperType(paperId);
              }
            }
          }
        }

        /**
         * Set FOMA paper type (from dropdown) - now takes paper_id directly
         */
        setFomaPaperType(paperId) {
          // Direct paper_id from dropdown
          this.currentPaperId = paperId;
          console.log(`setFomaPaperType: Set to ${paperId}`);

          // Extract the suffix for UI state tracking
          const fomaPrefixes = {
            foma_fomaspeed: "fomaspeed",
            foma_fomabrom: "fomabrom",
            foma_fomapastel_mg: "fomapastel_mg",
            fomatone_mg_classic_variant: "fomatone_mg_classic_variant",
          };
          this.fomaPaperType = fomaPrefixes[paperId] || "fomaspeed";

          // Update filter dropdowns with grades for this paper
          this.updateFilterDropdown();

          // SYNC WITH SERVER - Critical for correct grade recommendations
          this.syncFilterSystemWithServer();

          // Load calibration for new paper and update display
          this.loadCalibrationForCurrentPaper();
          this.updateCalibrationDisplay();

        }

        /**
         * Update filter grade dropdown based on current paper brand
         */
        updateFilterDropdown() {
          console.log("updateFilterDropdown called");
          const dropdown = document.getElementById("exposureFilterGrade");
          if (!dropdown) {
            console.warn("exposureFilterGrade dropdown not found");
            return;
          }

          // Clear existing options
          dropdown.innerHTML = "";

          // Add appropriate options based on filter system
          const filters = this.getFilterData();
          console.log(
            `updateFilterDropdown: got ${Object.keys(filters).length} filters`,
          );

          // Add "No Filter" option first
          const noneOption = document.createElement("option");
          noneOption.value = "";
          noneOption.textContent = "None (no filter)";
          dropdown.appendChild(noneOption);

          // Add filter options in paper-specific order
          this.getOrderedFilterEntries(filters).forEach(([grade, data]) => {
            const option = document.createElement("option");
            const factor =
              data && typeof data.factor === "number" ? data.factor : 1.0;
            const name = (data && data.name) || grade;
            option.value = grade;
            option.textContent = `${name} (×${factor.toFixed(1)})`;
            dropdown.appendChild(option);
          });

          this.updateProofFilterDropdown();

        }

        /**
         * Get ordered filter entries based on paper type
         */
        getOrderedFilterEntries(filters) {
          if (!filters || typeof filters !== "object") return [];

          const keys = Object.keys(filters).filter(
            (grade) => grade !== "" && grade !== "none",
          );

          const ilfordOrder = ["00", "0", "1", "2", "3", "4", "5"];
          const fomaOrder = ["2xY", "Y", "M1", "2xM1", "M2", "2xM2"];

          const hasIlford = ilfordOrder.some((grade) => keys.includes(grade));
          const hasFoma = fomaOrder.some((grade) => keys.includes(grade));

          const order = hasIlford ? ilfordOrder : hasFoma ? fomaOrder : keys;
          const ordered = [];

          order.forEach((grade) => {
            if (filters[grade]) {
              ordered.push([grade, filters[grade]]);
            }
          });

          keys.forEach((grade) => {
            if (!order.includes(grade) && filters[grade]) {
              ordered.push([grade, filters[grade]]);
            }
          });

          return ordered;
        }

        /**
         * Get filter data for current paper (from server metadata)
         */
        getFilterData() {
          const paperId = this.currentPaperId || this.getCurrentPaperId();
          console.log(`getFilterData: looking for paper_id=${paperId}`);
          console.log(
            `getFilterData: papersList has ${this.papersList.length} papers`,
          );

          const paper = this.papersList.find((p) => p.id === paperId);
          console.log(`getFilterData: found paper=${!!paper}`);

          if (paper && paper.filters) {
            console.log(
              `getFilterData: returning ${Object.keys(paper.filters).length} filters`,
            );
            return paper.filters;
          }

          console.warn(
            `getFilterData: No filters found for paper_id=${paperId}`,
          );
          return {};
        }

        /**
         * Fetch papers list from server
         */
        async fetchPapersFromServer() {
          try {
            const response = await fetch("/papers");
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            // Log raw response for debugging
            const responseText = await response.text();
            console.log(
              "Raw /papers response length:",
              responseText.length,
              "bytes",
            );
            console.log("First 200 chars:", responseText.substring(0, 200));
            console.log(
              "Last 200 chars:",
              responseText.substring(responseText.length - 200),
            );

            const data = JSON.parse(responseText);

            if (data.status === "success" && data.papers) {
              this.papersList = data.papers;
              console.log(`Fetched ${data.count} papers from server`);
            } else if (data.error) {
              console.error("Server returned error:", data.error);
            }
          } catch (error) {
            console.error("Failed to fetch papers from server:", error);
          }
        }

        /**
         * Sync current paper selection with server
         * Sends current paper_id to server so it uses correct paper for calculations
         */
        async syncPaperWithServer() {
          try {
            const response = await fetch(
              `/light-meter-paper?paper_id=${encodeURIComponent(this.currentPaperId)}`,
            );
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();

            if (data.status === "success") {
              console.log(`Synced paper with server: ${data.display_name}`);
            }
          } catch (error) {
            console.error("Failed to sync paper with server:", error);
          }
        }

        /**
         * Sync filter system with server (legacy method for backward compatibility)
         * Now calls syncPaperWithServer instead
         */
        async syncFilterSystemWithServer() {
          return this.syncPaperWithServer();
        }

        /**
         * Bind exposure mode controls
         */
        bindExposureModeControls() {
          // Averaging slider
          const avgSlider = document.getElementById("avgSamplesSlider");
          const avgValue = document.getElementById("avgSamplesValue");
          if (avgSlider && avgValue) {
            avgSlider.addEventListener("input", () => {
              avgValue.textContent = avgSlider.value;
            });
          }

          // Measure button
          const measureBtn = document.getElementById("measureLuxBtn");
          if (measureBtn) {
            measureBtn.addEventListener("click", () => this.measureLux());
          }

          // Send to CALC button
          const sendBtn = document.getElementById("sendExposureToCalc");
          if (sendBtn) {
            sendBtn.addEventListener("click", () => this.sendExposureToCalc());
          }

          // Filter grade change
          const filterSelect = document.getElementById("exposureFilterGrade");
          if (filterSelect) {
            filterSelect.addEventListener("change", () => {
              if (this.lastLux) {
                this.calculateExposureTime(this.lastLux);
              }
            });
          }
        }

        /**
         * Bind contrast mode controls
         */
        bindContrastModeControls() {
          // Averaging slider
          const avgSlider = document.getElementById("contrastAvgSamplesSlider");
          const avgValue = document.getElementById("contrastAvgSamplesValue");
          if (avgSlider && avgValue) {
            avgSlider.addEventListener("input", () => {
              avgValue.textContent = avgSlider.value;
            });
          }

          // Highlight measure button
          const highlightBtn = document.getElementById("measureHighlightBtn");
          if (highlightBtn) {
            highlightBtn.addEventListener("click", () =>
              this.measureHighlight("contrast"),
            );
          }

          // Shadow measure button
          const shadowBtn = document.getElementById("measureShadowBtn");
          if (shadowBtn) {
            shadowBtn.addEventListener("click", () =>
              this.measureShadow("contrast"),
            );
          }

          // Analyze button
          const analyzeBtn = document.getElementById("analyzeContrastBtn");
          if (analyzeBtn) {
            analyzeBtn.addEventListener("click", () => this.analyzeContrast());
          }

          // Send suggested time to CALC button
          const sendContrastBtn = document.getElementById("sendContrastToCalc");
          if (sendContrastBtn) {
            sendContrastBtn.addEventListener("click", () =>
              this.sendContrastToCalc(),
            );
          }

          // Clear button
          const clearBtn = document.getElementById("clearContrastBtn");
          if (clearBtn) {
            clearBtn.addEventListener("click", () =>
              this.clearContrastReadings(),
            );
          }
        }

        /**
         * Bind split-grade mode controls
         */
        bindSplitModeControls() {
          // Averaging slider
          const avgSlider = document.getElementById("splitAvgSamplesSlider");
          const avgValue = document.getElementById("splitAvgSamplesValue");
          if (avgSlider && avgValue) {
            avgSlider.addEventListener("input", () => {
              avgValue.textContent = avgSlider.value;
            });
          }

          // Highlight measure button
          const highlightBtn = document.getElementById(
            "splitMeasureHighlightBtn",
          );
          if (highlightBtn) {
            highlightBtn.addEventListener("click", () =>
              this.measureHighlight("split"),
            );
          }

          // Shadow measure button
          const shadowBtn = document.getElementById("splitMeasureShadowBtn");
          if (shadowBtn) {
            shadowBtn.addEventListener("click", () =>
              this.measureShadow("split"),
            );
          }

          // Calculate button
          const calcBtn = document.getElementById("calculateSplitBtn");
          if (calcBtn) {
            calcBtn.addEventListener("click", () => this.calculateSplitGrade());
          }

          // Send to CALC buttons
          const sendBothBtn = document.getElementById("sendSplitBothToCalc");
          if (sendBothBtn) {
            sendBothBtn.addEventListener("click", () =>
              this.sendSplitBothToCalc(),
            );
          }

          // Clear button
          const clearBtn = document.getElementById("clearSplitBtn");
          if (clearBtn) {
            clearBtn.addEventListener("click", () => this.clearSplitReadings());
          }
        }

        /**
         * Bind virtual proof mode controls
         */
        bindProofModeControls() {
          const widthInput = document.getElementById("proofGridWidth");
          const heightInput = document.getElementById("proofGridHeight");
          const applyBtn = document.getElementById("proofApplyGridBtn");
          const measureBtn = document.getElementById("proofMeasureNextBtn");
          const setRefBtn = document.getElementById("proofSetReferenceBtn");
          const recomputeBtn = document.getElementById("proofRecomputeBtn");
          const clearBtn = document.getElementById("proofClearBtn");
          const avgSlider = document.getElementById("proofAvgSamplesSlider");
          const avgValue = document.getElementById("proofAvgSamplesValue");
          const filterSelect = document.getElementById("proofFilterGrade");

          if (avgSlider && avgValue) {
            avgSlider.addEventListener("input", () => {
              avgValue.textContent = avgSlider.value;
            });
          }

          if (applyBtn) {
            applyBtn.addEventListener("click", async () => {
              await this.stopProofScan();
              const width = parseInt(widthInput?.value || "0", 10);
              const height = parseInt(heightInput?.value || "0", 10);
              this.configureProofGrid(width, height);
            });
          }

          if (measureBtn) {
            measureBtn.addEventListener("click", () => this.toggleProofScan());
          }

          if (setRefBtn) {
            setRefBtn.addEventListener("click", async () => {
              await this.stopProofScan();
              if (this.proof.selectedIndex !== null) {
                this.setProofReference(this.proof.selectedIndex);
              }
            });
          }

          if (recomputeBtn) {
            recomputeBtn.addEventListener("click", async () => {
              await this.stopProofScan();
              this.recomputeProofResults();
            });
          }

          if (clearBtn) {
            clearBtn.addEventListener("click", async () => {
              await this.stopProofScan();
              this.clearProofGrid();
            });
          }

          if (filterSelect) {
            filterSelect.addEventListener("change", () => {
              this.proof.filterGrade = filterSelect.value;
              if (this.proof.referenceLux !== null) {
                this.recomputeProofResults();
              }
            });
          }

          this.updateProofFilterDropdown();
          this.configureProofGrid(this.proof.width, this.proof.height, true);
        }

        bindProofSettingsControls() {
          const enabledToggle = document.getElementById(
            "proofStabilityEnabled",
          );
          const beepToggle = document.getElementById("proofStabilityBeep");
          const toleranceInput = document.getElementById(
            "proofStabilityTolerance",
          );
          const minStableInput = document.getElementById(
            "proofStabilityMinStable",
          );
          const maxWaitInput = document.getElementById("proofStabilityMaxWait");
          const minDeltaInput = document.getElementById("proofStabilityMinDelta");

          const stability = this.proof.stability || {};
          if (enabledToggle) enabledToggle.checked = !!stability.enabled;
          if (beepToggle) beepToggle.checked = !!stability.beepOnStable;
          if (toleranceInput) {
            toleranceInput.value = stability.tolerancePct ?? 2.5;
          }
          if (minStableInput) {
            minStableInput.value = stability.minStableCount ?? 2;
          }
          if (maxWaitInput) {
            maxWaitInput.value = stability.maxWaitMs ?? 900;
          }
          if (minDeltaInput) {
            minDeltaInput.value = stability.minDeltaLux ?? 0.2;
          }

          const applySettings = () => {
            if (enabledToggle) {
              this.proof.stability.enabled = enabledToggle.checked;
            }
            if (beepToggle) {
              this.proof.stability.beepOnStable = beepToggle.checked;
            }
            if (toleranceInput) {
              const value = parseFloat(toleranceInput.value);
              this.proof.stability.tolerancePct =
                Number.isFinite(value) && value > 0 ? value : 2.5;
            }
            if (minStableInput) {
              const value = parseInt(minStableInput.value, 10);
              this.proof.stability.minStableCount =
                Number.isFinite(value) && value > 0 ? value : 2;
            }
            if (maxWaitInput) {
              const value = parseInt(maxWaitInput.value, 10);
              this.proof.stability.maxWaitMs =
                Number.isFinite(value) && value > 0 ? value : 900;
            }
            if (minDeltaInput) {
              const value = parseFloat(minDeltaInput.value);
              this.proof.stability.minDeltaLux =
                Number.isFinite(value) && value > 0 ? value : 0.2;
            }
          };

          [
            enabledToggle,
            beepToggle,
            toleranceInput,
            minStableInput,
            maxWaitInput,
            minDeltaInput,
          ].forEach((element) => {
            if (!element) return;
            element.addEventListener("change", applySettings);
            element.addEventListener("input", applySettings);
          });
        }

        updateProofFilterDropdown() {
          const dropdown = document.getElementById("proofFilterGrade");
          if (!dropdown) {
            return;
          }

          const current = this.proof.filterGrade || dropdown.value;
          dropdown.innerHTML = "";

          const noneOption = document.createElement("option");
          noneOption.value = "";
          noneOption.textContent = "None (no filter)";
          dropdown.appendChild(noneOption);

          const filters = this.getFilterData();
          this.getOrderedFilterEntries(filters).forEach(([grade, data]) => {
            const option = document.createElement("option");
            const factor =
              data && typeof data.factor === "number" ? data.factor : 1.0;
            const isoR =
              data && typeof data.iso_r === "number" ? data.iso_r : null;
            const name = (data && data.name) || grade;
            option.value = grade;
            const isoLabel = isoR !== null ? `ISO R ${Math.round(isoR)}` : "ISO R --";
            option.textContent = `${name} (${isoLabel}, ×${factor.toFixed(1)})`;
            dropdown.appendChild(option);
          });

          if (current && dropdown.querySelector(`option[value="${current}"]`)) {
            dropdown.value = current;
          } else if (filters["2"]) {
            dropdown.value = "2";
            this.proof.filterGrade = "2";
          } else {
            dropdown.value = "";
            this.proof.filterGrade = "";
          }
        }

        configureProofGrid(width, height, keepReference = false) {
          const safeWidth = Math.min(Math.max(width || 1, 1), 50);
          const safeHeight = Math.min(Math.max(height || 1, 1), 50);
          const total = safeWidth * safeHeight;

          this.proof.width = safeWidth;
          this.proof.height = safeHeight;
          this.proof.cursor = 0;
          this.proof.isScanning = false;
          this.proof.isMeasuring = false;
          this.proof.scanAbort = false;
          this.proof.samples = Array(total).fill(null);
          this.proof.results = Array(total).fill(null);
          this.proof.lastIndex = null;
          this.proof.selectedIndex = null;

          if (!keepReference) {
            this.proof.referenceIndex = null;
            this.proof.referenceLux = null;
          }

          const totalDisplay = document.getElementById("proofGridTotal");
          if (totalDisplay) {
            totalDisplay.textContent = `${safeWidth} x ${safeHeight} (${total})`;
          }

          this.renderProofGrid();
          this.updateProofStatus();
          this.setProofScanStatus("Idle");
          this.updateProofHistogram();
        }

        renderProofGrid() {
          const grid = document.getElementById("proofGrid");
          if (!grid) return;

          grid.innerHTML = "";
          grid.style.gridTemplateColumns = `repeat(${this.proof.width}, 1fr)`;
          grid.style.gridTemplateRows = `repeat(${this.proof.height}, 1fr)`;

          const total = this.proof.width * this.proof.height;
          for (let i = 0; i < total; i += 1) {
            const cell = document.createElement("div");
            cell.className = "proof-cell";
            cell.id = `proofCell-${i}`;
            cell.addEventListener("click", async () => {
              await this.stopProofScan();
              this.selectProofCell(i);
            });
            grid.appendChild(cell);
            this.updateProofGridCell(i);
          }
        }

        updateProofGridCell(index) {
          const cell = document.getElementById(`proofCell-${index}`);
          if (!cell) return;

          const result = this.proof.results[index];
          const hasSample = this.proof.samples[index] !== null;
          const cursorIndex = this.getProofCursorIndex();

          cell.classList.toggle("proof-cursor", index === cursorIndex);
          cell.classList.toggle(
            "proof-reference",
            index === this.proof.referenceIndex,
          );
          cell.classList.toggle(
            "proof-selected",
            index === this.proof.selectedIndex,
          );
          cell.classList.toggle(
            "proof-clipped-white",
            !!(result && result.clipped_white),
          );
          cell.classList.toggle(
            "proof-clipped-black",
            !!(result && result.clipped_black),
          );

          if (result && typeof result.grayscale === "number") {
            const g = Math.max(0, Math.min(255, result.grayscale));
            cell.style.background = `rgb(${g}, ${g}, ${g})`;
          } else if (hasSample) {
            cell.style.background = "#333";
          } else {
            cell.style.background = "#111";
          }

          if (result && typeof result.zone === "number") {
            const densityLabel =
              result && typeof result.density === "number"
                ? ` | D ${result.density.toFixed(2)}`
                : "";
            cell.title = `Zone ${result.zone.toFixed(1)}${densityLabel}`;
          } else if (hasSample) {
            cell.title = "Measured";
          } else {
            cell.title = "Empty";
          }
        }

        updateProofStatus() {
          const total = this.proof.width * this.proof.height;
          const measured = this.proof.samples.filter((v) => v !== null).length;
          const progress = document.getElementById("proofScanProgress");
          if (progress) {
            progress.textContent = `${measured}/${total}`;
          }

          const measureBtn = document.getElementById("proofMeasureNextBtn");
          if (measureBtn) {
            if (this.proof.isScanning) {
              measureBtn.disabled = false;
              measureBtn.textContent = "Stop Scan";
            } else if (this.proof.cursor >= total) {
              measureBtn.disabled = true;
              measureBtn.textContent = "Scan Complete";
            } else {
              measureBtn.disabled = false;
              measureBtn.textContent = "Start Scan";
            }
          }

          const setRefBtn = document.getElementById("proofSetReferenceBtn");
          if (setRefBtn) {
            setRefBtn.disabled = this.proof.selectedIndex === null;
          }

          const recomputeBtn = document.getElementById("proofRecomputeBtn");
          if (recomputeBtn) {
            recomputeBtn.disabled =
              this.proof.referenceLux === null || measured === 0;
          }
        }

        updateProofHistogram() {
          const canvas = document.getElementById("proofHistogram");
          if (!canvas) return;

          const ctx = canvas.getContext("2d");
          if (!ctx) return;

          const width = canvas.clientWidth || 240;
          const height = canvas.clientHeight || 90;
          const dpr = window.devicePixelRatio || 1;
          const scaledWidth = Math.max(1, Math.floor(width * dpr));
          const scaledHeight = Math.max(1, Math.floor(height * dpr));

          if (canvas.width !== scaledWidth || canvas.height !== scaledHeight) {
            canvas.width = scaledWidth;
            canvas.height = scaledHeight;
          }

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(dpr, dpr);
          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = "#0b0b0b";
          ctx.fillRect(0, 0, width, height);

          const values = [];
          for (const result of this.proof.results) {
            if (!result || typeof result.grayscale !== "number") continue;
            const clamped = Math.max(0, Math.min(255, result.grayscale));
            values.push(clamped);
          }

          if (values.length === 0) {
            return;
          }

          const binCount = 64;
          const bins = Array(binCount).fill(0);
          for (const value of values) {
            const bin = Math.min(
              binCount - 1,
              Math.floor((value / 256) * binCount),
            );
            bins[bin] += 1;
          }

          // Apply gaussian smoothing to reduce spikes
          const smoothBins = Array(binCount).fill(0);
          const kernel = [0.27, 0.46, 0.27]; // Simple 3-point gaussian
          for (let i = 0; i < binCount; i += 1) {
            let sum = 0;
            let weightSum = 0;
            for (let j = -1; j <= 1; j += 1) {
              const idx = i + j;
              if (idx >= 0 && idx < binCount) {
                sum += bins[idx] * kernel[j + 1];
                weightSum += kernel[j + 1];
              }
            }
            smoothBins[i] = sum / weightSum;
          }

          const maxCount = Math.max(...smoothBins);
          if (maxCount <= 0) {
            return;
          }

          // Draw smooth curve using quadratic interpolation
          ctx.beginPath();
          ctx.moveTo(0, height);
          
          // First point
          const x0 = 0;
          const y0 = height - (smoothBins[0] / maxCount) * height;
          ctx.lineTo(x0, y0);
          
          // Draw smooth curve through all points
          for (let i = 0; i < binCount; i += 1) {
            const x1 = ((i + 0.5) / binCount) * width;
            const y1 = height - (smoothBins[i] / maxCount) * height;
            
            if (i < binCount - 1) {
              const x2 = ((i + 1.5) / binCount) * width;
              const y2 = height - (smoothBins[i + 1] / maxCount) * height;
              
              // Control point at midpoint for smooth curve
              const cpX = (x1 + x2) / 2;
              const cpY = (y1 + y2) / 2;
              ctx.quadraticCurveTo(x1, y1, cpX, cpY);
            } else {
              // Last point
              ctx.lineTo(x1, y1);
            }
          }
          
          ctx.lineTo(width, height);
          ctx.closePath();

          ctx.fillStyle = "rgba(220, 220, 220, 0.85)";
          ctx.fill();
          ctx.strokeStyle = "rgba(250, 250, 250, 0.9)";
          ctx.lineWidth = 1;
          ctx.stroke();
        }

        setProofScanStatus(message) {
          const status = document.getElementById("proofScanStatus");
          if (status) {
            status.textContent = message;
          }
        }

        async fetchProofLux(samples) {
          const params = new URLSearchParams({
            samples: samples,
            calibration: this.calibration,
          });

          const response = await fetch("/light-meter?" + params.toString());
          const data = await response.json();

          if (data.status !== "success") {
            const errorMessage = data.error || "Measurement error";
            throw new Error(errorMessage);
          }

          return data;
        }

        async waitForProofStability() {
          const stability = this.proof.stability || {};
          const maxWaitMs = stability.maxWaitMs || 900;
          const tolerancePct = stability.tolerancePct || 2.5;
          const minStableCount = stability.minStableCount || 2;
          const minDeltaLux = stability.minDeltaLux || 0.2;

          const startTime = Date.now();
          let lastLux = null;
          let stableCount = 0;

          this.setProofScanStatus("Hold still...");

          while (Date.now() - startTime < maxWaitMs) {
            if (this.proof.scanAbort) {
              return { stable: false, lux: null, cancelled: true };
            }

            let currentLux = null;
            try {
              const data = await this.fetchProofLux(1);
              currentLux = data.lux;
            } catch (error) {
              this.showFeedback("Stability error: " + error.message, "error");
              return { stable: false, lux: null, cancelled: false };
            }

            if (!currentLux || currentLux <= 0) {
              continue;
            }

            if (lastLux !== null) {
              const tolerance = Math.max(
                minDeltaLux,
                Math.abs(lastLux) * (tolerancePct / 100),
              );
              if (Math.abs(currentLux - lastLux) <= tolerance) {
                stableCount += 1;
              } else {
                stableCount = 0;
              }
            }

            lastLux = currentLux;

            if (stableCount >= minStableCount) {
              this.setProofScanStatus("Stable");
              if (stability.beepOnStable) {
                playBeep(600, 0.1, 0.2);
              }
              return { stable: true, lux: currentLux, cancelled: false };
            }
          }

          this.setProofScanStatus("Stability timeout");
          return { stable: false, lux: lastLux, cancelled: false };
        }

        async measureProofNext() {
          const total = this.proof.width * this.proof.height;
          if (this.proof.cursor >= total) {
            this.showFeedback("Grid scan complete", "success");
            return false;
          }

          if (this.proof.isMeasuring) {
            return false;
          }

          const samples =
            parseInt(document.getElementById("proofAvgSamplesSlider").value) ||
            5;
          const measureBtn = document.getElementById("proofMeasureNextBtn");
          const index = this.getProofCursorIndex();
          const allowStop = this.proof.isScanning;

          if (index === null) {
            this.showFeedback("Invalid scan position", "error");
            return false;
          }

          if (measureBtn && !allowStop) {
            measureBtn.disabled = true;
            measureBtn.textContent = "Measuring...";
          }

          this.proof.isMeasuring = true;

          const stability = this.proof.stability || {};
          let stableLux = null;
          if (stability.enabled) {
            const stabilityResult = await this.waitForProofStability();
            if (stabilityResult.cancelled) {
              this.proof.isMeasuring = false;
              this.updateProofStatus();
              return false;
            }
            if (!stabilityResult.stable) {
              this.showFeedback(
                "Stability timeout. Hold still and try again.",
                "error",
              );
              this.proof.isMeasuring = false;
              this.updateProofStatus();
              return false;
            }
            stableLux = stabilityResult.lux;
          }

          try {
            let data = null;
            if (samples === 1 && stableLux !== null) {
              data = { status: "success", lux: stableLux };
            } else {
              data = await this.fetchProofLux(samples);
            }

            if (data.status === "success") {
              this.proof.samples[index] = data.lux;
              this.proof.lastIndex = index;

              await this.updateProofResult(index);
              this.proof.cursor += 1;

              this.updateProofGridCell(index);
              const nextCursorIndex = this.getProofCursorIndex();
              if (nextCursorIndex !== null) {
                this.updateProofGridCell(nextCursorIndex);
              }
              this.updateProofStatus();
              if (!stability.enabled) {
                playBeep(800, 0.3, 0.2);
              }
              this.setProofScanStatus("Captured");
              return true;
            } else {
              this.showFeedback("Measurement error: " + data.error, "error");
            }
          } catch (error) {
            this.showFeedback("Connection error: " + error.message, "error");
          } finally {
            this.proof.isMeasuring = false;
            this.updateProofStatus();
          }

          return false;
        }

        async updateProofResult(index) {
          const lux = this.proof.samples[index];
          if (!lux || lux <= 0) return;

          try {
            const paperId = this.currentPaperId || this.getCurrentPaperId();
            const params = new URLSearchParams({
              lux: lux,
              calibration: this.calibration,
              paper_id: paperId,
            });

            if (this.proof.referenceLux) {
              params.append("reference_lux", this.proof.referenceLux);
            }

            if (this.proof.filterGrade) {
              params.append("filter", this.proof.filterGrade);
            }

            const response = await fetch(
              "/light-meter-virtual-proof?" + params.toString(),
            );
            const data = await response.json();

            if (data.status === "success" && data.result) {
              this.proof.results[index] = data.result;
              this.updateProofGridCell(index);
              this.updateProofSampleInfo(index, data.result);
            } else {
              this.showFeedback("Preview error: " + data.error, "error");
            }
          } catch (error) {
            this.showFeedback("Preview error: " + error.message, "error");
          }
        }

        updateProofSampleInfo(index, result, forceUpdate = false) {
          // Only update if this is the last measured cell or explicitly forced
          if (!forceUpdate && index !== this.proof.lastIndex) return;

          const luxDisplay = document.getElementById("proofLastLux");
          const zoneDisplay = document.getElementById("proofLastZone");
          const isoDisplay = document.getElementById("proofLastIsoR");
          const evDisplay = document.getElementById("proofLastEvRange");
          const densityDisplay = document.getElementById("proofLastDensity");
          const clippingDisplay = document.getElementById("proofLastClipping");

          if (luxDisplay) {
            luxDisplay.textContent = `Lux: ${this.proof.samples[
              index
            ].toFixed(1)}`;
          }
          if (zoneDisplay) {
            if (result && typeof result.zone === "number") {
              zoneDisplay.textContent = `Zone: ${result.zone.toFixed(1)}`;
            } else {
              zoneDisplay.textContent = "Zone: --";
            }
          }
          if (isoDisplay) {
            if (result && typeof result.iso_r === "number") {
              isoDisplay.textContent = `ISO R: ${Math.round(result.iso_r)}`;
            } else {
              isoDisplay.textContent = "ISO R: --";
            }
          }
          if (evDisplay) {
            if (result && typeof result.printable_ev === "number") {
              evDisplay.textContent = `EV Range: ${result.printable_ev.toFixed(1)}`;
            } else {
              evDisplay.textContent = "EV Range: --";
            }
          }
          if (densityDisplay) {
            if (result && typeof result.density === "number") {
              densityDisplay.textContent = `Density: ${result.density.toFixed(2)}`;
            } else {
              densityDisplay.textContent = "Density: --";
            }
          }
          if (clippingDisplay) {
            const clips = [];
            if (result?.clipped_white) clips.push("paper white");
            if (result?.clipped_black) clips.push("max black");
            clippingDisplay.textContent =
              clips.length > 0 ? `Clipping: ${clips.join(", ")}` : "Clipping: --";
          }
        }

        async recomputeProofResults() {
          await this.stopProofScan();
          const total = this.proof.width * this.proof.height;
          const recomputeBtn = document.getElementById("proofRecomputeBtn");
          if (recomputeBtn) {
            recomputeBtn.disabled = true;
            recomputeBtn.textContent = "Recomputing...";
          }

          for (let i = 0; i < total; i += 1) {
            if (this.proof.samples[i] !== null) {
              await this.updateProofResult(i);
            }
          }

          if (recomputeBtn) {
            recomputeBtn.textContent = "Recompute Preview";
          }

          this.updateProofStatus();
          this.updateProofHistogram();
        }

        selectProofCell(index) {
          const lux = this.proof.samples[index];
          const result = this.proof.results[index];
          
          if (lux === null) {
            this.showFeedback("This cell has not been measured yet", "error");
            return;
          }

          // Update selected index and refresh UI
          const previousSelected = this.proof.selectedIndex;
          this.proof.selectedIndex = index;
          
          if (previousSelected !== null) {
            this.updateProofGridCell(previousSelected);
          }
          this.updateProofGridCell(index);
          
          // Display cell info in LAST SAMPLE box
          this.updateProofSampleInfo(index, result, true);
          
          // Update button state
          this.updateProofStatus();
        }

        setProofReference(index) {
          this.stopProofScan();
          const lux = this.proof.samples[index];
          if (lux === null) {
            this.showFeedback("Measure a cell before setting reference", "error");
            return;
          }

          // Clear previous selection when setting reference
          const previousSelected = this.proof.selectedIndex;
          this.proof.selectedIndex = null;

          this.proof.referenceIndex = index;
          this.proof.referenceLux = lux;

          // Update previous selected cell if it exists
          if (previousSelected !== null && previousSelected !== index) {
            this.updateProofGridCell(previousSelected);
          }

          this.renderProofGrid();
          this.recomputeProofResults();
        }

        clearProofGrid() {
          this.configureProofGrid(this.proof.width, this.proof.height, false);
          const luxDisplay = document.getElementById("proofLastLux");
          const zoneDisplay = document.getElementById("proofLastZone");
          const isoDisplay = document.getElementById("proofLastIsoR");
          const evDisplay = document.getElementById("proofLastEvRange");
          const densityDisplay = document.getElementById("proofLastDensity");
          const clippingDisplay = document.getElementById("proofLastClipping");
          if (luxDisplay) luxDisplay.textContent = "Lux: --";
          if (zoneDisplay) zoneDisplay.textContent = "Zone: --";
          if (isoDisplay) isoDisplay.textContent = "ISO R: --";
          if (evDisplay) evDisplay.textContent = "EV Range: --";
          if (densityDisplay) densityDisplay.textContent = "Density: --";
          if (clippingDisplay) clippingDisplay.textContent = "Clipping: --";
          this.updateProofHistogram();
        }

        getProofCursorIndex() {
          return this.proofStepToIndex(this.proof.cursor);
        }

        proofStepToIndex(step) {
          const total = this.proof.width * this.proof.height;
          if (step < 0 || step >= total) {
            return null;
          }

          const row = Math.floor(step / this.proof.width);
          let col = step % this.proof.width;
          if (row % 2 === 1) {
            col = this.proof.width - 1 - col;
          }

          return row * this.proof.width + col;
        }

        async toggleProofScan() {
          if (this.proof.isScanning) {
            await this.stopProofScan();
          } else {
            await this.startProofScan();
          }
        }

        async startProofScan() {
          const total = this.proof.width * this.proof.height;
          if (this.proof.isScanning) {
            return;
          }

          if (this.proof.cursor >= total) {
            this.showFeedback("Grid scan complete", "success");
            this.updateProofStatus();
            return;
          }

          this.proof.isScanning = true;
          this.proof.scanAbort = false;
          this.setProofScanStatus("Scanning...");
          this.updateProofStatus();

          while (this.proof.cursor < total && !this.proof.scanAbort) {
            const measured = await this.measureProofNext();
            if (!measured) {
              break;
            }
          }

          this.proof.isScanning = false;
          if (!this.proof.scanAbort) {
            this.setProofScanStatus("Idle");
            this.autoSelectMiddleGray();
          }
          this.updateProofStatus();
        }

        async stopProofScan() {
          if (!this.proof.isScanning && !this.proof.isMeasuring) {
            return;
          }

          this.proof.scanAbort = true;
          while (this.proof.isMeasuring) {
            await new Promise((resolve) => setTimeout(resolve, 50));
          }

          this.proof.isScanning = false;
          this.setProofScanStatus("Idle");
          this.updateProofStatus();
        }

        autoSelectMiddleGray() {
          const validSamples = this.proof.samples.filter(
            (lux) => lux !== null && lux > 0,
          );

          if (validSamples.length === 0) {
            return;
          }

          // Calculate geometric mean (same as CONTRAST ANALYZER)
          // Geometric mean = exp(mean(log(values)))
          const geometricMean = Math.exp(
            validSamples.reduce((sum, lux) => sum + Math.log(lux), 0) /
              validSamples.length,
          );

          // Find the cell closest to the geometric mean (in log space for photographic accuracy)
          let closestIndex = null;
          let closestDistance = Infinity;

          this.proof.samples.forEach((lux, index) => {
            if (lux === null || lux <= 0) return;

            // Distance in log space (EV space)
            const distance = Math.abs(Math.log(lux) - Math.log(geometricMean));
            if (distance < closestDistance) {
              closestDistance = distance;
              closestIndex = index;
            }
          });

          // Set the reference automatically
          if (closestIndex !== null) {
            this.proof.referenceIndex = closestIndex;
            this.proof.referenceLux = this.proof.samples[closestIndex];
            this.renderProofGrid();
            this.recomputeProofResults();

            this.showFeedback(
              `Auto-selected Zone V reference: ${this.proof.referenceLux.toFixed(
                1,
              )} lux (geometric mean)`,
              "success",
            );
            playBeep(1000, 0.3, 0.3);
          }
        }

        /**
         * Bind calibration controls
         */
        bindCalibrationControls() {
          // Manual calibration input
          const calInput = document.getElementById("calibrationInput");
          if (calInput) {
            calInput.value = this.calibration;
          }

          // Calculate calibration button
          const calcCalBtn = document.getElementById("calculateCalibrationBtn");
          if (calcCalBtn) {
            calcCalBtn.addEventListener("click", () =>
              this.calculateCalibration(),
            );
          }

          // Save calibration button
          const saveBtn = document.getElementById("saveCalibrationBtn");
          if (saveBtn) {
            saveBtn.addEventListener("click", () =>
              this.saveCalibrationFromInput(),
            );
          }
        }

        /**
         * Bind sensor settings controls
         */
        bindSensorControls() {
          // Apply sensor settings
          const applyBtn = document.getElementById("applySensorSettingsBtn");
          if (applyBtn) {
            applyBtn.addEventListener("click", () =>
              this.applySensorSettings(),
            );
          }

          // Refresh status
          const refreshBtn = document.getElementById("refreshSensorStatusBtn");
          if (refreshBtn) {
            refreshBtn.addEventListener("click", () =>
              this.checkSensorStatus(),
            );
          }
        }

        /**
         * Check sensor status via API
         */
        async checkSensorStatus() {
          const statusDisplay = document.getElementById("sensorStatus");

          try {
            const response = await fetch("/light-meter-config");
            const data = await response.json();

            if (data.status === "success" && data.light_meter) {
              const sensor = data.light_meter.sensor;
              this.sensorConnected = sensor.connected;

              if (sensor.connected) {
                statusDisplay.textContent = "Connected";
                statusDisplay.style.color = "var(--accent)";

                // Update sensor info
                document.getElementById("sensorGain").textContent =
                  sensor.gain || "Unknown";
                document.getElementById("sensorIntegration").textContent =
                  (sensor.integration_ms || 300) + "ms";
              } else {
                statusDisplay.textContent = "Not Connected";
                statusDisplay.style.color = "var(--danger)";
              }
            } else {
              statusDisplay.textContent = "Not Available";
              statusDisplay.style.color = "var(--danger)";
              this.sensorConnected = false;
            }
          } catch (error) {
            statusDisplay.textContent = "Error: " + error.message;
            statusDisplay.style.color = "var(--danger)";
            this.sensorConnected = false;
          }
        }

        /**
         * Apply sensor settings
         */
        async applySensorSettings() {
          const gain = document.getElementById("sensorGainSelect").value;
          const integration = document.getElementById(
            "sensorIntegrationSelect",
          ).value;
          const paperId = this.currentPaperId || this.getCurrentPaperId();

          try {
            const params = new URLSearchParams();
            if (paperId) params.append("paper_id", paperId);
            if (gain) params.append("gain", gain);
            if (integration) params.append("integration", integration);

            const response = await fetch(
              "/light-meter-config?" + params.toString(),
            );
            const data = await response.json();

            if (data.status === "success") {
              this.showFeedback("Sensor settings applied", "success");
              this.checkSensorStatus();
            } else {
              this.showFeedback("Error: " + data.error, "error");
            }
          } catch (error) {
            this.showFeedback("Connection error: " + error.message, "error");
          }
        }

        /**
         * Measure lux (exposure mode)
         */
        async measureLux() {
          const samples =
            parseInt(document.getElementById("avgSamplesSlider").value) || 5;
          const filterGrade = document.getElementById(
            "exposureFilterGrade",
          ).value;

          const luxDisplay = document.getElementById("luxReading");
          const varianceDisplay = document.getElementById("luxVariance");
          const measureBtn = document.getElementById("measureLuxBtn");

          // Show loading state
          measureBtn.disabled = true;
          measureBtn.textContent = "Measuring...";
          luxDisplay.textContent = "...";

          try {
            const params = new URLSearchParams({
              samples: samples,
              calibration: this.calibration,
              filter: filterGrade,
            });

            const response = await fetch("/light-meter?" + params.toString());
            const data = await response.json();

            if (data.status === "success") {
              this.lastLux = data.lux;
              luxDisplay.textContent = data.lux.toFixed(1) + " lux";
              varianceDisplay.textContent = data.variance
                ? data.variance.toFixed(2)
                : "--";

              // Use server's calculated exposure time (includes filter factor)
              this.exposureTime = data.exposure_time;
              const timeDisplay = document.getElementById("meterExposureTime");
              if (timeDisplay) {
                timeDisplay.textContent = data.exposure_time.toFixed(2);
              }

              // Enable send button
              document.getElementById("sendExposureToCalc").disabled = false;

              playBeep(800, 0.3, 0.2);
            } else {
              luxDisplay.textContent = "Error";
              this.showFeedback("Measurement error: " + data.error, "error");
            }
          } catch (error) {
            luxDisplay.textContent = "Error";
            this.showFeedback("Connection error: " + error.message, "error");
          } finally {
            measureBtn.disabled = false;
            measureBtn.textContent = "MEASURE LUX";
          }
        }

        /**
         * Calculate exposure time from lux reading
         */
        calculateExposureTime(lux) {
          if (!lux || lux <= 0) return;

          const filterGrade = document.getElementById(
            "exposureFilterGrade",
          ).value;
          const filters = this.getFilterData();
          const filterData = filters[filterGrade] || filters[""];
          const factor = filterData.factor;

          // Base exposure time
          let time = this.calibration / lux;

          // Apply filter factor
          time *= factor;

          this.exposureTime = time;

          // Update display
          const timeDisplay = document.getElementById("meterExposureTime");
          if (timeDisplay) {
            timeDisplay.textContent = time.toFixed(2);
          }
        }

        /**
         * Send exposure time to CALC tab
         */
        sendExposureToCalc() {
          if (!this.exposureTime || this.exposureTime <= 0) {
            this.showFeedback("No exposure time calculated", "error");
            return;
          }

          this.sendTimeToCalc(this.exposureTime, "Exposure meter");
        }

        /**
         * Measure highlight area
         */
        async measureHighlight(mode = "contrast") {
          const samples =
            parseInt(
              document.getElementById(
                mode === "split"
                  ? "splitAvgSamplesSlider"
                  : "contrastAvgSamplesSlider",
              ).value,
            ) || 5;

          const displayId =
            mode === "split" ? "splitHighlightLux" : "highlightLux";
          const luxDisplay = document.getElementById(displayId);
          const btnId =
            mode === "split"
              ? "splitMeasureHighlightBtn"
              : "measureHighlightBtn";
          const measureBtn = document.getElementById(btnId);

          // Show loading state
          measureBtn.disabled = true;
          measureBtn.textContent = "Measuring...";
          luxDisplay.textContent = "...";

          try {
            const response = await fetch(
              `/light-meter-highlight?samples=${samples}`,
            );
            const data = await response.json();

            if (data.status === "success") {
              this.highlightLux = data.lux;
              luxDisplay.textContent = data.lux.toFixed(1) + " lux";

              this.updateContrastButtons(mode);
              playBeep(800, 0.3, 0.2);
            } else {
              luxDisplay.textContent = "Error";
              this.showFeedback("Measurement error: " + data.error, "error");
            }
          } catch (error) {
            luxDisplay.textContent = "Error";
            this.showFeedback("Connection error: " + error.message, "error");
          } finally {
            measureBtn.disabled = false;
            measureBtn.textContent = "Measure Highlight";
          }
        }

        /**
         * Measure shadow area
         */
        async measureShadow(mode = "contrast") {
          const samples =
            parseInt(
              document.getElementById(
                mode === "split"
                  ? "splitAvgSamplesSlider"
                  : "contrastAvgSamplesSlider",
              ).value,
            ) || 5;

          const displayId = mode === "split" ? "splitShadowLux" : "shadowLux";
          const luxDisplay = document.getElementById(displayId);
          const btnId =
            mode === "split" ? "splitMeasureShadowBtn" : "measureShadowBtn";
          const measureBtn = document.getElementById(btnId);

          // Show loading state
          measureBtn.disabled = true;
          measureBtn.textContent = "Measuring...";
          luxDisplay.textContent = "...";

          try {
            const response = await fetch(
              `/light-meter-shadow?samples=${samples}`,
            );
            const data = await response.json();

            if (data.status === "success") {
              this.shadowLux = data.lux;
              luxDisplay.textContent = data.lux.toFixed(1) + " lux";

              this.updateContrastButtons(mode);
              playBeep(800, 0.3, 0.2);
            } else {
              luxDisplay.textContent = "Error";
              this.showFeedback("Measurement error: " + data.error, "error");
            }
          } catch (error) {
            luxDisplay.textContent = "Error";
            this.showFeedback("Connection error: " + error.message, "error");
          } finally {
            measureBtn.disabled = false;
            measureBtn.textContent = "Measure Shadow";
          }
        }

        /**
         * Update contrast/split mode buttons based on readings
         * Auto-triggers analysis when both measurements are complete
         */
        updateContrastButtons(mode) {
          const hasBoth = this.highlightLux !== null && this.shadowLux !== null;

          if (mode === "contrast") {
            document.getElementById("analyzeContrastBtn").disabled = !hasBoth;
            // Auto-analyze when both readings are available
            if (hasBoth) {
              this.analyzeContrast();
            }
          } else if (mode === "split") {
            document.getElementById("calculateSplitBtn").disabled = !hasBoth;
            // Auto-calculate split-grade when both readings are available
            if (hasBoth) {
              this.calculateSplitGrade();
            }
          }
        }

        /**
         * Analyze contrast from stored readings
         * DESIGN: Only measures contrast and recommends grade - NO exposure time calculation
         * Exposure time must be determined using Exposure Meter mode with the recommended grade filter
         */
        async analyzeContrast() {
          if (!this.highlightLux || !this.shadowLux) {
            this.showFeedback(
              "Measure both highlight and shadow first",
              "error",
            );
            return;
          }

          try {
            // Get current calibration and paper ID
            const paperId = this.currentPaperId || this.getCurrentPaperId();
            const calibration = this.calibration || 1000.0;

            // Send calibration along with the request
            const baseParams =
              `/light-meter-contrast?calibration=${calibration}&paper_id=${paperId}`;
            const response = await fetch(baseParams);
            const data = await response.json();

            if (data.status === "success") {
              this.deltaEV = data.delta_ev;
              this.recommendedGrade = data.recommended_grade;

              // Update displays - CONTRAST AND GRADE ONLY, NO EXPOSURE TIME
              document.getElementById("deltaEVDisplay").textContent =
                data.delta_ev.toFixed(1) + " EV";

              if (data.recommended_grade) {
                const grade = data.recommended_grade;

                document.getElementById("recommendedGrade").textContent =
                  grade.grade;
                document.getElementById("matchQuality").textContent =
                  grade.match_quality.charAt(0).toUpperCase() +
                  grade.match_quality.slice(1);

                // Analysis reasoning
                const reasoning =
                  grade.reasoning || `Grade ${grade.grade} recommended`;
                document.getElementById("analysisReasoning").textContent =
                  reasoning;

                console.log("Enhanced analysis data:", grade);
              }

              // Display exposure time (midpoint-based)
              if (data.exposure_times) {
                const times = data.exposure_times;
                this.contrastSuggestedTime = times.suggested_time;
                document.getElementById("suggestedExposureTime").textContent =
                  times.suggested_time + " sec";
                document.getElementById("midpointLuxDisplay").textContent =
                  (times.midpoint_lux ?? "--") + " lux";
                document.getElementById("exposureNote").textContent =
                  times.notes || "--";

                const sendContrastBtn =
                  document.getElementById("sendContrastToCalc");
                if (sendContrastBtn) {
                  sendContrastBtn.disabled = false;
                }

                console.log("Exposure time calculated:", times);
              } else {
                this.contrastSuggestedTime = null;
                // Clear exposure time displays if not available
                document.getElementById("suggestedExposureTime").textContent =
                  "-- sec";
                document.getElementById("midpointLuxDisplay").textContent =
                  "-- lux";
                document.getElementById("exposureNote").textContent = "--";
                const sendContrastBtn =
                  document.getElementById("sendContrastToCalc");
                if (sendContrastBtn) {
                  sendContrastBtn.disabled = true;
                }
              }

              playBeep(1000, 0.3, 0.3);
            } else {
              this.showFeedback("Analysis error: " + data.error, "error");
            }
          } catch (error) {
            this.showFeedback("Connection error: " + error.message, "error");
          }
        }

        /**
         * Clear contrast readings
         */
        async clearContrastReadings() {
          this.highlightLux = null;
          this.shadowLux = null;
          this.deltaEV = null;
          this.recommendedGrade = null;
          this.contrastSuggestedTime = null;

          // Clear displays
          document.getElementById("highlightLux").textContent = "-- lux";
          document.getElementById("shadowLux").textContent = "-- lux";
          document.getElementById("deltaEVDisplay").textContent = "--";
          document.getElementById("recommendedGrade").textContent = "--";
          document.getElementById("matchQuality").textContent = "--";

          document.getElementById("analysisReasoning").textContent = "--";

          // Clear exposure time displays
          document.getElementById("suggestedExposureTime").textContent =
            "-- sec";
          document.getElementById("midpointLuxDisplay").textContent = "-- lux";
          document.getElementById("exposureNote").textContent = "--";

          const sendContrastBtn = document.getElementById("sendContrastToCalc");
          if (sendContrastBtn) {
            sendContrastBtn.disabled = true;
          }

          // Disable buttons
          document.getElementById("analyzeContrastBtn").disabled = true;

          // Clear on server too
          try {
            await fetch("/light-meter-config?clear=true");
          } catch (e) {}

          this.showFeedback("Contrast readings cleared", "success");
        }

        /**
         * Send contrast analyzer suggested time to CALC tab
         */
        sendContrastToCalc() {
          const time = this.contrastSuggestedTime;
          if (!time || time <= 0) {
            this.showFeedback("No suggested time available", "error");
            return;
          }

          this.sendTimeToCalc(time, "Contrast Analyzer Suggested");
        }

        /**
         * Calculate split-grade exposure times from stored readings
         * DESIGN: Calculates absolute exposure times for both soft and hard exposures
         * Uses paper selection from PAPER & FILTER SETUP
         */
        async calculateSplitGrade() {
          if (!this.highlightLux || !this.shadowLux) {
            this.showFeedback(
              "Measure both highlight and shadow first",
              "error",
            );
            return;
          }

          // Get current paper_id from selection
          const paperId = this.currentPaperId || this.getCurrentPaperId();

          // Get calibration for current paper
          const calibration = this.calibration;

          console.log("Split-grade calculation starting...");
          console.log("Current paper ID:", paperId);
          console.log("Calibration:", calibration);
          console.log("Highlight lux:", this.highlightLux);
          console.log("Shadow lux:", this.shadowLux);

          const endpoint = "/light-meter-split-grade-heiland";

          // Build query parameters with paper_id
          const params = new URLSearchParams({
            highlight: this.highlightLux,
            shadow: this.shadowLux,
            calibration: calibration,
            paper_id: paperId,
          });

          console.log("Calling split-grade endpoint:", endpoint);
          console.log("Parameters:", params.toString());
          console.log(
            "Highlight:",
            this.highlightLux,
            "Shadow:",
            this.shadowLux,
            "PaperID:",
            paperId,
          );

          try {
            const response = await fetch(endpoint + "?" + params.toString());
            console.log("Response status:", response.status);

            const responseText = await response.text();
            console.log("Response text:", responseText);

            const data = JSON.parse(responseText);
            console.log("Parsed data:", data);

            if (data.status === "success" && data.result) {
              const result = data.result;
              console.log("Split-grade result:", result);

              // Validate result has required fields
              if (
                !result.soft_time ||
                !result.hard_time ||
                !result.total_time
              ) {
                console.error("Missing required fields in result:", result);
                this.showFeedback("Invalid result from server", "error");
                return;
              }

              this.splitGradeResult = result;

              // Store paper info for sending to CALC
              this.splitGradeResult.paperId = paperId;
              this.splitGradeResult.neutralTime = result.total_time;

              // Update displays with absolute exposure times
              document.getElementById("splitDeltaEV").textContent =
                result.delta_ev.toFixed(1) + " EV";

              document.getElementById("splitMatchQuality").textContent =
                result.match_quality;

              // Show match quality note
              const matchNote = document.getElementById("splitMatchNote");
              if (
                result.match_quality === "poor" &&
                result.total_printable_ev &&
                result.total_printable_ev > result.delta_ev + 2
              ) {
                matchNote.textContent =
                  "Note: Negative contrast is lower than paper's full range. Single-grade printing may be sufficient.";
                matchNote.style.color = "#666";
              } else if (
                result.match_quality === "excellent" ||
                result.match_quality === "good"
              ) {
                matchNote.textContent =
                  "Split-grade is appropriate for this negative contrast.";
                matchNote.style.color = "var(--accent)";
              } else {
                matchNote.textContent = "";
              }

              document.getElementById("splitPrintableEV").textContent =
                (result.total_printable_ev || 0).toFixed(1) + " EV";

              document.getElementById("splitPaperGamma").textContent = (
                result.paper_gamma || 0.7
              ).toFixed(2);

              document.getElementById("splitContrastIndex").textContent = (
                result.paper_contrast_index || 1.0
              ).toFixed(2);

              const dmin = result.paper_dmin || 0.05;
              const dmax = result.paper_dmax || 2.0;
              document.getElementById("splitDensityRange").textContent =
                `${(dmax - dmin).toFixed(2)} (Dmin: ${dmin.toFixed(2)}, Dmax: ${dmax.toFixed(2)})`;

              const reasoning = result.selection_reason
                ? `${result.selection_reason} (Match: ${result.match_quality})`
                : `Match: ${result.match_quality}`;
              document.getElementById("splitAnalysisReasoning").textContent =
                reasoning;

              // Calculate split-adjusted times
              const softAdj = result.soft_time * (result.soft_percent / 100);
              const hardAdj = result.hard_time * (result.hard_percent / 100);
              const totalAdj = softAdj + hardAdj;

              result.soft_time_adjusted = softAdj;
              result.hard_time_adjusted = hardAdj;
              result.total_time_adjusted = totalAdj;

              // Soft exposure (split-adjusted)
              document.getElementById("splitSoftTime").textContent =
                softAdj.toFixed(2) + "s";
              document.getElementById("splitSoftFilterName").textContent =
                result.soft_filter;
              document.getElementById("splitSoftPercent").textContent =
                result.soft_percent.toFixed(0) + "%";

              // Hard exposure (split-adjusted)
              document.getElementById("splitHardTime").textContent =
                hardAdj.toFixed(2) + "s";
              document.getElementById("splitHardFilterName").textContent =
                result.hard_filter;
              document.getElementById("splitHardPercent").textContent =
                result.hard_percent.toFixed(0) + "%";

              // Total time (split-adjusted)
              document.getElementById("splitTotalTime").textContent =
                totalAdj.toFixed(2) + "s";

              // Enable send button
              document.getElementById("sendSplitBothToCalc").disabled = false;

              playBeep(1000, 0.3, 0.3);
            } else {
              console.error("Server returned non-success response:", data);
              this.showFeedback(
                "Calculation error: " + (data.error || "Unknown"),
                "error",
              );
            }
          } catch (error) {
            console.error("Split-grade calculation error:", error);
            this.showFeedback("Connection error: " + error.message, "error");
          }
        }

        /**
         * Clear split-grade readings
         */
        async clearSplitReadings() {
          this.highlightLux = null;
          this.shadowLux = null;
          this.splitGradeResult = null;

          // Clear displays
          document.getElementById("splitHighlightLux").textContent = "-- lux";
          document.getElementById("splitShadowLux").textContent = "-- lux";
          document.getElementById("splitDeltaEV").textContent = "--";
          document.getElementById("splitMatchQuality").textContent = "--";
          document.getElementById("splitMatchNote").textContent = "--";
          document.getElementById("splitPrintableEV").textContent = "-- EV";
          document.getElementById("splitPaperGamma").textContent = "--";
          document.getElementById("splitContrastIndex").textContent = "--";
          document.getElementById("splitDensityRange").textContent =
            "-- (Dmin-Dmax)";
          document.getElementById("splitAnalysisReasoning").textContent = "--";
          document.getElementById("splitSoftTime").textContent = "--.--";
          document.getElementById("splitSoftFilterName").textContent = "--";
          document.getElementById("splitSoftPercent").textContent = "--%";
          document.getElementById("splitHardTime").textContent = "--.--";
          document.getElementById("splitHardFilterName").textContent = "--";
          document.getElementById("splitHardPercent").textContent = "--%";
          document.getElementById("splitTotalTime").textContent = "--.--";

          // Disable buttons
          document.getElementById("calculateSplitBtn").disabled = true;
          document.getElementById("sendSplitBothToCalc").disabled = true;

          // Clear on server too
          try {
            await fetch("/light-meter-config?clear=true");
          } catch (e) {}

          this.showFeedback("Split-grade readings cleared", "success");
        }

        /**
         * Send both split-grade times to CALC tab
         */
        sendSplitBothToCalc() {
          if (!this.splitGradeResult) {
            this.showFeedback("No split-grade result available", "error");
            return;
          }

          const softTime =
            this.splitGradeResult.soft_time_adjusted ||
            this.splitGradeResult.soft_time;
          const hardTime =
            this.splitGradeResult.hard_time_adjusted ||
            this.splitGradeResult.hard_time;

          if (!softTime || !hardTime) {
            this.showFeedback("Split-grade times are missing", "error");
            return;
          }

          const totalTime =
            this.splitGradeResult.total_time_adjusted ||
            this.splitGradeResult.total_time ||
            softTime + hardTime;

          applySplitGradeToCalc({
            neutralTime: totalTime,
            highlightsBase: softTime,
            shadowsBase: hardTime,
            softTime: softTime,
            hardTime: hardTime,
            totalTime: totalTime,
            softFilter: this.splitGradeResult.soft_filter,
            hardFilter: this.splitGradeResult.hard_filter,
            softFactor: this.splitGradeResult.soft_factor,
            hardFactor: this.splitGradeResult.hard_factor,
          });

          playBeep(800, 0.3, 0.3);
          this.showFeedback(
            `Split-grade sent: ${softTime.toFixed(2)}s + ${hardTime.toFixed(
              2,
            )}s = ${totalTime.toFixed(2)}s total`,
            "success",
          );
        }

        /**
         * Send time to CALC tab timer
         * Uses the same mechanism as TEST STRIP tab
         */
        sendTimeToCalc(time, source) {
          if (!time || time <= 0) {
            this.showFeedback("Invalid exposure time", "error");
            return;
          }

          // Update CALC tab base time slider
          const baseSlider = document.getElementById("baseTimeSlider");
          if (baseSlider) {
            // Clamp to slider range
            const clampedTime = Math.min(
              Math.max(time, parseFloat(baseSlider.min)),
              parseFloat(baseSlider.max),
            );
            baseSlider.value = clampedTime;
            baseSlider.dispatchEvent(new Event("input", { bubbles: true }));
          }

          // Reset the incremental timer for fresh start
          if (window.incrementalTimer) {
            window.incrementalTimer.baseTime = time;
            window.incrementalTimer.reset();
          }

          // Switch to CALC tab
          switchTab("calc");

          // Scroll to top
          const container = document.querySelector(".container");
          if (container) container.scrollTop = 0;
          window.scrollTo(0, 0);

          // Audio feedback
          playBeep(800, 0.3, 0.3);

          // Show feedback
          this.showFeedback(`${source}: ${time.toFixed(2)}s → CALC`, "success");

          // Log to exposure log manager
          if (window.exposureLogManager) {
            window.exposureLogManager.addCalcPhase({
              baseTime: time,
              stopAdjustment: 0,
              finalTime: time,
              filterContext: source,
              notes: `Via light meter: ${source}`,
            });
          }
        }

        /**
         * Calculate calibration from lux and time
         */
        calculateCalibration() {
          const luxInput = document.getElementById("calMeasuredLux");
          const timeInput = document.getElementById("calCorrectTime");

          const lux = parseFloat(luxInput.value);
          const time = parseFloat(timeInput.value);

          if (!lux || lux <= 0 || !time || time <= 0) {
            this.showFeedback("Enter valid lux and time values", "error");
            return;
          }

          const calibration = lux * time;

          // Update calibration input
          document.getElementById("calibrationInput").value =
            calibration.toFixed(0);

          // Save calibration
          this.calibration = calibration;
          this.saveCalibration();
          this.updateCalibrationDisplay();

          // Send to server immediately
          this.sendCalibrationToServer(calibration);

          this.showFeedback(
            `Calibration calculated: ${calibration.toFixed(0)} lux·s`,
            "success",
          );
        }

        /**
         * Save calibration from input field
         */
        saveCalibrationFromInput() {
          const input = document.getElementById("calibrationInput");
          const value = parseFloat(input.value);

          if (!value || value <= 0) {
            this.showFeedback("Enter a valid calibration value", "error");
            return;
          }

          this.calibration = value;
          this.saveCalibration();
          this.updateCalibrationDisplay();

          // Also send to server
          this.sendCalibrationToServer(value);

          this.showFeedback(
            `Calibration saved: ${value.toFixed(0)} lux·s`,
            "success",
          );
        }

        /**
         * Send calibration to server
         */
        async sendCalibrationToServer(value) {
          try {
            const paperId = this.currentPaperId || this.getCurrentPaperId();
            await fetch(
              `/light-meter-calibrate?constant=${value}&paper_id=${paperId}`,
            );
          } catch (e) {
            console.warn("Could not send calibration to server:", e);
          }
        }

        /**
         * Load calibration from localStorage
         * Now loads all calibrations as a dict keyed by paper ID
         */
        loadAllCalibrations() {
          const stored = localStorage.getItem(
            STORAGE_KEYS.LIGHT_METER_CALIBRATIONS,
          );
          if (stored) {
            try {
              return JSON.parse(stored);
            } catch (e) {
              console.warn("Could not parse calibrations, using defaults");
            }
          }
          // Migrate old single calibration value if exists
          const oldCalibration = localStorage.getItem("lightMeterCalibration");
          if (oldCalibration) {
            const defaultCalibrations = this.getDefaultCalibrations();
            defaultCalibrations["ilford_mg4_rc"] = parseFloat(oldCalibration);
            localStorage.removeItem("lightMeterCalibration"); // Remove old key
            this.saveAllCalibrations(defaultCalibrations);
            return defaultCalibrations;
          }
          return this.getDefaultCalibrations();
        }

        /**
         * Get default calibrations for all paper types
         */
        getDefaultCalibrations() {
          return {
            // Ilford papers
            ilford_mg4_rc: 1000,
            ilford_warmtone: 1000,
            ilford_cooltone: 1000,
            ilford_portfolio: 1000,
            // FOMA papers
            foma_fomaspeed: 1000,
            foma_fomatone: 1000,
          };
        }


        /**
         * Get current paper ID based on brand and type selection
         */
        getCurrentPaperId() {
          if (this.currentPaperId) {
            return this.currentPaperId;
          }

          const papers = Array.isArray(this.papersList) ? this.papersList : [];
          if (papers.length === 0) {
            return "";
          }

          if (this.paperBrand === "ilford") {
            const ilfordPaper = papers.find((paper) =>
              paper.id.startsWith("ilford"),
            );
            return ilfordPaper ? ilfordPaper.id : papers[0].id;
          }

          if (this.paperBrand === "foma") {
            const fomaPaper = papers.find((paper) =>
              paper.id.startsWith("foma"),
            );
            return fomaPaper ? fomaPaper.id : papers[0].id;
          }

          return papers[0].id;
        }

        /**
         * Get calibration for current paper
         */
        getCalibrationForCurrentPaper() {
          const paperId = this.getCurrentPaperId();
          return this.calibrations[paperId] || 1000;
        }

        /**
         * Save all calibrations to localStorage
         */
        saveAllCalibrations(calibrations = null) {
          const data = calibrations || this.calibrations;
          localStorage.setItem(
            STORAGE_KEYS.LIGHT_METER_CALIBRATIONS,
            JSON.stringify(data),
          );
        }

        /**
         * Save calibration for current paper to localStorage
         */
        saveCalibration() {
          const paperId = this.getCurrentPaperId();
          this.calibrations[paperId] = this.calibration;
          this.saveAllCalibrations();
        }

        /**
         * Load calibration for current paper (updates this.calibration)
         */
        loadCalibrationForCurrentPaper() {
          this.calibration = this.getCalibrationForCurrentPaper();
        }

        /**
         * Get human-readable paper name for display
         */
        getCurrentPaperName() {
          const paperId = this.getCurrentPaperId();
          const paper = Array.isArray(this.papersList)
            ? this.papersList.find((p) => p.id === paperId)
            : null;

          if (paper && paper.display_name) {
            return paper.display_name;
          }

          return paperId || "";
        }

        /**
         * Update calibration display with current paper name and value
         */
        updateCalibrationDisplay() {
          // Update calibration value
          const display = document.getElementById("meterCalibrationValue");
          if (display) {
            display.textContent = this.calibration.toFixed(0) + " lux·s";
          }

          // Update paper name display
          const paperNameDisplay = document.getElementById(
            "meterCurrentPaperName",
          );
          if (paperNameDisplay) {
            paperNameDisplay.textContent = this.getCurrentPaperName();
          }

          // Update calibration input field if present
          const calibrationInput = document.getElementById("calibrationInput");
          if (calibrationInput) {
            calibrationInput.value = this.calibration.toFixed(0);
          }
        }

        /**
         * Show feedback message (uses existing pattern)
         */
        showFeedback(message, type = "success") {
          if (settingsManager && settingsManager.showAllProfilesFeedback) {
            settingsManager.showAllProfilesFeedback(message, type);
          } else {
            console.log(`[${type}] ${message}`);
          }
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        // Initialize audio service first (for all sound functionality)
        audioService = new AudioService();
        audioService.init();

        // Initialize settings manager first
        settingsManager = new SettingsManager();

        // Initialize calculator
        window.incrementalTimer = new IncrementalTimer();

        // Initialize the combined calculator (replaces both old calculators)
        window.heightCalculator = new EnlargerHeightCalculator(
          window.incrementalTimer,
        );

        // Initialize custom filter bank (feeds contrast factor)
        window.customFilterBankManager = new CustomFilterBankManager(
          window.heightCalculator,
        );

        // Initialize test strip generator
        window.fstopTestGenerator = new FStopTestStripGenerator();

        // Initialize chemical manager (UPDATED)
        window.chemicalManager = new ChemicalManager();

        // Initialize split-grade calculator
        window.splitGradeCalculator = new SplitGradeCalculator();

        // Initialize light meter manager
        window.lightMeterManager = new LightMeterManager();

        // Initialize countdown manager
        window.countdownManager = new CountdownManager();

        // Initialize timers
        timerManager.init();

        // Apply saved settings to UI and instances on startup
        loadSettingsToUI();

        // Initialize fullscreen manager
        const fullscreenManager = new FullscreenManager();

        // Initialize relay manager
        window.relayManager = new RelayManager();

        // Initialize temperature manager
        window.temperatureManager = new TemperatureManager();

        // Initialize Real-Time Auto Factorial Development manager
        window.realTimeAutoFactorial = new RealTimeAutoFactorial(timerManager);
        window.realTimeAutoFactorial.init();

        // Color scheme selector
        document.querySelectorAll(".toggle-btn[data-scheme]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const scheme = btn.getAttribute("data-scheme");
            settingsManager.setColorScheme(scheme);
          });
        });

        document
          .getElementById("testCountdownBeep")
          ?.addEventListener("click", () => {
            // Test the different countdown beep patterns
            playCountdownBeep(5); // Early second beep
            setTimeout(() => playCountdownBeep(4), 300);
            setTimeout(() => playCountdownBeep(3), 600); // Last 3 seconds beep
            setTimeout(() => playPreset("countdownComplete"), 900); // Final beep
          });

        // Settings panel event listeners
        document
          .getElementById("saveGlobalSettings")
          .addEventListener("click", () => {
            settingsManager.saveGlobalSettings();
          });

        // Live-apply settings as user edits (debounced)
        (function bindLiveSettings() {
          const toBind = [
            { id: "settingBaseTime", evt: "input" },
            { id: "settingDevTime", evt: "input" },
            { id: "settingStopTime", evt: "input" },
            { id: "settingFixTime", evt: "input" },
            { id: "settingFloTime", evt: "input" },
            { id: "settingCountdownDelay", evt: "input" },
            { id: "settingCountdownBeep", evt: "change" },
            { id: "settingCountdownPattern", evt: "change" },
            { id: "settingAutoAdvance", evt: "change" },
            { id: "settingAutoAdvanceDelay", evt: "input" },
            { id: "safelightAutoOff", evt: "change" },
            { id: "settingCalcWarningBeep", evt: "change" },
            { id: "settingCalcEndBeep", evt: "change" },
            { id: "settingTimerWarningBeep", evt: "change" },
            { id: "settingTimerEndBeep", evt: "change" },
            { id: "settingStopIncrement", evt: "change" },
            { id: "proofStabilityEnabled", evt: "change" },
            { id: "proofStabilityBeep", evt: "change" },
            { id: "proofStabilityTolerance", evt: "input" },
            { id: "proofStabilityMinStable", evt: "input" },
            { id: "proofStabilityMaxWait", evt: "input" },
            { id: "proofStabilityMinDelta", evt: "input" },
          ];
          toBind.forEach(({ id, evt }) => {
            const el = document.getElementById(id);
            if (!el) return;
            let t = null;
            el.addEventListener(evt, () => {
              clearTimeout(t);
              t = setTimeout(() => {
                settingsManager.applyLiveSettings();
              }, 150);
            });
          });
        })();

        // Initialize denom and controls (functions moved outside DOMContentLoaded)
        window.stopDenominator =
          window.stopDenominator ||
          (settingsManager && settingsManager.settings.stopDenominator) ||
          3;
        setActiveSeg("calcIncrementSeg", window.stopDenominator);
        setActiveSeg("testIncrementSeg", window.stopDenominator);
        initSegControl("calcIncrementSeg");
        initSegControl("testIncrementSeg");
        // Backwards compatibility: update select values if present
        const calcOld = document.getElementById("calcIncrementDenom");
        const testOld = document.getElementById("testIncrementDenom");
        if (calcOld) calcOld.value = window.stopDenominator;
        if (testOld) testOld.value = window.stopDenominator;
        updateAllRulers();

        // Timer profile management in timer tab
        document
          .getElementById("saveTimerProfile")
          ?.addEventListener("click", () => {
            const profileName =
              document.getElementById("timerProfileName").value;
            if (settingsManager.saveCurrentProfile(profileName)) {
              document.getElementById("timerProfileName").value = "";
            }
          });

        document
          .getElementById("clearTimerProfiles")
          ?.addEventListener("click", () => {
            settingsManager.clearAllProfiles();
          });

        // Test strip profile management in test tab
        document
          .getElementById("saveTestStripProfile")
          ?.addEventListener("click", () => {
            const profileName = document.getElementById(
              "testStripProfileName",
            ).value;
            if (
              window.fstopTestGenerator &&
              window.fstopTestGenerator.saveProfile(profileName)
            ) {
              document.getElementById("testStripProfileName").value = "";
            }
          });

        document
          .getElementById("clearTestStripProfiles")
          ?.addEventListener("click", () => {
            if (window.fstopTestGenerator) {
              window.fstopTestGenerator.clearAllProfiles();
            }
          });

        // Split-grade CALC tab handlers
        document
          .getElementById("applyHighlights")
          ?.addEventListener("click", () => {
            if (
              appState.calculator.splitGrade.enabled &&
              appState.calculator.splitGrade.softTime !== null
            ) {
              const time = appState.calculator.splitGrade.softTime;
              const baseSlider = document.getElementById("baseTimeSlider");
              if (baseSlider) {
                baseSlider.value = time;
                baseSlider.dispatchEvent(new Event("input", { bubbles: true }));
                // Reset CALC timer
                if (window.incrementalTimer) {
                  window.incrementalTimer.reset();
                }
                playBeep(800, 0.3, 0.3);
                settingsManager.showAllProfilesFeedback(
                  `Applied Highlights (F${
                    appState.calculator.splitGrade.softFilter
                  }): ${time.toFixed(2)}s`,
                  "success",
                );
              }
            }
          });

        document
          .getElementById("applyShadows")
          ?.addEventListener("click", () => {
            if (
              appState.calculator.splitGrade.enabled &&
              appState.calculator.splitGrade.hardTime !== null
            ) {
              const time = appState.calculator.splitGrade.hardTime;
              const baseSlider = document.getElementById("baseTimeSlider");
              if (baseSlider) {
                baseSlider.value = time;
                baseSlider.dispatchEvent(new Event("input", { bubbles: true }));
                // Reset CALC timer
                if (window.incrementalTimer) {
                  window.incrementalTimer.reset();
                }
                playBeep(800, 0.3, 0.3);
                settingsManager.showAllProfilesFeedback(
                  `Applied Shadows (F${
                    appState.calculator.splitGrade.hardFilter
                  }): ${time.toFixed(2)}s`,
                  "success",
                );
              }
            }
          });

        document
          .getElementById("clearSplitData")
          ?.addEventListener("click", () => {
            appState.calculator.splitGrade = {
              enabled: false,
              neutralTime: null,
              highlightsBase: null,
              shadowsBase: null,
              softTime: null,
              hardTime: null,
              totalTime: null,
              softFilter: null,
              hardFilter: null,
              paperBrand: null,
              fomaPaperType: null,
              burnPercent: null,
              softFactor: null,
              hardFactor: null,
            };
            const display = document.getElementById("splitGradeDisplay");
            if (display) display.style.display = "none";
            playBeep(400, 0.3, 0.3);
            settingsManager.showAllProfilesFeedback(
              "Split-grade data cleared",
              "success",
            );
          });

        // Combined export/import in settings tab
        document
          .getElementById("exportAllProfiles")
          ?.addEventListener("click", () => {
            settingsManager.exportAllData();
          });

        document
          .getElementById("importAllProfiles")
          ?.addEventListener("click", () => {
            document.getElementById("allProfilesFileInput").click();
          });

        document
          .getElementById("allProfilesFileInput")
          .addEventListener("change", (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
              settingsManager.importAllData(event.target.result);
              e.target.value = "";
            };
            reader.onerror = () => {
              settingsManager.showAllProfilesFeedback(
                "Error reading file",
                "error",
              );
              e.target.value = "";
            };
            reader.readAsText(file);
          });

        document
          .getElementById("resetAllSettings")
          .addEventListener("click", () => {
            settingsManager.resetAllSettings();
          });

        // Initialize audio context on any user interaction
        document.addEventListener("click", initAudioContext);

        // ===== CENTRALIZED EVENT DELEGATION =====
        // Handle all timer-related button clicks via delegation
        document.addEventListener("click", (e) => {
          // Timer toggle buttons (Start/Pause)
          const timerBtn = e.target.closest(
            '[id^="btn"][id$="Dev"], [id^="btn"][id$="Stop"], [id^="btn"][id$="Fix"], [id^="btn"][id$="Flo"]',
          );
          if (timerBtn && timerBtn.id.startsWith("btn")) {
            const timerName = timerBtn.id.replace("btn", "");
            const timer = timerManager?.timers.find(
              (t) => t.name === timerName,
            );
            if (timer) {
              e.preventDefault();
              timer.toggle();
            }
            return;
          }

          // Timer action buttons (reset only - plus/minus handled by hold events)
          const timerActionBtn = e.target.closest(
            "button[data-timer][data-action]",
          );
          if (timerActionBtn) {
            const timerName = timerActionBtn.getAttribute("data-timer");
            const action = timerActionBtn.getAttribute("data-action");
            const timer = timerManager?.timers.find(
              (t) => t.name === timerName,
            );
            if (timer) {
              e.preventDefault();
              if (action === "reset") timer.reset();
              // plus/minus actions are handled by hold-to-adjust events
            }
            return;
          }

          // Calculator buttons
          if (e.target.id === "startExposure" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.toggle();
            return;
          }
          if (e.target.id === "stopCalcTimer" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.stopCurrentExposure();
            return;
          }
          if (e.target.id === "resetCalcTimer" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.reset();
            return;
          }
          if (e.target.id === "repeatExposure" && window.incrementalTimer) {
            e.preventDefault();
            window.incrementalTimer.repeatLast();
            return;
          }

          // Relay toggle buttons
          const relayToggleBtn = e.target.closest(".settings-btn[data-relay]");
          if (relayToggleBtn && window.relayManager) {
            const relayNum = parseInt(
              relayToggleBtn.getAttribute("data-relay"),
            );
            e.preventDefault();
            window.relayManager.toggleRelay(relayNum);
            return;
          }

          // Load buttons (consolidated - profile, preset, chemical, teststrip, or split)
          const loadBtn = e.target.closest(
            ".load-btn[data-context][data-name]",
          );
          if (loadBtn) {
            const context = loadBtn.getAttribute("data-context");
            const name = loadBtn.getAttribute("data-name");
            e.preventDefault();

            if (context === "profile" && settingsManager) {
              const profile = settingsManager.profiles.find(
                (p) => p.name === name,
              );
              if (profile) {
                settingsManager.loadProfile(profile);
              }
            } else if (context === "preset" && window.chemicalManager) {
              const preset = window.chemicalManager.chemicalPresets.find(
                (p) => p.name === name,
              );
              if (preset) {
                window.chemicalManager.loadChemicalPreset(preset);
              }
            } else if (context === "teststrip" && window.fstopTestGenerator) {
              window.fstopTestGenerator.loadProfile(name);
            } else if (context === "split" && window.splitGradeCalculator) {
              const preset = window.splitGradeCalculator.splitPresets.find(
                (p) => p.name === name,
              );
              if (preset) {
                window.splitGradeCalculator.loadPreset(preset);
              }
            }
            return;
          }

          // Delete buttons (consolidated - profile, preset, chemical, teststrip, or split)
          const deleteBtn = e.target.closest(".delete-btn[data-context]");
          if (deleteBtn) {
            const context = deleteBtn.getAttribute("data-context");
            e.preventDefault();

            if (context === "profile" && settingsManager) {
              const profileName = deleteBtn.getAttribute("data-name");
              settingsManager.deleteProfile(profileName);
            } else if (context === "preset" && window.chemicalManager) {
              const presetName = deleteBtn.getAttribute("data-name");
              window.chemicalManager.deleteChemicalPreset(presetName);
            } else if (context === "chemical" && window.chemicalManager) {
              const id = parseInt(deleteBtn.getAttribute("data-id"));
              window.chemicalManager.deleteChemical(id);
            } else if (context === "teststrip" && window.fstopTestGenerator) {
              const profileName = deleteBtn.getAttribute("data-name");
              window.fstopTestGenerator.deleteProfile(profileName);
            } else if (context === "split" && window.splitGradeCalculator) {
              const presetName = deleteBtn.getAttribute("data-name");
              window.splitGradeCalculator.deletePreset(presetName);
            }
            return;
          }

          // Renew button (for chemical shelf life)
          const renewBtn = e.target.closest(
            ".renew-btn[data-context][data-id]",
          );
          if (renewBtn && window.chemicalManager) {
            const id = parseInt(renewBtn.getAttribute("data-id"));
            e.preventDefault();
            window.chemicalManager.renewChemical(id);
            return;
          }

          // Dilution buttons
          const dilutionBtn = e.target.closest(".toggle-btn[data-ratio]");
          if (dilutionBtn && window.chemicalManager) {
            e.preventDefault();
            document
              .querySelectorAll(".toggle-btn[data-ratio]")
              .forEach((b) => b.classList.remove("active"));
            dilutionBtn.classList.add("active");
            window.chemicalManager.dilutionRatio =
              dilutionBtn.getAttribute("data-ratio");
            window.chemicalManager.updateMixCalculator();
            return;
          }

          // Paper size buttons
          const paperSizeBtn = e.target.closest(".toggle-btn[data-size]");
          if (paperSizeBtn && window.chemicalManager) {
            const size = parseFloat(paperSizeBtn.getAttribute("data-size"));
            if (size) {
              e.preventDefault();
              window.chemicalManager.setPaperSize(size);
              if (window.chemicalManager.customPaperSizeInput) {
                window.chemicalManager.customPaperSizeInput.value =
                  size.toFixed(3);
              }
            }
            return;
          }

          // Color scheme buttons
          const colorSchemeBtn = e.target.closest(".toggle-btn[data-scheme]");
          if (colorSchemeBtn && settingsManager) {
            const scheme = colorSchemeBtn.getAttribute("data-scheme");
            e.preventDefault();
            settingsManager.setColorScheme(scheme);
            return;
          }
        });

        // Hold-to-adjust functionality for timer +/- buttons
        const holdIntervals = new Map(); // Store interval IDs for each button

        function startHoldAdjustment(button, timer, adjustment) {
          // Initial adjustment
          timer.adjustTime(adjustment);

          // Start continuous adjustment after 500ms delay
          const intervalId = setInterval(() => {
            timer.adjustTime(adjustment);
          }, 200); // Adjust every 200ms while holding

          holdIntervals.set(button, intervalId);
        }

        function stopHoldAdjustment(button) {
          const intervalId = holdIntervals.get(button);
          if (intervalId) {
            clearInterval(intervalId);
            holdIntervals.delete(button);
          }
        }

        // Mouse events for desktop
        document.addEventListener("mousedown", (e) => {
          const adjustBtn = e.target.closest(
            "button[data-timer][data-action='plus'], button[data-timer][data-action='minus']",
          );
          if (adjustBtn) {
            const timerName = adjustBtn.getAttribute("data-timer");
            const action = adjustBtn.getAttribute("data-action");
            const timer = timerManager?.timers.find(
              (t) => t.name === timerName,
            );

            if (timer && !timer.state.isRunning) {
              const adjustment = action === "plus" ? 1 : -1;
              startHoldAdjustment(adjustBtn, timer, adjustment);
            }
          }
        });

        document.addEventListener("mouseup", (e) => {
          const adjustBtn = e.target.closest(
            "button[data-timer][data-action='plus'], button[data-timer][data-action='minus']",
          );
          if (adjustBtn) {
            stopHoldAdjustment(adjustBtn);
          }
        });

        document.addEventListener("mouseleave", (e) => {
          // Stop all holds if mouse leaves any button
          holdIntervals.forEach((intervalId, button) => {
            clearInterval(intervalId);
          });
          holdIntervals.clear();
        });

        // Touch events for mobile
        document.addEventListener("touchstart", (e) => {
          const adjustBtn = e.target.closest(
            "button[data-timer][data-action='plus'], button[data-timer][data-action='minus']",
          );
          if (adjustBtn) {
            e.preventDefault();
            const timerName = adjustBtn.getAttribute("data-timer");
            const action = adjustBtn.getAttribute("data-action");
            const timer = timerManager?.timers.find(
              (t) => t.name === timerName,
            );

            if (timer && !timer.state.isRunning) {
              const adjustment = action === "plus" ? 1 : -1;
              startHoldAdjustment(adjustBtn, timer, adjustment);
            }
          }
        });

        document.addEventListener("touchend", (e) => {
          const adjustBtn = e.target.closest(
            "button[data-timer][data-action='plus'], button[data-timer][data-action='minus']",
          );
          if (adjustBtn) {
            e.preventDefault();
            stopHoldAdjustment(adjustBtn);
          }
        });

        document.addEventListener("touchcancel", (e) => {
          // Stop all holds on touch cancel
          holdIntervals.forEach((intervalId, button) => {
            clearInterval(intervalId);
          });
          holdIntervals.clear();
        });

        // Event delegation for segmented controls (f-stop denominator)
        document.addEventListener("click", (e) => {
          const segmentedBtn = e.target.closest(".segmented-btn[data-denom]");
          if (segmentedBtn) {
            const container = segmentedBtn.closest(".segmented-control");
            if (container) {
              const denom = parseInt(
                segmentedBtn.getAttribute("data-denom"),
                10,
              );
              e.preventDefault();

              // Update all buttons in this container
              container.querySelectorAll(".segmented-btn").forEach((btn) => {
                btn.classList.remove("active");
                btn.setAttribute("aria-pressed", "false");
              });
              segmentedBtn.classList.add("active");
              segmentedBtn.setAttribute("aria-pressed", "true");

              // Update global denominator
              window.stopDenominator = denom;

              // Sync all segmented controls
              document
                .querySelectorAll(".segmented-control")
                .forEach((cont) => {
                  cont.querySelectorAll(".segmented-btn").forEach((btn) => {
                    const btnDenom = parseInt(
                      btn.getAttribute("data-denom"),
                      10,
                    );
                    if (btnDenom === denom) {
                      btn.classList.add("active");
                      btn.setAttribute("aria-pressed", "true");
                    } else {
                      btn.classList.remove("active");
                      btn.setAttribute("aria-pressed", "false");
                    }
                  });
                });

              // Update calculators
              if (window.incrementalTimer) {
                window.incrementalTimer.updateCalculations();
                window.incrementalTimer.render();
              }
              if (window.fstopTestGenerator) {
                window.fstopTestGenerator.generateSteps();
                window.fstopTestGenerator.updateDisplay();
              }
              try {
                updateAllRulers();
              } catch (e) {}
              try {
                updateChart();
              } catch (e) {}
            }
          }
        });

        // Initialize collapsible rows in the CALC, SPLIT, CHEMICAL, TIMER, and SETTINGS tabs
        (function initCalcCollapsibles() {
          const STORAGE_KEY = "calc_collapsed";
          let stored = JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}");
          const sections = document.querySelectorAll(
            "#calc .collapsible, #split .collapsible, #fstop-test .collapsible, #chemical .collapsible, #timer .collapsible, #settings .collapsible, #light-meter .collapsible",
          );
          // Clean up any stored keys that no longer correspond to existing sections
          const existingIds = Array.from(sections)
            .map((s) => s.getAttribute("data-id"))
            .filter(Boolean);
          Object.keys(stored).forEach((key) => {
            if (!existingIds.includes(key)) {
              delete stored[key];
            }
          });
          // Persist cleaned state back to storage
          localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
          sections.forEach((sec) => {
            const id = sec.getAttribute("data-id") || "";
            const header = sec.querySelector(".collapsible-header");
            const content = sec.querySelector(".collapsible-content");
            if (!header || !content) return;

            // Default: collapsed unless explicitly set to false in storage
            const collapsed = stored[id] !== false;
            header.setAttribute("aria-expanded", collapsed ? "false" : "true");
            content.style.maxHeight = collapsed
              ? "0px"
              : content.scrollHeight + "px";

            header.addEventListener("click", () => {
              const expanded = header.getAttribute("aria-expanded") === "true";
              header.setAttribute("aria-expanded", expanded ? "false" : "true");
              if (expanded) {
                content.style.maxHeight = "0px";
                stored[id] = true;
              } else {
                content.style.maxHeight = content.scrollHeight + "px";
                stored[id] = false;
              }
              localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));
            });

            // Expand to fit dynamic content changes (new profiles/presets/etc.)
            const observer = new MutationObserver(() => {
              if (header.getAttribute("aria-expanded") === "true") {
                content.style.maxHeight = content.scrollHeight + "px";
              }
            });
            observer.observe(content, {
              childList: true,
              subtree: true,
              characterData: true,
            });
          });

          const activeTab = document.querySelector(".tab-content.active");
          if (activeTab) {
            refreshCollapsibleHeights(activeTab);
          }

          // Recalculate max-heights on resize (for fluid content)
          window.addEventListener("resize", () => {
            const currentTab = document.querySelector(".tab-content.active");
            if (currentTab) {
              refreshCollapsibleHeights(currentTab);
            }
          });
        })();

        // Initialize exposure log manager
        window.exposureLogManager = new ExposureLogManager();

        // Initialize update status manager
        window.updateStatusManager = new UpdateStatusManager();

        // LOGS tab event listeners
        document.getElementById("exportCSV")?.addEventListener("click", () => {
          if (window.exposureLogManager) {
            window.exposureLogManager.exportCSV();
          }
        });

        document.getElementById("exportJSON")?.addEventListener("click", () => {
          if (window.exposureLogManager) {
            window.exposureLogManager.exportJSON();
          }
        });

        document.getElementById("importJSON")?.addEventListener("click", () => {
          if (window.exposureLogManager) {
            window.exposureLogManager.importJSON();
          }
        });

        document
          .getElementById("clearAllLogs")
          ?.addEventListener("click", () => {
            if (window.exposureLogManager) {
              window.exposureLogManager.clearAll();
            }
          });

        // Initial chart update
        updateChart();
      });
    </script>
  </body>
</html>
